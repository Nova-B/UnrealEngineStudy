<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unreal Engine - Tick System</title>
    <style>
        :root {
            --bg: #1a1a2e;
            --bg-card: #16213e;
            --bg-code: #0f0f1a;
            --bg-sidebar: #12121f;
            --text: #eaeaea;
            --text-muted: #888;
            --text-dim: #666;
            --accent: #4f8cff;
            --accent-dim: #3a6bc9;
            --border: #2a2a4a;
            --success: #4ade80;
            --warning: #fbbf24;
            --info: #60a5fa;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', 'Noto Sans KR', -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.8;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .sidebar {
            width: 340px;
            min-width: 340px;
            height: 100vh;
            background: var(--bg-sidebar);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
        }

        .sidebar-header h1 {
            font-size: 1.1rem;
            color: var(--accent);
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .chapter-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 8px;
            transition: all 0.2s;
        }

        .chapter-toggle:hover {
            border-color: var(--accent);
        }

        .chapter-toggle h2 {
            font-size: 0.95rem;
            color: var(--text);
            font-weight: 600;
        }

        .chapter-toggle .arrow {
            color: var(--accent);
            transition: transform 0.2s;
            font-size: 0.8rem;
        }

        .chapter-toggle.collapsed .arrow {
            transform: rotate(-90deg);
        }

        .section-list {
            overflow: hidden;
            margin-bottom: 15px;
            padding-left: 10px;
        }

        .section-list.collapsed {
            display: none;
        }

        .section-item {
            display: block;
            padding: 10px 12px;
            margin: 4px 0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 3px solid transparent;
        }

        .section-item:hover {
            background: var(--bg-card);
            border-left-color: var(--accent-dim);
        }

        .section-item.active {
            background: var(--bg-card);
            border-left-color: var(--accent);
        }

        .section-item .section-title {
            font-size: 0.9rem;
            color: var(--text);
            font-weight: 500;
            margin-bottom: 4px;
        }

        .section-item .section-desc {
            font-size: 0.75rem;
            color: var(--text-dim);
            line-height: 1.4;
        }

        .section-item.active .section-title {
            color: var(--accent);
        }

        .main {
            flex: 1;
            height: 100vh;
            overflow-y: auto;
            padding: 40px 60px;
        }

        .content-area {
            max-width: 900px;
        }

        .content-header {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--accent);
        }

        .content-header h1 {
            font-size: 1.8rem;
            color: var(--accent);
            margin-bottom: 10px;
        }

        .content-header .breadcrumb {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        h2 {
            font-size: 1.3rem;
            color: var(--accent);
            margin: 30px 0 15px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }

        h3 {
            font-size: 1.1rem;
            color: var(--text);
            margin: 25px 0 12px 0;
        }

        h4 {
            font-size: 1rem;
            color: var(--text-muted);
            margin: 20px 0 10px 0;
        }

        p {
            margin-bottom: 15px;
            color: var(--text);
        }

        ul, ol {
            margin: 15px 0;
            padding-left: 25px;
        }

        li {
            margin-bottom: 8px;
            color: var(--text);
        }

        pre {
            background: var(--bg-code);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
        }

        pre code {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            background: transparent;
        }

        code:not(pre code) {
            background: var(--bg-code);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 0.9em;
            color: var(--accent);
        }

        .flow {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
            padding: 20px;
            margin: 20px 0;
            background: var(--bg-code);
            border: 1px solid var(--border);
            border-radius: 8px;
        }

        .flow-node {
            background: var(--bg-card);
            border: 1px solid var(--accent);
            padding: 10px 18px;
            border-radius: 6px;
            font-size: 0.9rem;
            color: var(--text);
        }

        .flow-arrow {
            color: var(--accent);
            font-size: 1.2rem;
        }

        .flow-vertical {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 20px;
            margin: 20px 0;
            background: var(--bg-code);
            border: 1px solid var(--border);
            border-radius: 8px;
        }

        .flow-vertical .flow-node {
            width: 100%;
            max-width: 400px;
            text-align: center;
        }

        .flow-vertical .flow-arrow {
            transform: rotate(90deg);
        }

        .callout {
            border-left: 4px solid var(--info);
            background: rgba(96, 165, 250, 0.1);
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .callout.tip {
            border-color: var(--success);
            background: rgba(74, 222, 128, 0.1);
        }

        .callout.warning {
            border-color: var(--warning);
            background: rgba(251, 191, 36, 0.1);
        }

        .callout.important {
            border-color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
        }

        .callout-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 0.9rem;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border: 1px solid var(--border);
        }

        th {
            background: var(--bg-code);
            font-weight: 600;
            color: var(--accent);
        }

        tr:hover {
            background: rgba(79, 140, 255, 0.05);
        }

        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 50px;
            padding-top: 30px;
            border-top: 1px solid var(--border);
        }

        .nav-btn {
            padding: 12px 20px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            cursor: pointer;
            transition: all 0.2s;
        }

        .nav-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .welcome {
            text-align: center;
            padding: 60px 20px;
        }

        .welcome h1 {
            color: var(--accent);
            margin-bottom: 20px;
        }

        .hierarchy-box {
            background: var(--bg-code);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Consolas', monospace;
            font-size: 0.9rem;
            line-height: 1.8;
            white-space: pre;
            overflow-x: auto;
        }

        @media (max-width: 900px) {
            .sidebar {
                width: 100%;
                height: auto;
                max-height: 40vh;
            }
            body {
                flex-direction: column;
            }
            .main {
                padding: 20px;
            }
        }
    </style>
    <!-- Highlight.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs2015.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
</head>
<body>
    <nav class="sidebar">
        <div class="sidebar-header">
            <h1>Unreal Engine</h1>
        </div>
        <div class="sidebar-content" id="nav-chapters">
            <!-- Framework: 언리얼 클래스 구조 및 초기화 (2.3~2.22) -->
            <div class="chapter-toggle collapsed" onclick="toggleChapter(this)">
                <h2>Framework</h2>
                <span class="arrow">▼</span>
            </div>
            <div class="section-list collapsed" id="framework-list">
                <div class="section-item" data-section="fw-sec1" onclick="showSection('framework', 'fw-sec1')">
                    <div class="section-title">언리얼 클래스 구조</div>
                    <div class="section-desc">UEngine, GameInstance, World, Actor 관계</div>
                </div>
                <div class="section-item" data-section="fw-sec2" onclick="showSection('framework', 'fw-sec2')">
                    <div class="section-title">엔진 생성</div>
                    <div class="section-desc">WinMain부터 GEngine 생성까지</div>
                </div>
                <div class="section-item" data-section="fw-sec3" onclick="showSection('framework', 'fw-sec3')">
                    <div class="section-title">월드 생성 및 초기화</div>
                    <div class="section-desc">FWorldContext, CreateWorld, InitWorld</div>
                </div>
                <div class="section-item" data-section="fw-sec4" onclick="showSection('framework', 'fw-sec4')">
                    <div class="section-title">월드의 핵심 구성요소</div>
                    <div class="section-desc">Game/Physics/Render World와 Thread</div>
                </div>
                <div class="section-item" data-section="fw-sec5" onclick="showSection('framework', 'fw-sec5')">
                    <div class="section-title">월드 액터 등록</div>
                    <div class="section-desc">Actor = UObject + Components</div>
                </div>
                <div class="section-item" data-section="fw-sec6" onclick="showSection('framework', 'fw-sec6')">
                    <div class="section-title">액터 계층 정렬</div>
                    <div class="section-desc">SortActorsHierarchy와 Depth 계산</div>
                </div>
                <div class="section-item" data-section="fw-sec7" onclick="showSection('framework', 'fw-sec7')">
                    <div class="section-title">컴포넌트 증분 등록</div>
                    <div class="section-desc">IncrementalRegisterComponents</div>
                </div>
                <div class="section-item" data-section="fw-sec8" onclick="showSection('framework', 'fw-sec8')">
                    <div class="section-title">컴포넌트 등록</div>
                    <div class="section-desc">부모 기반 등록과 계층 처리</div>
                </div>
                <div class="section-item" data-section="fw-sec9" onclick="showSection('framework', 'fw-sec9')">
                    <div class="section-title">컴포넌트 등록 과정</div>
                    <div class="section-desc">RegisterComponentWithWorld 상세</div>
                </div>
                <div class="section-item" data-section="fw-sec10" onclick="showSection('framework', 'fw-sec10')">
                    <div class="section-title">PIE 생성 및 초기화</div>
                    <div class="section-desc">EngineTick에서 PIE 시작까지</div>
                </div>
                <div class="section-item" data-section="fw-sec11" onclick="showSection('framework', 'fw-sec11')">
                    <div class="section-title">게임 초기화 과정</div>
                    <div class="section-desc">11단계 게임 초기화 순서</div>
                </div>
                <div class="section-item" data-section="fw-sec12" onclick="showSection('framework', 'fw-sec12')">
                    <div class="section-title">에디터 월드 복제</div>
                    <div class="section-desc">StaticDuplicateObjectEx와 PIE World</div>
                </div>
                <div class="section-item" data-section="fw-sec13" onclick="showSection('framework', 'fw-sec13')">
                    <div class="section-title">로컬플레이어 생성</div>
                    <div class="section-desc">GameInstance의 LocalPlayer 관리</div>
                </div>
                <div class="section-item" data-section="fw-sec14" onclick="showSection('framework', 'fw-sec14')">
                    <div class="section-title">월드의 게임 초기화</div>
                    <div class="section-desc">4단계 초기화와 BeginPlay</div>
                </div>
                <div class="section-item" data-section="fw-sec15" onclick="showSection('framework', 'fw-sec15')">
                    <div class="section-title">게임모드 생성</div>
                    <div class="section-desc">GameMode Class 로딩 우선순위</div>
                </div>
                <div class="section-item" data-section="fw-sec16" onclick="showSection('framework', 'fw-sec16')">
                    <div class="section-title">월드 액터 초기화</div>
                    <div class="section-desc">InitializeActorsForPlay와 SortActorList</div>
                </div>
                <div class="section-item" data-section="fw-sec17" onclick="showSection('framework', 'fw-sec17')">
                    <div class="section-title">월드 액터 초기화 과정</div>
                    <div class="section-desc">RouteActorInitialize 3단계</div>
                </div>
                <div class="section-item" data-section="fw-sec18" onclick="showSection('framework', 'fw-sec18')">
                    <div class="section-title">플레이어 구성 요소 생성</div>
                    <div class="section-desc">PlayerController, Pawn, PlayerInput</div>
                </div>
                <div class="section-item" data-section="fw-sec19" onclick="showSection('framework', 'fw-sec19')">
                    <div class="section-title">플레이어 컨트롤러 생성</div>
                    <div class="section-desc">Login과 PostInitializeComponents</div>
                </div>
                <div class="section-item" data-section="fw-sec20" onclick="showSection('framework', 'fw-sec20')">
                    <div class="section-title">플레이어 입력 시스템</div>
                    <div class="section-desc">PlayerInput vs InputComponent</div>
                </div>
                <div class="section-item" data-section="fw-sec21" onclick="showSection('framework', 'fw-sec21')">
                    <div class="section-title">플레이어 입력 생성</div>
                    <div class="section-desc">SetPlayer와 InputComponent 생성</div>
                </div>
                <div class="section-item" data-section="fw-sec22" onclick="showSection('framework', 'fw-sec22')">
                    <div class="section-title">플레이어 시작</div>
                    <div class="section-desc">PostLogin과 RestartPlayer</div>
                </div>
                <div class="section-item" data-section="fw-sec23" onclick="showSection('framework', 'fw-sec23')">
                    <div class="section-title">폰 생성 위치 결정</div>
                    <div class="section-desc">ChoosePlayerStart 4단계</div>
                </div>
                <div class="section-item" data-section="fw-sec24" onclick="showSection('framework', 'fw-sec24')">
                    <div class="section-title">폰 생성과 빙의</div>
                    <div class="section-desc">RestartPlayerAtPlayerStart</div>
                </div>
                <div class="section-item" data-section="fw-sec25" onclick="showSection('framework', 'fw-sec25')">
                    <div class="section-title">폰 생성</div>
                    <div class="section-desc">SpawnDefaultPawnFor</div>
                </div>
                <div class="section-item" data-section="fw-sec26" onclick="showSection('framework', 'fw-sec26')">
                    <div class="section-title">컨트롤러 폰 수정</div>
                    <div class="section-desc">SetPawn과 Attach</div>
                </div>
                <div class="section-item" data-section="fw-sec27" onclick="showSection('framework', 'fw-sec27')">
                    <div class="section-title">빙의 (Possess)</div>
                    <div class="section-desc">양방향 연결 4단계</div>
                </div>
                <div class="section-item" data-section="fw-sec28" onclick="showSection('framework', 'fw-sec28')">
                    <div class="section-title">카메라 타겟과 입력 설정</div>
                    <div class="section-desc">ClientRestart 후속 처리</div>
                </div>
                <div class="section-item" data-section="fw-sec29" onclick="showSection('framework', 'fw-sec29')">
                    <div class="section-title">빙의 완료 후 세부 설정</div>
                    <div class="section-desc">FinishRestartPlayer</div>
                </div>
                <div class="section-item" data-section="fw-sec30" onclick="showSection('framework', 'fw-sec30')">
                    <div class="section-title">월드 시작</div>
                    <div class="section-desc">BeginPlay 호출 체인</div>
                </div>
            </div>

            <!-- Tick: Tick 시스템 (3.43~3.54) -->
            <div class="chapter-toggle collapsed" onclick="toggleChapter(this)">
                <h2>Tick</h2>
                <span class="arrow">▼</span>
            </div>
            <div class="section-list collapsed" id="tick-list">
                <div class="section-item" data-section="tick-sec1" onclick="showSection('tick', 'tick-sec1')">
                    <div class="section-title">언리얼 Tick 방식 개념</div>
                    <div class="section-desc">TickFunction 기반 Tick 시스템의 특징과 장점</div>
                </div>
                <div class="section-item" data-section="tick-sec2" onclick="showSection('tick', 'tick-sec2')">
                    <div class="section-title">TickFunction 구조</div>
                    <div class="section-desc">Actor와 Component의 Tick 시스템 비교</div>
                </div>
                <div class="section-item" data-section="tick-sec3" onclick="showSection('tick', 'tick-sec3')">
                    <div class="section-title">TickFunction - Flag</div>
                    <div class="section-desc">bCanEverTick과 bStartWithTickEnabled</div>
                </div>
                <div class="section-item" data-section="tick-sec4" onclick="showSection('tick', 'tick-sec4')">
                    <div class="section-title">TickFunction - State</div>
                    <div class="section-desc">Enabled, Disabled, CoolingDown 상태 관리</div>
                </div>
                <div class="section-item" data-section="tick-sec5" onclick="showSection('tick', 'tick-sec5')">
                    <div class="section-title">TickFunction - Group</div>
                    <div class="section-desc">8개 Tick Group과 2차원 배열 관리</div>
                </div>
                <div class="section-item" data-section="tick-sec6" onclick="showSection('tick', 'tick-sec6')">
                    <div class="section-title">TickFunction - Prerequisite</div>
                    <div class="section-desc">선행조건으로 Tick 실행 순서 보장</div>
                </div>
                <div class="section-item" data-section="tick-sec7" onclick="showSection('tick', 'tick-sec7')">
                    <div class="section-title">TickFunction - InternalData</div>
                    <div class="section-desc">등록 후 실제 실행 데이터 관리</div>
                </div>
                <div class="section-item" data-section="tick-sec8" onclick="showSection('tick', 'tick-sec8')">
                    <div class="section-title">Tick 관리자 3대장</div>
                    <div class="section-desc">Manager, Level, Sequencer의 역할 분담</div>
                </div>
                <div class="section-item" data-section="tick-sec9" onclick="showSection('tick', 'tick-sec9')">
                    <div class="section-title">Tick 등록 과정</div>
                    <div class="section-desc">BeginPlay에서의 Tick 등록 4단계</div>
                </div>
                <div class="section-item" data-section="tick-sec10" onclick="showSection('tick', 'tick-sec10')">
                    <div class="section-title">Tick 처리 전체 과정</div>
                    <div class="section-desc">World로부터 시작하는 6단계 처리</div>
                </div>
                <div class="section-item" data-section="tick-sec11" onclick="showSection('tick', 'tick-sec11')">
                    <div class="section-title">월드 Tick</div>
                    <div class="section-desc">UWorld::Tick 함수의 상세 분석</div>
                </div>
                <div class="section-item" data-section="tick-sec12" onclick="showSection('tick', 'tick-sec12')">
                    <div class="section-title">물리 Tick 설정</div>
                    <div class="section-desc">StartPhysics/EndPhysics TickFunction 등록</div>
                </div>
                <div class="section-item" data-section="tick-sec13" onclick="showSection('tick', 'tick-sec13')">
                    <div class="section-title">TickTasks 초기화</div>
                    <div class="section-desc">Start 시점의 2차원 배열 초기화</div>
                </div>
                <div class="section-item" data-section="tick-sec14" onclick="showSection('tick', 'tick-sec14')">
                    <div class="section-title">쿨타임 스케줄링 (개념)</div>
                    <div class="section-desc">상대 시간과 Two Cursor 방식</div>
                </div>
                <div class="section-item" data-section="tick-sec15" onclick="showSection('tick', 'tick-sec15')">
                    <div class="section-title">쿨타임 스케줄링 (코드)</div>
                    <div class="section-desc">ScheduleTickFunctionCooldowns 구현</div>
                </div>
                <div class="section-item" data-section="tick-sec16" onclick="showSection('tick', 'tick-sec16')">
                    <div class="section-title">쿨타임 활성화</div>
                    <div class="section-desc">CoolingDown에서 Enabled로 전환</div>
                </div>
                <div class="section-item" data-section="tick-sec17" onclick="showSection('tick', 'tick-sec17')">
                    <div class="section-title">TickTask와 TickGroup 배정</div>
                    <div class="section-desc">QueueTickFunction의 네 가지 역할</div>
                </div>
                <div class="section-item" data-section="tick-sec18" onclick="showSection('tick', 'tick-sec18')">
                    <div class="section-title">TickTask의 틱 실행</div>
                    <div class="section-desc">ReleaseTickGroup과 DoTask 실행</div>
                </div>
                <div class="section-item" data-section="tick-sec19" onclick="showSection('tick', 'tick-sec19')">
                    <div class="section-title">Tick 마무리</div>
                    <div class="section-desc">EndFrame과 재스케줄링</div>
                </div>
                <div class="section-item" data-section="tick-sec20" onclick="showSection('tick', 'tick-sec20')">
                    <div class="section-title">Tick 제거</div>
                    <div class="section-desc">UnRegisterTickFunction과 상태별 처리</div>
                </div>
            </div>

            <!-- Component 챕터 -->
            <div class="chapter-toggle collapsed" onclick="toggleChapter(this)">
                <h2>Component</h2>
                <span class="arrow">▼</span>
            </div>
            <div class="section-list collapsed" id="component-list">
                <div class="section-item" data-section="comp-sec1" onclick="showSection('component', 'comp-sec1')">
                    <div class="section-title">ActorComponent 개념</div>
                    <div class="section-desc">Component 기반 모듈화 아키텍처</div>
                </div>
                <div class="section-item" data-section="comp-sec2" onclick="showSection('component', 'comp-sec2')">
                    <div class="section-title">SceneComponent 개념</div>
                    <div class="section-desc">Transform과 계층 구조</div>
                </div>
                <div class="section-item" data-section="comp-sec3" onclick="showSection('component', 'comp-sec3')">
                    <div class="section-title">컴포넌트 연결 초기 설정</div>
                    <div class="section-desc">SetupAttachment 5가지 검사</div>
                </div>
                <div class="section-item" data-section="comp-sec4" onclick="showSection('component', 'comp-sec4')">
                    <div class="section-title">컴포넌트 연결</div>
                    <div class="section-desc">AttachToComponent 7가지 검증</div>
                </div>
                <div class="section-item" data-section="comp-sec5" onclick="showSection('component', 'comp-sec5')">
                    <div class="section-title">컴포넌트 분리</div>
                    <div class="section-desc">DetachFromComponent 동작 원리</div>
                </div>
                <div class="section-item" data-section="comp-sec6" onclick="showSection('component', 'comp-sec6')">
                    <div class="section-title">SetPawn</div>
                    <div class="section-desc">Controller와 Pawn의 연결</div>
                </div>
                <div class="section-item" data-section="comp-sec7" onclick="showSection('component', 'comp-sec7')">
                    <div class="section-title">월드 트랜스폼 업데이트</div>
                    <div class="section-desc">UpdateComponentToWorld 계층적 갱신</div>
                </div>
                <div class="section-item" data-section="comp-sec8" onclick="showSection('component', 'comp-sec8')">
                    <div class="section-title">위치 및 회전 설정</div>
                    <div class="section-desc">MoveComponent 동작 원리</div>
                </div>
                <div class="section-item" data-section="comp-sec9" onclick="showSection('component', 'comp-sec9')">
                    <div class="section-title">PrimitiveComponent 개념</div>
                    <div class="section-desc">렌더링과 충돌의 통합</div>
                </div>
                <div class="section-item" data-section="comp-sec10" onclick="showSection('component', 'comp-sec10')">
                    <div class="section-title">충돌 체크 개념</div>
                    <div class="section-desc">Overlap 7단계 프로세스</div>
                </div>
                <div class="section-item" data-section="comp-sec11" onclick="showSection('component', 'comp-sec11')">
                    <div class="section-title">충돌 체크 구현</div>
                    <div class="section-desc">UpdateOverlapsImpl 코드 분석</div>
                </div>
                <div class="section-item" data-section="comp-sec12" onclick="showSection('component', 'comp-sec12')">
                    <div class="section-title">BeginOverlap, EndOverlap</div>
                    <div class="section-desc">Overlap 이벤트 호출 규칙</div>
                </div>
                <div class="section-item" data-section="comp-sec13" onclick="showSection('component', 'comp-sec13')">
                    <div class="section-title">Weld 개념</div>
                    <div class="section-desc">물리 시뮬레이션 통합</div>
                </div>
                <div class="section-item" data-section="comp-sec14" onclick="showSection('component', 'comp-sec14')">
                    <div class="section-title">SkeletalMesh 개념</div>
                    <div class="section-desc">Skeleton + Mesh + Animation 구조</div>
                </div>
                <div class="section-item" data-section="comp-sec15" onclick="showSection('component', 'comp-sec15')">
                    <div class="section-title">소켓 트랜스폼</div>
                    <div class="section-desc">Socket Transform 계산 과정</div>
                </div>
            </div>

            <!-- Object Constructor 챕터 -->
            <div class="chapter-toggle collapsed" onclick="toggleChapter(this)">
                <h2>Object Constructor</h2>
                <span class="arrow">▼</span>
            </div>
            <div class="section-list collapsed" id="object-list">
                <div class="section-item" data-section="obj-sec1" onclick="showSection('object', 'obj-sec1')">
                    <div class="section-title">CDO 개념</div>
                    <div class="section-desc">Class Default Object 이해</div>
                </div>
                <div class="section-item" data-section="obj-sec2" onclick="showSection('object', 'obj-sec2')">
                    <div class="section-title">오브젝트 생성 (NewObject)</div>
                    <div class="section-desc">런타임 UObject 생성 방법</div>
                </div>
                <div class="section-item" data-section="obj-sec3" onclick="showSection('object', 'obj-sec3')">
                    <div class="section-title">서브오브젝트 생성</div>
                    <div class="section-desc">CreateDefaultSubobject 원리</div>
                </div>
                <div class="section-item" data-section="obj-sec4" onclick="showSection('object', 'obj-sec4')">
                    <div class="section-title">AddComponentByClass</div>
                    <div class="section-desc">블루프린트 컴포넌트 추가</div>
                </div>
                <div class="section-item" data-section="obj-sec5" onclick="showSection('object', 'obj-sec5')">
                    <div class="section-title">UObject 생성 종합 정리</div>
                    <div class="section-desc">전체 생성 시스템 요약</div>
                </div>
            </div>

            <!-- Spawn Actor 챕터 -->
            <div class="chapter-toggle collapsed" onclick="toggleChapter(this)">
                <h2>Spawn Actor</h2>
                <span class="arrow">▼</span>
            </div>
            <div class="section-list collapsed" id="spawn-list">
                <div class="section-item" data-section="spawn-sec1" onclick="showSection('spawn', 'spawn-sec1')">
                    <div class="section-title">액터 생성 사전 처리</div>
                    <div class="section-desc">SpawnActor 내부 동작 분석</div>
                </div>
                <div class="section-item" data-section="spawn-sec2" onclick="showSection('spawn', 'spawn-sec2')">
                    <div class="section-title">액터 생성 마무리</div>
                    <div class="section-desc">FinishSpawning과 PostActorConstruction</div>
                </div>
                <div class="section-item" data-section="spawn-sec3" onclick="showSection('spawn', 'spawn-sec3')">
                    <div class="section-title">액터 초기화 순서</div>
                    <div class="section-desc">6단계 초기화 과정</div>
                </div>
                <div class="section-item" data-section="spawn-sec4" onclick="showSection('spawn', 'spawn-sec4')">
                    <div class="section-title">C++ vs Blueprint 생성 순서</div>
                    <div class="section-desc">컴포넌트 생성 시점 차이</div>
                </div>
                <div class="section-item" data-section="spawn-sec5" onclick="showSection('spawn', 'spawn-sec5')">
                    <div class="section-title">액터 생성 종합 정리</div>
                    <div class="section-desc">전체 생성 및 초기화 요약</div>
                </div>
            </div>

            <!-- Blueprint 챕터 -->
            <div class="chapter-toggle collapsed" onclick="toggleChapter(this)">
                <h2>Blueprint</h2>
                <span class="arrow">▼</span>
            </div>
            <div class="section-list collapsed" id="blueprint-list">
                <div class="section-item" data-section="bp-sec1" onclick="showSection('blueprint', 'bp-sec1')">
                    <div class="section-title">블루프린트 개념</div>
                    <div class="section-desc">UBlueprint와 GeneratedClass</div>
                </div>
                <div class="section-item" data-section="bp-sec2" onclick="showSection('blueprint', 'bp-sec2')">
                    <div class="section-title">SimpleConstructionScript</div>
                    <div class="section-desc">SCS 컴포넌트 계층 관리</div>
                </div>
                <div class="section-item" data-section="bp-sec3" onclick="showSection('blueprint', 'bp-sec3')">
                    <div class="section-title">컴포넌트 오버라이딩</div>
                    <div class="section-desc">InheritableComponentHandler</div>
                </div>
                <div class="section-item" data-section="bp-sec4" onclick="showSection('blueprint', 'bp-sec4')">
                    <div class="section-title">ExecuteConstruction</div>
                    <div class="section-desc">8단계 컴포넌트 생성 및 등록</div>
                </div>
                <div class="section-item" data-section="bp-sec5" onclick="showSection('blueprint', 'bp-sec5')">
                    <div class="section-title">SCS 컴포넌트 생성 준비</div>
                    <div class="section-desc">ExecuteScriptOnActor</div>
                </div>
                <div class="section-item" data-section="bp-sec6" onclick="showSection('blueprint', 'bp-sec6')">
                    <div class="section-title">SCS 컴포넌트 생성 및 등록</div>
                    <div class="section-desc">ExecuteNodeOnActor</div>
                </div>
                <div class="section-item" data-section="bp-sec7" onclick="showSection('blueprint', 'bp-sec7')">
                    <div class="section-title">SpawnActor 정리</div>
                    <div class="section-desc">6단계 전체 흐름</div>
                </div>
                <div class="section-item" data-section="bp-sec8" onclick="showSection('blueprint', 'bp-sec8')">
                    <div class="section-title">블루프린트와 SpawnActor 종합</div>
                    <div class="section-desc">완전 정복 가이드</div>
                </div>
            </div>

            <!-- Render 챕터 -->
            <div class="chapter-toggle collapsed" onclick="toggleChapter(this)">
                <h2>Render</h2>
                <span class="arrow">▼</span>
            </div>
            <div class="section-list collapsed" id="render-list">
                <div class="section-item" data-section="render-sec1" onclick="showSection('render', 'render-sec1')">
                    <div class="section-title">카메라 업데이트</div>
                    <div class="section-desc">World Tick에서 카메라 POV 계산</div>
                </div>
                <div class="section-item" data-section="render-sec2" onclick="showSection('render', 'render-sec2')">
                    <div class="section-title">화면 렌더링</div>
                    <div class="section-desc">Viewport Draw와 SceneView</div>
                </div>
                <div class="section-item" data-section="render-sec3" onclick="showSection('render', 'render-sec3')">
                    <div class="section-title">렌더링 정보 계산</div>
                    <div class="section-desc">CalcSceneView와 투영 데이터</div>
                </div>
            </div>

            <!-- Garbage Collector 챕터 -->
            <div class="chapter-toggle collapsed" onclick="toggleChapter(this)">
                <h2>Garbage Collector</h2>
                <span class="arrow">▼</span>
            </div>
            <div class="section-list collapsed" id="gc-list">
                <div class="section-item" data-section="gc-sec1" onclick="showSection('gc', 'gc-sec1')">
                    <div class="section-title">GC 개념 및 과정</div>
                    <div class="section-desc">Mark and Sweep, 3단계 과정</div>
                </div>
                <div class="section-item" data-section="gc-sec2" onclick="showSection('gc', 'gc-sec2')">
                    <div class="section-title">GC 준비</div>
                    <div class="section-desc">ConditionalCollectGarbage와 비동기 로딩</div>
                </div>
                <div class="section-item" data-section="gc-sec3" onclick="showSection('gc', 'gc-sec3')">
                    <div class="section-title">초기 도달 가능성 처리</div>
                    <div class="section-desc">FGCObject, Root Object, Swap 최적화</div>
                </div>
                <div class="section-item" data-section="gc-sec4" onclick="showSection('gc', 'gc-sec4')">
                    <div class="section-title">도달 가능성 분석</div>
                    <div class="section-desc">Schema 시스템과 참조 추적</div>
                </div>
                <div class="section-item" data-section="gc-sec5" onclick="showSection('gc', 'gc-sec5')">
                    <div class="section-title">메모리 반환</div>
                    <div class="section-desc">Sweep, BeginDestroy, FinishDestroy</div>
                </div>
                <div class="section-item" data-section="gc-sec6" onclick="showSection('gc', 'gc-sec6')">
                    <div class="section-title">AddToRoot와 Destroy Actor</div>
                    <div class="section-desc">Root Object 등록과 Actor 제거</div>
                </div>
            </div>

            <!-- Pointer 챕터 -->
            <div class="chapter-toggle collapsed" onclick="toggleChapter(this)">
                <h2>Pointer</h2>
                <span class="arrow">▼</span>
            </div>
            <div class="section-list collapsed" id="ptr-list">
                <div class="section-item" data-section="ptr-sec1" onclick="showSection('ptr', 'ptr-sec1')">
                    <div class="section-title">TObjectPtr</div>
                    <div class="section-desc">강한 참조, 점진적 GC, 쓰기 장벽</div>
                </div>
                <div class="section-item" data-section="ptr-sec2" onclick="showSection('ptr', 'ptr-sec2')">
                    <div class="section-title">TWeakObjectPtr</div>
                    <div class="section-desc">약한 참조, Index/SerialNumber, 순환 참조 방지</div>
                </div>
            </div>
        </div>
    </nav>
    <main class="main">
        <div class="content-area" id="content">
            <div class="welcome">
                <h1>Unreal Engine Tick System</h1>
                <p>좌측 메뉴에서 섹션을 선택하세요.</p>
            </div>
        </div>
    </main>
    <script>
        const sectionData = {};

        // ========================================
        // Framework: 언리얼 클래스 구조 및 초기화 (2.3~2.22)
        // ========================================

        sectionData['fw-sec1'] = {
            title: '언리얼 클래스 구조',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>언리얼 클래스 구조</h1>
                </div>
                <h2>Overview</h2>
                <p>언리얼 엔진의 핵심 클래스 구조를 이해합니다. Framework의 핵심은 <strong>클래스 생성</strong>과 <strong>Tick(로직의 실행)</strong> 두 가지입니다.</p>

                <h2>주요 클래스 구조</h2>
                <h3>UEngine: 운영체제의 역할</h3>
                <p>마치 <strong>운영체제</strong>처럼 전체 엔진을 관리하는 최상위 클래스입니다.</p>

                <h3>GameInstance: Process (실행 단위)</h3>
                <p>프로세스(실행 단위)에 해당합니다. 메모장, 그림판 아이콘처럼 하나의 게임 실행을 담당합니다.</p>
                <div class="callout">
                    <div class="callout-title">운영체제와 프로세스를 분리하면 좋은 점</div>
                    <ul>
                        <li><strong>생명 주기 독립성</strong>: Game을 종료한다고 해서 운영체제(Engine)가 종료되지 않음</li>
                        <li><strong>변수 범위 관리</strong>: 게임 생명 주기와 동일한 변수는 Instance 단위로 관리</li>
                    </ul>
                </div>

                <h3>UWorld (지구)</h3>
                <p>여러 개의 레벨을 가질 수 있는 게임 월드입니다.</p>

                <h3>ULevel (각 국가)</h3>
                <p>World 내부의 구역 단위입니다.</p>

                <h3>Actor (World에 배치할 수 있는 최소 단위)</h3>
                <pre><code class="language-cpp">// Actor = UObject + Components
UObject + Component(Render, Transform) = Actor</code></pre>

                <h2>주요 게임플레이 클래스</h2>
                <h3>AGameMode (World의 관리자)</h3>
                <table>
                    <tr><th>역할</th><th>설명</th></tr>
                    <tr><td>규칙 관리</td><td>Game World의 규칙을 정의</td></tr>
                    <tr><td>상태 동기화</td><td>GameState를 통해 서버의 GameMode 정보를 각 클라이언트가 볼 수 있도록 함</td></tr>
                    <tr><td>서버 전용</td><td>오직 서버에만 존재</td></tr>
                </table>

                <h3>APlayerController (World의 Player를 대변)</h3>
                <div class="flow">
                    <div class="flow-node">PlayerController</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Possess</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Pawn</div>
                </div>
                <table>
                    <tr><th>기능</th><th>설명</th></tr>
                    <tr><td>빙의</td><td>Possess를 통해 APawn을 소유하여 조정</td></tr>
                    <tr><td>상태 공유</td><td>PlayerState를 통해 각 클라이언트에서 다른 플레이어의 정보를 볼 수 있도록 함</td></tr>
                    <tr><td>입력 처리</td><td>PlayerInput으로 입력 정보를 APawn의 InputComponent에 전달</td></tr>
                    <tr><td>카메라 관리</td><td>APawn의 CameraComponent 렌더링 정보를 Camera Manager에 전달</td></tr>
                </table>

                <h3>LocalPlayer (실제로 플레이하고 있는 진짜 나)</h3>
                <div class="callout important">
                    <div class="callout-title">LocalPlayer의 특징</div>
                    <ul>
                        <li><strong>생명주기 독립성</strong>: World가 사라지면 World 상의 PlayerController는 사라지지만 LocalPlayer는 사라지지 않음</li>
                        <li><strong>Engine 레벨</strong>: Engine 수준에서의 나를 대표</li>
                    </ul>
                </div>

                <h3>ViewportClient (보이는 화면을 담당하는 클래스)</h3>
                <table>
                    <tr><th>역할</th><th>설명</th></tr>
                    <tr><td>플랫폼 대응</td><td>Cross Platform을 지원하려면 각 플랫폼의 함수 차이를 처리</td></tr>
                    <tr><td>입력 수신</td><td>운영체제로부터 Input을 전달받는 역할</td></tr>
                    <tr><td>브릿지</td><td>엔진과 게임 인스턴스 사이의 중간 다리 역할</td></tr>
                </table>

                <h2>핵심 정리</h2>
                <table>
                    <tr><th>클래스</th><th>역할</th></tr>
                    <tr><td>UEngine</td><td>운영체제 역할</td></tr>
                    <tr><td>GameInstance</td><td>프로세스 역할 (게임 생명주기와 동일)</td></tr>
                    <tr><td>UWorld</td><td>게임 월드 (여러 레벨 포함)</td></tr>
                    <tr><td>Actor</td><td>World에 배치 가능한 최소 단위</td></tr>
                    <tr><td>GameMode</td><td>World의 규칙 관리자 (서버 전용)</td></tr>
                    <tr><td>PlayerController</td><td>World 속의 나</td></tr>
                    <tr><td>LocalPlayer</td><td>Engine 속의 나</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" disabled>← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec2'] = {
            title: '엔진 생성',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>엔진 생성</h1>
                </div>
                <h2>Overview</h2>
                <p>언리얼 엔진의 시작점과 무한 루프 위치를 파악합니다.</p>
                <ul>
                    <li><strong>Where is Starting Point</strong> - 시작점이 어디인가</li>
                    <li><strong>Where is Loop</strong> - 무한 루프가 어디인가</li>
                </ul>

                <h2>Starting Point</h2>
                <div class="callout tip">
                    <div class="callout-title">별거아니네 모먼트</div>
                    <p>결국 시작점은 <strong>WinMain</strong>입니다! 거대한 프로그램이지만 시작점은 동일합니다.</p>
                </div>

                <h3>WinMain</h3>
                <p>StartUp과 Shutdown 처리를 담당합니다.</p>

                <h3>LaunchWindowsStartup</h3>
                <p>두 가지 처리를 담당합니다:</p>
                <h4>1. Command 처리 - 언리얼 처리 방식으로 변경</h4>
                <div class="callout">
                    <div class="callout-title">언리얼 처리 방식으로 변경하는 이유</div>
                    <p>언리얼은 여러 플랫폼을 지원하는데, 각 플랫폼마다 cmd를 처리하는 방식이 다릅니다. 각자의 플랫폼마다 처리하는 방식을 예외처리하는 방식보다는 <strong>언리얼에서 사용하는 방식으로 통일</strong>하여 처리하는 것이 나은 방향입니다.</p>
                </div>

                <h4>2. Main 함수 진입 - SEH</h4>
                <div class="callout warning">
                    <div class="callout-title">SEH (Structured Exception Handling)</div>
                    <p>간단히 말해서 <strong>언리얼 Crash Report 처리하는 방식</strong>입니다.</p>
                </div>

                <h3>GuardedMainWrapper</h3>
                <p>Wrapper를 사용하는 이유는 <strong>SEH를 사용하여 Crash Report 같은 상황을 catch하기 위함</strong>입니다 (try-catch와 유사).</p>

                <h2>Loop Point</h2>
                <h3>GuardedMain</h3>
                <div class="callout tip">
                    <div class="callout-title">별거아니네 모먼트 #2</div>
                    <p>결국에 <strong>무한 루프를 도는 Tick이 존재</strong>합니다.</p>
                </div>

                <h2>초기화 단계</h2>
                <h3>1. EnginePreInit</h3>
                <pre><code class="language-cpp">// GEngineLoop의 PreInit 단계 처리
// GEngineLoop에 필요한 초기 설정과 cmd처리</code></pre>
                <table>
                    <tr><th>단계</th><th>설명</th></tr>
                    <tr><td>설정 초기화</td><td>GEngineLoop에 필요한 초기 설정</td></tr>
                    <tr><td>CMD 처리</td><td>커맨드 라인 인자 처리</td></tr>
                </table>

                <h3>2. EditorInit</h3>
                <pre><code class="language-cpp">// GEngineLoop의 Init 단계 처리
// GEngine을 생성</code></pre>
                <div class="callout tip">
                    <div class="callout-title">핵심</div>
                    <p><strong>GEngine을 생성</strong>하는 단계! 컴퓨터 실행 시 하드웨어 초기화 이후 윈도우가 실행되는 시점과 동일하다고 볼 수 있습니다.</p>
                </div>

                <h2>핵심 플로우</h2>
                <div class="flow-vertical">
                    <div class="flow-node">WinMain</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">LaunchWindowsStartup</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">GuardedMainWrapper</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">GuardedMain</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">EnginePreInit / EditorInit</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">GEngine 생성</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">EngineTick 무한 루프</div>
                </div>

                <h2>요약</h2>
                <ol>
                    <li><strong>WinMain</strong>에서 시작</li>
                    <li><strong>LaunchWindowsStartup</strong>에서 CMD 처리 및 SEH 설정</li>
                    <li><strong>GuardedMain</strong>에서 무한 루프 시작</li>
                    <li><strong>EnginePreInit</strong>에서 초기 설정</li>
                    <li><strong>EditorInit</strong>에서 <strong>GEngine 생성</strong></li>
                    <li><strong>EngineTick</strong>으로 무한 루프 실행</li>
                </ol>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec3'] = {
            title: '월드 생성 및 초기화',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>월드 생성 및 초기화</h1>
                </div>
                <h2>Overview</h2>
                <p>EditorInit에서 GEngine을 생성한 이후, UEngine Init에서 World를 생성하고 초기화하는 과정을 설명합니다.</p>

                <h2>UEngine Init</h2>
                <h3>주요 초기화 작업</h3>
                <pre><code class="language-cpp">// UEngine의 Loop에 FEngineLoop를 등록
// EngineSubsystem 생성
// AddToRoot -> GC에 의해 지워지지 않도록 설정</code></pre>

                <h3>에디터 환경에서 주목할 부분</h3>
                <table>
                    <tr><th>순서</th><th>작업</th><th>설명</th></tr>
                    <tr><td>1</td><td>FWorldContext 생성</td><td>Editor Type으로 설정하여 생성</td></tr>
                    <tr><td>2</td><td>UWorld 생성</td><td>World를 생성하여 등록</td></tr>
                </table>

                <div class="callout">
                    <div class="callout-title">왜 곧바로 UWorld를 등록하지 않고 FWorldContext를 Wrapping했을까?</div>
                    <p>Engine을 구성하는 World의 종류가 많아지게 되었고, 각 Type마다 로직을 분리하기 위해서는 UWorld가 <strong>어떤 Type인지 한 번 더 Wrapping한 구조체가 필요</strong>하게 되었습니다.</p>
                </div>

                <h2>CreateNewWorldContext</h2>
                <p>UEngine의 WorldList에 FWorldContext를 생성하여 추가합니다.</p>

                <h3>EWorldType - World의 다양한 타입</h3>
                <pre><code class="language-cpp">enum class EWorldType
{
    None,
    Game,           // 게임 월드
    Editor,         // 에디터 창에서 보이는 화면
    PIE,            // 플레이 게임 화면
    EditorPreview,  // 액터 BP나 staticmesh 열었을 때 보이는 창
    GamePreview,
    Inactive
};</code></pre>

                <div class="callout">
                    <div class="callout-title">FWorldContext란?</div>
                    <p>언리얼 엔진 레벨에서 UWorld 객체들을 다루기 위한 맥락. 엔진이 여러 월드를 생성하고 파괴하는 과정에서, 어떤 월드가 <strong>어떤 목적</strong>(예: 게임 플레이, 에디터, PIE)에 속하는지를 명확하게 추적하고 관리하는 방법을 제공합니다.</p>
                </div>

                <h2>CreateWorld</h2>
                <h3>1. UPackage 생성</h3>
                <pre><code class="language-cpp">// UPackage는 ContentBrowser에서 Level 형태로 보이는 파일
// 언리얼이 데이터를 조금 더 체계적으로 관리하기 위해 UPackage 클래스를 생성</code></pre>

                <h3>2. SetFeatureLevel</h3>
                <p>렌더링 관련 설정을 처리합니다.</p>

                <h3>3. InitializeNewWorld</h3>
                <table>
                    <tr><th>순서</th><th>구성 요소</th><th>설명</th></tr>
                    <tr><td>1</td><td>PersistentLevel 생성</td><td>World와 1대1 관계를 가지는 필수 Level</td></tr>
                    <tr><td>2</td><td>WorldSetting 생성</td><td>GameMode, GameState, Pawn, PlayerState 등을 포함</td></tr>
                    <tr><td>3</td><td>InitWorld 진행</td><td>물리, 네비게이션 등의 필수적 요소 생성 및 초기화</td></tr>
                    <tr><td>4</td><td>UpdateWorldComponents</td><td>Level에 배치된 액터와 컴포넌트를 등록</td></tr>
                </table>

                <h2>핵심 플로우</h2>
                <div class="flow-vertical">
                    <div class="flow-node">UEngine::Init</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">FWorldContext 생성</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">CreateWorld</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">UPackage / SetFeatureLevel</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">InitializeNewWorld</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">PersistentLevel / WorldSetting / InitWorld</div>
                </div>

                <h2>핵심 정리</h2>
                <ol>
                    <li><strong>FWorldContext</strong>: World의 타입과 목적을 관리하는 Wrapper</li>
                    <li><strong>PersistentLevel</strong>: World와 1대1 관계를 가지는 필수 Level</li>
                    <li><strong>WorldSetting</strong>: 게임 설정값을 담고 있는 Actor</li>
                    <li><strong>InitWorld</strong>: Physics, Navigation 등 필수 요소 초기화</li>
                    <li><strong>UpdateWorldComponents</strong>: Actor와 Component 등록 (렌더링 가능 상태)</li>
                </ol>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec4'] = {
            title: '월드의 핵심 구성요소',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>월드의 핵심 구성요소</h1>
                </div>
                <h2>Overview</h2>
                <p>언리얼 엔진으로 게임을 만드는 과정은 <strong>한 편의 블록버스터 영화를 만드는 과정</strong>과 비슷합니다.</p>

                <h2>영화 제작 비유로 이해하는 언리얼 World 구조</h2>
                <h3>영화 제작 과정</h3>
                <table>
                    <tr><th>단계</th><th>설명</th></tr>
                    <tr><td>시나리오</td><td>스토리 구성</td></tr>
                    <tr><td>배우 연기 지도</td><td>연기 디렉션</td></tr>
                    <tr><td>특수효과</td><td>시각 효과</td></tr>
                    <tr><td>조명 및 카메라</td><td>촬영 설비</td></tr>
                    <tr><td>편집</td><td>후반 작업</td></tr>
                </table>

                <h3>한 곳에서 모든 작업을 진행한다면?</h3>
                <p>작업 효율이 떨어집니다. 실제 영화 촬영장에서는 역할과 목적에 따라 <strong>각각의 세트장</strong>을 만듭니다.</p>

                <h2>언리얼의 World 분리 구조</h2>
                <p>이와 같이 언리얼에서도 <strong>작업 성격에 따라 내부적으로 World를 분리</strong>하여 구성합니다.</p>

                <h3>1. Game World (Main Control Tower)</h3>
                <pre><code class="language-cpp">// 게임에 핵심적인 로직(행동 규칙)을 담당
// 평소에 GetWorld()로 받아오는 World가 바로 이것</code></pre>
                <table>
                    <tr><th>특징</th><th>설명</th></tr>
                    <tr><td>주요 역할</td><td>메인 컨트롤 타워</td></tr>
                    <tr><td>담당 업무</td><td>게임 로직, 행동 규칙</td></tr>
                    <tr><td>접근 방법</td><td>GetWorld()</td></tr>
                </table>

                <h3>2. Physics World</h3>
                <pre><code class="language-cpp">// 물리 처리 담당
// 물리적 상호작용, 충돌 등
// 가장 연산량이 많은 곳</code></pre>

                <h3>3. Render World</h3>
                <pre><code class="language-cpp">// 렌더링 담당
// 플레이어 화면에 어떻게 보일지 계산</code></pre>

                <h2>Thread = 영화 제작의 Staff</h2>
                <div class="callout">
                    <div class="callout-title">Thread = 영화의 Staff</div>
                    <p>언리얼에서는 이 Staff가 <strong>Thread</strong>에 해당합니다.</p>
                    <ul>
                        <li>Thread가 <strong>게임 월드</strong>에 가면 → <strong>감독</strong>이 되는 것</li>
                        <li>Thread가 <strong>Physics 월드</strong>에 가면 → <strong>특수 효과 스태프</strong>가 되는 것</li>
                        <li>Thread가 <strong>Render 월드</strong>에 가면 → <strong>촬영 스태프</strong>가 되는 것</li>
                    </ul>
                </div>

                <h3>Single Thread의 문제점</h3>
                <p>Thread가 하나라면? 3개의 월드를 번갈아 방문하며 처리 속도가 느려집니다.</p>

                <h3>Multi-Thread의 해결책</h3>
                <div class="callout tip">
                    <div class="callout-title">멀티 스레드의 장점</div>
                    <p>각각 월드에 스레드를 하나씩 배치하여 <strong>각 전문 스태프가 병렬적으로 일을 처리</strong>합니다.</p>
                </div>
                <div class="flow">
                    <div class="flow-node">Game Thread</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Game World</div>
                </div>
                <div class="flow">
                    <div class="flow-node">Physics Thread</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Physics World</div>
                </div>
                <div class="flow">
                    <div class="flow-node">Render Thread</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Render World</div>
                </div>

                <h2>InitWorld 핵심 코드</h2>
                <div class="callout important">
                    <div class="callout-title">핵심</div>
                    <p><strong>Render World, Physics World를 생성</strong></p>
                </div>
                <pre><code class="language-cpp">// 1. World Subsystem 생성

// 2. Physics World 생성
if (IVS.bCreatePhysicsScene)
{
    CreatePhysicsScene(WorldSettings);
}

// 3. Render World 생성
GetRendererModule().AllocateScene(
    this,
    bRequiresHitProxies,
    IVS.bCreateFXSystem,
    GetFeatureLevel()
);

// 4. AI Navigation 생성
if (IVS.bCreateNavigation)
{
    FNavigationSystem::AddNavigationSystemToWorld(...);
}</code></pre>

                <h2>핵심 정리</h2>
                <ol>
                    <li><strong>World 분리</strong>: Game, Physics, Render World로 역할 분담</li>
                    <li><strong>Thread 시스템</strong>: 각 World마다 전문 Thread 배치</li>
                    <li><strong>병렬 처리</strong>: 멀티스레드로 성능 향상</li>
                    <li><strong>InitWorld</strong>: Physics World와 Render World 생성하는 핵심 함수</li>
                    <li><strong>Persistent Level</strong>: Levels[0]에 저장되는 필수 Level</li>
                </ol>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec5'] = {
            title: '월드 액터 등록',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>월드 액터 등록</h1>
                </div>
                <h2>Overview</h2>
                <p>액터가 월드에 등록되는 과정과 액터와 UObject의 차이를 이해합니다.</p>

                <h2>액터를 등록한다는 것</h2>
                <h3>액터란 무엇인가?</h3>
                <div class="callout">
                    <div class="callout-title">Actor의 정의</div>
                    <p><strong>World에 배치할 수 있는 것</strong></p>
                </div>

                <h3>액터와 UObject의 차이</h3>
                <pre><code class="language-cpp">// 핵심 차이점
// Actor와 UObject는 외부적 개입요소가 없다면 완전히 동일한 클래스
// 그 외부적 개입요소란? → Component!

// Actor = UObject + Components
UObject + Transform Component + Render Component + Mesh Component = Actor</code></pre>

                <div class="callout important">
                    <div class="callout-title">액터 등록의 핵심</div>
                    <p>UObject에 Transform Component, Render 관련 Component, Mesh Component 등이 있어야 World에 배치되고 Rendering 될 수 있습니다. <strong>즉, Actor을 등록한다는 것은 Component를 등록하는 과정이라고 볼 수 있습니다.</strong></p>
                </div>

                <h2>UpdateWorldComponents</h2>
                <p>Level에 있는 Actor를 <strong>순차적으로 돌며 등록</strong>합니다.</p>

                <h3>등록 컨셉</h3>
                <table>
                    <tr><th>컨셉</th><th>설명</th></tr>
                    <tr><td>나누어서 처리</td><td>한 프레임에 모두 처리하는 것이 아니라 프레임 별로 나누어 처리 (런타임)</td></tr>
                    <tr><td>계층 구조 보장</td><td>Root - Child1 - Child2의 구조를 가지는 Actor는 계층의 순서대로 등록</td></tr>
                    <tr><td>Component 분할 처리</td><td>정렬 방식에 의존하지 않고 부모 Component부터 등록 시작</td></tr>
                </table>

                <div class="callout warning">
                    <div class="callout-title">문제점</div>
                    <p><strong>Level에 Actor를 저장할 때 순서는 보장이 안 되어있습니다.</strong> (계층 정보 생각하지 않고 일단 저장함) → 계층에 맞게 <strong>정렬하는 과정이 필요</strong></p>
                </div>

                <h2>IncrementalUpdateComponents</h2>
                <h3>3단계 처리 과정</h3>
                <table>
                    <tr><th>단계</th><th>이름</th><th>설명</th></tr>
                    <tr><td>1</td><td>Init</td><td>SortActorsHierarchy - Actor들을 계층적으로 정렬</td></tr>
                    <tr><td>2</td><td>RegisterInitialComponents</td><td>Level에 존재하는 Actor 등록</td></tr>
                    <tr><td>3</td><td>Finalize</td><td>다음 호출을 위해 변수들 초기화</td></tr>
                </table>

                <pre><code class="language-cpp">switch (IncrementalComponentState)
{
    case EIncrementalComponentState::Init:
        // Actor들을 계층적으로 정렬
        SortActorsHierarchy();
        break;

    case EIncrementalComponentState::RegisterInitialComponents:
        // Level에 존재하는 Actor 등록
        IncrementalRegisterComponents();
        break;

    case EIncrementalComponentState::Finalize:
        // 변수들 초기화
        ResetIncrementalState();
        break;
}</code></pre>

                <h2>핵심 정리</h2>
                <ol>
                    <li><strong>Actor = UObject + Components</strong>: 등록은 결국 Component 등록</li>
                    <li><strong>3가지 컨셉</strong>: 프레임 분할 처리, Actor 계층 구조 보장, Component 계층 보장</li>
                    <li><strong>3단계 처리</strong>: Init(계층 정렬), Register(Actor 등록), Finalize(상태 초기화)</li>
                    <li><strong>NumComponents 파라미터</strong>: 0이면 전체, 양수면 개수만큼</li>
                </ol>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec6'] = {
            title: '액터 계층 정렬',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>액터 계층 정렬</h1>
                </div>
                <h2>Overview</h2>
                <p>SortActorsHierarchy 함수의 상세 분석과 SceneComponent, ChildActorComponent를 이해합니다.</p>

                <div class="callout">
                    <div class="callout-title">SortActorsHierarchy의 목적</div>
                    <p>Level에 Root-Child 계층으로 정리되지 않고 <strong>무분별하게 등록된 액터들을 계층에 맞게 정렬</strong>하는 과정</p>
                </div>

                <h2>SceneComponent</h2>
                <div class="callout tip">
                    <div class="callout-title">SceneComponent란?</div>
                    <p><strong>월드 공간에서 좌표를 가질 수 있는 매우 중요한 컴포넌트</strong></p>
                </div>
                <table>
                    <tr><th>특징</th><th>설명</th></tr>
                    <tr><td>계층 구조</td><td>컴포넌트 간의 계층을 가질 수 있음</td></tr>
                    <tr><td>RootComponent</td><td>Actor의 RootComponent가 SceneComponent임</td></tr>
                    <tr><td>Attach 가능</td><td>다른 SceneComponent에 부착 가능</td></tr>
                </table>

                <pre><code class="language-cpp">class AActor : public UObject
{
protected:
    // Actor의 RootComponent
    UPROPERTY(...)
    TObjectPtr<USceneComponent> RootComponent;
}</code></pre>

                <div class="callout warning">
                    <div class="callout-title">생명주기 주의사항</div>
                    <p><strong>SceneComponent로 부착된 액터 간에는 생명주기를 같이 하지 않습니다.</strong> 즉, A에 B가 부착된 상태에서 A액터를 Destroy해도 B 액터는 월드에 남아있습니다.</p>
                </div>

                <h2>ChildActorComponent</h2>
                <div class="callout important">
                    <div class="callout-title">ChildActorComponent의 특징</div>
                    <p>액터 간에 부착했을 때 <strong>생명 주기를 같이 하도록</strong> 하는 특별한 컴포넌트</p>
                </div>

                <h2>정렬 방식</h2>
                <h3>1. 일반적인 경우</h3>
                <div class="hierarchy-box">자신의 부모가 몇 번 타고 올라갈 수 있느냐에 따라 Depth를 결정

Root(Depth 0)
└── Child(Depth 1)
    └── Child of Child(Depth 2)</div>

                <h3>2. 특수한 경우 (ChildActorComponent)</h3>
                <div class="hierarchy-box">// Child의 부모가 ChildActorComponent인 경우
// +1이 아니라 -1로 처리

Root(Depth 0)
└── ChildActorComponent(Depth 1)
    └── Child of ChildActorComponent(부모 - 1 = Depth 0)</div>

                <div class="callout">
                    <div class="callout-title">왜 특수한 규칙이 존재하는가?</div>
                    <p><strong>ChildComponent에 의한 Child Actor의 경우</strong>, Child Actor 자체의 초기화가 먼저 종료되지 않으면 등록 과정에서 문제가 발생할 수 있기 때문에 <strong>depth를 부모보다 높게 설정</strong></p>
                </div>

                <h2>SortActorsHierarchy 코드</h2>
                <h3>주요 변수</h3>
                <pre><code class="language-cpp">// 정렬에 따른 Hierarchy Depth를 저장하기 위한 변수
TMap<AActor*, int32> DepthMap;

// 참조 순환 문제를 해결하기 위한 변수
TSet<AActor*> VisitedActors;</code></pre>

                <h3>CalcAttachDepth 람다식</h3>
                <pre><code class="language-cpp">auto CalcAttachDepth = [&](AActor* InActor, auto& CalcAttachDepthRef) -> int32
{
    // WorldSetting은 가장 중요하므로 Depth를 가장 낮게 지정
    if (InActor->IsA<AWorldSettings>())
    {
        DepthMap.Add(InActor, 0);
        return 0;
    }

    // 부모 액터가 존재한다면
    if (AActor* ParentActor = InActor->GetAttachParentActor())
    {
        int32 ParentDepth = CalcAttachDepthRef(ParentActor, CalcAttachDepthRef);

        if (InActor->GetParentComponent()->IsA<UChildActorComponent>())
        {
            // 특수한 경우: ChildActorComponent
            CurrentDepth = ParentDepth - 1;
        }
        else
        {
            // 일반적인 경우
            CurrentDepth = ParentDepth + 1;
        }
    }

    DepthMap.Add(InActor, CurrentDepth);
    return CurrentDepth;
};</code></pre>

                <h2>핵심 정리</h2>
                <ol>
                    <li><strong>SceneComponent</strong>: 월드 좌표를 가지는 핵심 컴포넌트 (Actor의 RootComponent, 생명주기 독립적)</li>
                    <li><strong>ChildActorComponent</strong>: 생명주기를 함께하는 특수 컴포넌트</li>
                    <li><strong>정렬 방식</strong>: 일반(Depth = Parent + 1), ChildActorComponent(Depth = Parent - 1)</li>
                    <li><strong>DepthMap</strong>: Depth 저장</li>
                    <li><strong>VisitedActors</strong>: 순환 참조 방지</li>
                </ol>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec7'] = {
            title: '컴포넌트 증분 등록',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>컴포넌트 증분 등록</h1>
                </div>
                <h2>Overview</h2>
                <p>액터 내부의 컴포넌트를 <strong>나눠서 등록</strong>하는 걸 코드에서 어떻게 처리하는가를 보는 것이 핵심입니다.</p>

                <h2>함수 호출 흐름</h2>
                <div class="flow-vertical">
                    <div class="flow-node">IncrementalUpdateComponents</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">EIncrementalComponentState::RegisterInitialComponent</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">IncrementalRegisterComponents</div>
                </div>

                <div class="callout important">
                    <div class="callout-title">기억할 것</div>
                    <p><strong>프레임 별로 나누어서 처리한다!</strong></p>
                </div>

                <h2>코드 상세 분석</h2>
                <h3>1. 액터 인덱스 관리</h3>
                <pre><code class="language-cpp">// CurrentActorIndexForIncrementalUpdate 변수
// 그 전까지 몇 번 액터 등록을 마쳤는지를 저장하는 변수
int32 CurrentActorIndexForIncrementalUpdate;

// 해당 index의 액터를 가져와 등록을 진행하기 시작
AActor* Actor = Actors[CurrentActorIndexForIncrementalUpdate];</code></pre>

                <h3>2. PreRegister 단계 확인</h3>
                <pre><code class="language-cpp">// 컴포넌트가 모두 등록되지 않았다면?
if (!Actor->IsActorInitialized())
{
    // PreRegister 단계 여부를 확인
    if (!bHasCurrentActorCalledPreRegister)
    {
        // 한 번만 호출되도록 보장
        Actor->PreRegisterAllComponents();
        bHasCurrentActorCalledPreRegister = true;
    }

    // Actor의 IncrementalRegisterComponents 호출
    Actor->IncrementalRegisterComponents(NumComponentsToUpdate);
}</code></pre>

                <div class="callout warning">
                    <div class="callout-title">PreRegister 중복 호출 방지</div>
                    <p>컴포넌트가 <strong>프레임별로 나누어서 처리되는 경우</strong>에는 bHasCurrentActorCalledPreRegister 변수가 없다면 계속해서 액터의 PreRegisterAllComponent가 호출될 수 있습니다. 그러므로 해당 변수를 통해 액터의 <strong>PreRegister는 한 번만 불리도록</strong> 합니다.</p>
                </div>

                <h3>3. NumComponentsToUpdate 처리</h3>
                <table>
                    <tr><th>NumComponentsToUpdate</th><th>동작</th></tr>
                    <tr><td>0</td><td>한 프레임에서 모두 처리 (Level 처음 로드할 때)</td></tr>
                    <tr><td>양수</td><td>지정된 개수만큼 처리 (런타임)</td></tr>
                </table>

                <h3>4. 액터 등록 완료 처리</h3>
                <pre><code class="language-cpp">// 해당 프레임에서 액터의 컴포넌트가 모두 등록되었다면
if (Actor->IsActorInitialized())
{
    // 다음 액터로 이동
    CurrentActorIndexForIncrementalUpdate++;

    // PreRegister 관련 변수 초기화
    bHasCurrentActorCalledPreRegister = false;
}</code></pre>

                <h3>5. RenderWorld 등록</h3>
                <pre><code class="language-cpp">// PrimitiveComponent를 RenderWorld에 등록
// 모든 액터 등록 완료 후 일괄 처리
if (CurrentActorIndexForIncrementalUpdate >= Actors.Num())
{
    if (Context)
    {
        Context->Process();  // 병렬로 등록
    }
}</code></pre>

                <div class="callout">
                    <div class="callout-title">왜 마지막에 한 번에 RenderWorld 등록?</div>
                    <p>모든 액터 컴포넌트가 등록된 이후에 처리하는 이유는 <strong>성능 향상</strong>을 위함입니다. 컴포넌트가 등록될 때마다 RenderWorld에 등록하면 <strong>병목 현상</strong>이 발생합니다.</p>
                </div>

                <h2>처리 단계 표</h2>
                <table>
                    <tr><th>단계</th><th>동작</th><th>조건</th></tr>
                    <tr><td>1</td><td>인덱스 확인</td><td>CurrentActorIndexForIncrementalUpdate</td></tr>
                    <tr><td>2</td><td>PreRegister</td><td>한 번만 호출</td></tr>
                    <tr><td>3</td><td>Component 등록</td><td>NumComponentsToUpdate 개수만큼</td></tr>
                    <tr><td>4</td><td>완료 처리</td><td>인덱스 증가, 플래그 초기화</td></tr>
                    <tr><td>5</td><td>Break 판단</td><td>NumComponentsToUpdate > 0이면 break</td></tr>
                    <tr><td>6</td><td>Render 등록</td><td>모든 Actor 등록 완료 시</td></tr>
                </table>

                <h2>핵심 정리</h2>
                <ol>
                    <li><strong>프레임 분할</strong>: NumComponentsToUpdate로 제어 (0: 전체, 양수: 지정 개수)</li>
                    <li><strong>PreRegister</strong>: bHasCurrentActorCalledPreRegister로 중복 호출 방지</li>
                    <li><strong>CurrentActorIndex</strong>: 진행 상황 추적</li>
                    <li><strong>RenderWorld 등록</strong>: 모든 Actor 등록 후 일괄 처리 (성능 최적화)</li>
                    <li><strong>점진적 처리</strong>: 프레임 드랍 방지를 위한 분할 처리</li>
                </ol>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec8'] = {
            title: '컴포넌트 등록',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>컴포넌트 등록</h1>
                </div>
                <h2>Overview</h2>
                <p>컴포넌트의 정렬 과정과 등록하는 함수를 이해합니다.</p>

                <h2>컴포넌트 등록 컨셉</h2>
                <h3>1. 부모 컴포넌트가 없는 경우</h3>
                <div class="hierarchy-box">GetComponents로 가져온 순서대로 선형적으로 진행

Component1 → Component2 → Component3 → ...</div>

                <h3>2. 부모 컴포넌트를 가지는 경우</h3>
                <div class="hierarchy-box">부모 컴포넌트를 타고 올라가며 등록 여부 확인

Child Component (등록 시도)
    ↓ (부모 확인)
Parent Component (미등록 발견)
    ↓ (부모의 부모 확인)
Root Component (등록 완료)
    ↓
✅ 부모 Component부터 등록 진행</div>

                <h3>3. 지정된 개수만큼 나누어서 등록하는 경우</h3>
                <p>지정된 개수만큼 위의 두 가지 컨셉을 유지하여 등록 (프레임 분할 처리)</p>

                <h2>IncrementalRegisterComponents 코드</h2>
                <h3>1. NumComponentsToRegister 처리</h3>
                <pre><code class="language-cpp">// 인자로 들어온 NumComponentsToRegister 처리
if (NumComponentsToRegister == 0)
{
    // MAX_INT값을 넣어주며 한 프레임에 모든 컴포넌트 등록 처리
    NumComponentsToRegister = MAX_int32;
}</code></pre>

                <h3>2. RootComponent 우선 등록</h3>
                <pre><code class="language-cpp">// 항상 RootComponent를 제일 먼저 등록함
if (RootComponent && !RootComponent->IsRegistered())
{
    RootComponent->RegisterComponent();
    NumTotalRegisteredComponents++;
}</code></pre>

                <div class="callout important">
                    <div class="callout-title">RootComponent 우선 등록</div>
                    <p><strong>모든 컴포넌트는 RootComponent에 Attach</strong>되므로 RootComponent를 먼저 등록해야 합니다.</p>
                </div>

                <h3>3. 전체 컴포넌트 등록 로직</h3>
                <pre><code class="language-cpp">// GetComponents로 모든 컴포넌트를 들고 온 다음
TArray<UActorComponent*> Components;
GetComponents(Components);

// 3가지 컨셉에 따라 for문을 돌며 등록을 진행
for (int32 CompIdx = 0; CompIdx < Components.Num(); CompIdx++)
{
    UActorComponent* Component = Components[CompIdx];

    // Registered 여부 판단
    if (!Component->IsRegistered())
    {
        USceneComponent* SceneComp = Cast<USceneComponent>(Component);

        // 부모 찾기
        while (SceneComp && SceneComp->GetAttachParent())
        {
            SceneComp = SceneComp->GetAttachParent();

            if (!SceneComp->IsRegistered())
            {
                // 등록되지 않은 부모 발견!
                CompIdx--;
                NumTotalRegisteredComponents--;
                Component = SceneComp;
                break;
            }
        }

        // 실제 등록
        Component->RegisterComponent();
    }

    NumTotalRegisteredComponents++;

    // 지정된 개수만큼 등록했으면 break
    if (--NumComponentsToRegister == 0)
    {
        break;
    }
}</code></pre>

                <h2>주요 변수 역할</h2>
                <table>
                    <tr><th>변수</th><th>역할</th><th>용도</th></tr>
                    <tr><td>NumComponentsToRegister</td><td>등록할 개수</td><td>0이면 전체, 양수면 해당 개수만큼</td></tr>
                    <tr><td>NumTotalRegisteredComponents</td><td>현재까지 등록된 개수</td><td>진행 상황 추적</td></tr>
                    <tr><td>CompIdx</td><td>현재 처리 중인 인덱스</td><td>부모 처리 시 -1로 조정</td></tr>
                </table>

                <div class="callout tip">
                    <div class="callout-title">Index 조정 로직</div>
                    <pre><code class="language-cpp">// 부모를 먼저 등록해야 할 때
CompIdx--;                      // 현재 인덱스 유지
NumTotalRegisteredComponents--; // 카운터 조정
Component = ParentComponent;    // 부모로 교체</code></pre>
                    <p>이렇게 하면: 부모가 먼저 등록됨 → 다음 루프에서 원래 컴포넌트로 돌아옴 → 최종 카운트가 정확히 맞음</p>
                </div>

                <h2>핵심 정리</h2>
                <ol>
                    <li><strong>3가지 등록 컨셉</strong>: 선형 등록, 계층 등록, 분할 등록</li>
                    <li><strong>RootComponent 우선</strong>: 모든 컴포넌트의 기준</li>
                    <li><strong>부모 우선 등록</strong>: 미등록 부모 발견 시 부모부터</li>
                    <li><strong>Index 조정</strong>: CompIdx--, NumTotal--로 정확한 처리</li>
                    <li><strong>완료 Notify</strong>: 모든 등록 완료 시 World에 알림</li>
                </ol>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec9'] = {
            title: '컴포넌트 등록 과정',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>컴포넌트 등록 과정</h1>
                </div>
                <h2>Overview</h2>
                <p>컴포넌트 등록이라는 실체가 무엇인지 이해합니다.</p>

                <h2>3단계 컨셉</h2>
                <table>
                    <tr><th>단계</th><th>설명</th></tr>
                    <tr><td>1. 부모 정보 기반 Update</td><td>컴포넌트는 계층 구조를 가지고 있고, 부모-자식 관계로 업데이트되어야 하는 경우(예: transform)가 존재</td></tr>
                    <tr><td>2. 전문 월드에 등록</td><td>컴포넌트를 각각의 전문 월드(Game, Physics, Render)에 등록</td></tr>
                    <tr><td>3. Tick 등록</td><td>만약 게임이 이미 시작된 환경이라면 Tick 함수까지 등록 진행</td></tr>
                </table>

                <h2>World별 등록 전략</h2>
                <h3>예시: Static Mesh Cube</h3>
                <div class="callout">
                    <div class="callout-title">Static Mesh Cube는 어떤 월드에 등록되어야 할까?</div>
                </div>
                <table>
                    <tr><th>World</th><th>필요 여부</th><th>이유</th></tr>
                    <tr><td>GameWorld</td><td>✅</td><td>Transform 정보를 GameWorld에 알려줘야 함</td></tr>
                    <tr><td>RenderWorld</td><td>✅</td><td>메시나 머티리얼 정보를 RenderWorld에 알려서 화면에 표시</td></tr>
                    <tr><td>PhysicsWorld</td><td>✅</td><td>캐릭터가 밟거나 물리적 상호작용을 위해</td></tr>
                </table>

                <h3>예시: SceneComponent</h3>
                <table>
                    <tr><th>World</th><th>필요 여부</th><th>이유</th></tr>
                    <tr><td>GameWorld</td><td>✅</td><td>Transform 정보만 필요</td></tr>
                    <tr><td>RenderWorld</td><td>❌</td><td>시각적 정보 없음</td></tr>
                    <tr><td>PhysicsWorld</td><td>❌</td><td>물리적 정보 없음</td></tr>
                </table>

                <div class="callout important">
                    <div class="callout-title">World 분할의 이유</div>
                    <p>SceneComponent가 RenderWorld에 가서 "그려야 될 정보가 없냐?"고 물어볼 필요도 없고, PhysicsWorld에 가서 충돌 여부를 확인할 필요도 없으므로 <strong>등록되지 않습니다</strong>. 만약 등록된다면 <strong>비효율적인 로직으로 시스템 자원을 낭비</strong>하게 될 것입니다.</p>
                </div>

                <h2>RegisterComponentWithWorld 코드</h2>
                <h3>액터(컴포넌트)의 등록 과정</h3>
                <div class="flow">
                    <div class="flow-node">Create</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Register</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Initialize</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">BeginPlay</div>
                </div>

                <h3>1. Create 단계</h3>
                <pre><code class="language-cpp">// OnComponentCreated -> Create 시작
OnComponentCreated();</code></pre>

                <h3>2. Register 단계 (ExecuteRegisterEvents)</h3>
                <pre><code class="language-cpp">// 부모 정보 기반 업데이트
OnRegister();
UpdateComponentToWorld();  // 좌표와 같은 부모 정보를 토대로 컴포넌트 정보 업데이트

// RenderWorld에 컴포넌트 분신을 생성하여 등록
CreateRenderState_Concurrent(Context);

// PhysicsWorld에 컴포넌트 분신을 생성하여 등록
CreatePhysicsState(/*bAllowDeferral=*/true);</code></pre>

                <div class="callout">
                    <div class="callout-title">왜 GameWorld에는 등록하지 않나요?</div>
                    <p>현재 코드를 쓰고 있는 영역이 <strong>GameWorld</strong>라고 생각하면 편합니다. NewObject 같은 로직을 사용하면 <strong>GameWorld에 자동으로 등록</strong>된다고 보면 됩니다.</p>
                </div>

                <h3>3. Initialize & BeginPlay 단계</h3>
                <pre><code class="language-cpp">// HandleRegisterComponentWithWorld에서:

// Initialize 과정 진행
InitializeComponent();

// 만약 Owner가 BeginPlay 된 상황이라면 (런타임에 컴포넌트 생성)
if (Owner->HasActorBegunPlay())
{
    // Tick에 등록
    RegisterAllComponentTickFunctions(/*bRegister=*/true);

    // BeginPlay 실행
    BeginPlay();
}</code></pre>

                <h2>등록 단계 요약</h2>
                <table>
                    <tr><th>순서</th><th>단계</th><th>함수</th><th>설명</th></tr>
                    <tr><td>1</td><td>Create</td><td>OnComponentCreated()</td><td>컴포넌트 생성</td></tr>
                    <tr><td>2</td><td>Register</td><td>ExecuteRegisterEvents()</td><td>부모 정보 업데이트, World 등록</td></tr>
                    <tr><td>3</td><td>Update</td><td>UpdateComponentToWorld()</td><td>Transform 등 업데이트</td></tr>
                    <tr><td>4</td><td>Render</td><td>CreateRenderState_Concurrent()</td><td>RenderWorld 등록</td></tr>
                    <tr><td>5</td><td>Physics</td><td>CreatePhysicsState()</td><td>PhysicsWorld 등록</td></tr>
                    <tr><td>6</td><td>Initialize</td><td>InitializeComponent()</td><td>초기화</td></tr>
                    <tr><td>7</td><td>Tick & Begin</td><td>RegisterAllComponentTickFunctions() + BeginPlay()</td><td>런타임 추가 시</td></tr>
                </table>

                <h2>핵심 정리</h2>
                <ol>
                    <li><strong>3단계 컨셉</strong>: 부모 기반 업데이트, 전문 World 등록, Tick 등록 (런타임)</li>
                    <li><strong>World 분할의 이유</strong>: 효율성 (필요한 World에만 등록)</li>
                    <li><strong>등록 순서</strong>: Create → Register → Initialize → BeginPlay</li>
                    <li><strong>ExecuteRegisterEvents</strong>: RenderWorld, PhysicsWorld 등록의 핵심</li>
                    <li><strong>GameWorld</strong>: 자동 등록 (현재 실행 영역)</li>
                </ol>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec10'] = {
            title: 'PIE 생성 및 초기화',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>PIE 생성 및 초기화</h1>
                </div>
                <h2>Overview</h2>
                <p>PIE(Play In Editor)의 핵심 3가지를 이해합니다:</p>
                <ul>
                    <li><strong>Start</strong> - 어떻게 시작되는가</li>
                    <li><strong>Init</strong> - 어떻게 초기화되는가</li>
                    <li><strong>Create</strong> - 어떻게 생성되는가</li>
                </ul>

                <h2>EngineTick</h2>
                <h3>FEngineLoop Tick</h3>

                <h4>1. 시간 및 Tick Rate 관리</h4>
                <pre><code class="language-cpp">// UpdateTimeAndHandleMaxTickRate()
// 언리얼에 존재하는 여러 개 World를 실행하는 Thread들의 Sync를
// GameWorld Thread 기준으로 맞추고 DeltaTime과 CurrentTime을 제공
GEngine->UpdateTimeAndHandleMaxTickRate();</code></pre>

                <h4>2. Engine Tick</h4>
                <table>
                    <tr><th>Tick 항목</th><th>함수</th><th>설명</th></tr>
                    <tr><td>TimeManager</td><td>TimeManager->Tick()</td><td>타임 매니저</td></tr>
                    <tr><td>World</td><td>PieContext.World->Tick()</td><td>월드 틱</td></tr>
                    <tr><td>Viewport</td><td>ViewportClient->Tick()</td><td>뷰포트 클라이언트</td></tr>
                </table>

                <h4>3. Play 버튼 체크</h4>
                <pre><code class="language-cpp">// 주목해 봐야할 함수
if (PlaySessionRequest.IsSet())
{
    // Editor에서 Play 버튼 눌렀는지 체크한다
    StartQueuedPlaySessionRequest();
}</code></pre>

                <div class="callout warning">
                    <div class="callout-title">별거아니네 모먼트</div>
                    <p>굳이 이걸 <strong>Tick으로 체크</strong>하고 있네...? → 언리얼 엔진도 별거아니네!</p>
                </div>

                <h2>StartQueuedPlaySessionRequestImpl</h2>
                <h3>1. 이전 플레이 데이터 제거</h3>
                <pre><code class="language-cpp">// 기존에 시작된 정보가 있다면 전부 리셋
EndPlayOnLocalPc();

// 이미 플레이 중인 맵이 있는 경우 닫아버림
if (PlayWorld && PlaySessionRequest->SessionDestination == EPlaySessionDestinationType::InProcess)
{
    EndPlayMap();
}</code></pre>

                <h3>2. 요청된 모드에 따른 Session 시작</h3>
                <pre><code class="language-cpp">switch (PlaySessionRequest->SessionDestination)
{
    case EPlaySessionDestinationType::InProcess:
        StartPlayInEditorSession(PlaySessionRequest.GetValue());  // 가장 기본
        break;

    case EPlaySessionDestinationType::NewProcess:
        StartPlayInNewProcessSession(PlaySessionRequest.GetValue());
        break;

    case EPlaySessionDestinationType::Launcher:
        StartPlayUsingLauncherSession(PlaySessionRequest.GetValue());
        break;
}</code></pre>

                <h2>StartPlayInEditorSession</h2>
                <h3>1. 에셋 로딩 대기</h3>
                <pre><code class="language-cpp">// 게임에 필요한 에셋들이 로딩될 때까지 대기
FEditorDelegates::PreBeginPIE.Broadcast(...);</code></pre>

                <h3>2. PIE 세팅 불러오기</h3>
                <pre><code class="language-cpp">InRequestParams.EditorPlaySettings->GetRunUnderOneProcess(bUserWantsSingleProcess);
InRequestParams.EditorPlaySettings->GetPlayNetMode(NetMode);
InRequestParams.EditorPlaySettings->GetPlayNumberOfClients(NumClients);

// PIE 생성은 최소 1개로 보장
int32 NumRequestedInstances = FMath::Max(NumClients, 1);</code></pre>

                <h3>3. PIE 환경 시작</h3>
                <pre><code class="language-cpp">// for문을 순회하는 이유는 여러 개의 PIE 환경일 수 있기 때문
for (int32 InstanceIndex = 0; InstanceIndex < NumRequestedInstances; InstanceIndex++)
{
    // PIE 생성
    CreateNewPlayInEditorInstance(InRequestParams, bRunAsDedicated, LocalNetMode);
}</code></pre>

                <h2>CreateNewPlayInEditorInstance</h2>
                <h3>OnLoginPIEComplete_Deferred</h3>
                <pre><code class="language-cpp">// GameWorld에 대한 중요한 정보를 가져와 저장
FWorldContext* PieWorldContext = GetWorldContextFromHandle(DataStruct.WorldContextHandle);

// 본격적인 GameFramework를 초기화하고 GameWorld를 준비
UGameInstance* GameInstance = CreateInnerProcessPIEGameInstance(...);</code></pre>

                <h2>핵심 플로우</h2>
                <div class="flow-vertical">
                    <div class="flow-node">EngineTick</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">PlaySessionRequest 체크</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">StartQueuedPlaySessionRequest</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">StartPlayInEditorSession</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">CreateNewPlayInEditorInstance</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">CreateInnerProcessPIEGameInstance</div>
                </div>

                <h2>핵심 정리</h2>
                <ol>
                    <li><strong>EngineTick</strong>: UpdateTime + Tick + Play 버튼 체크</li>
                    <li><strong>StartQueuedPlaySessionRequest</strong>: 외부 함수 + Impl 분리 패턴</li>
                    <li><strong>StartPlayInEditorSession</strong>: 에셋 로딩 + 세팅 + PIE 생성</li>
                    <li><strong>CreateNewPlayInEditorInstance</strong>: GameWorld 정보 + GameInstance 생성</li>
                    <li><strong>NumClients</strong>: 최소 1개 보장</li>
                </ol>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec11'] = {
            title: '게임 초기화 과정',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>게임 초기화 과정</h1>
                </div>
                <h2>Overview</h2>
                <p>게임이 시작될 때 필요한 핵심 컴포넌트들이 순차적으로 생성되는 과정을 이해합니다.</p>

                <h2>게임 초기화 11단계</h2>

                <h3>1. GameInstance 생성</h3>
                <p>Game의 생명주기와 완벽하게 동일하며, 게임 전반의 상태를 관리하는 최상위 객체입니다.</p>

                <h3>2. (Game)World 생성</h3>
                <p>실제로 플레이어가 게임과 상호작용하는 공간입니다.</p>

                <h3>3. GameViewportClient 생성</h3>
                <p>게임을 모니터에서 눈으로 보는 역할. 운영체제로부터 Input을 전달받는 창구입니다.</p>

                <h3>4. LocalPlayer 생성</h3>
                <p>Play를 진행하는 실제 플레이어와 동일. Engine 수준에서의 나를 대변합니다.</p>

                <h3>5. GameMode 생성</h3>
                <p>Game의 규칙 관리자. World 관리자(Pawn 입장, 퇴장 등). <strong>오직 서버에만 존재</strong>합니다.</p>

                <h3>6. GameState 생성</h3>
                <p>GameMode의 정보를 client에서 확인하기 위함. 네트워크 복제를 통해 클라이언트에 전달됩니다.</p>

                <h3>7. PlayerController 생성</h3>
                <p>Game World에서 나를 대변하고 조종하는 대상을 지휘. World 속의 나를 대변합니다.</p>

                <h3>8. PlayerState 생성</h3>
                <p>PlayerController의 정보를 다른 client에서 확인하기 위함. 점수, 이름 등 플레이어 관련 정보 복제.</p>

                <h3>9. CameraManager 생성</h3>
                <p>PlayerController 내부에 존재. 내가 조종하는 Pawn을 기준으로 화면을 보여주기 위함.</p>

                <h3>10. PlayerInput 생성</h3>
                <p>ViewportClient로부터 받아온 Input을 저장. Tick마다 해당 입력을 Controller나 Pawn으로 넘겨서 수행.</p>

                <h3>11. Pawn 생성</h3>
                <p>내가 Gameworld에서 조정하는 Character. PlayerController가 Possess 과정을 거쳐 조정 가능.</p>

                <h2>CreateInnerProcessPIEGameInstance 코드</h2>
                <h3>1. GameInstance Class 로딩</h3>
                <pre><code class="language-cpp">// ProjectSetting에 저장되어 있는 GameInstance Class 가져와서 UClass 로딩 진행
FSoftClassPath GameInstanceClassName = GetDefault<UGameMapsSettings>()->GameInstanceClass;
UClass* GameInstanceClass = GameInstanceClassName.TryLoadClass<UGameInstance>();

// ProjectSetting에 GameInstance가 None이라면 기본 클래스
if (!GameInstanceClass)
{
    GameInstanceClass = UGameInstance::StaticClass();
}

// GameInstance 생성
UGameInstance* GameInstance = NewObject<UGameInstance>(this, GameInstanceClass);</code></pre>

                <h3>2. Editor World 복제</h3>
                <pre><code class="language-cpp">// 게임 인스턴스 서브시스템 생성 및 내부적으로 월드 복제와 구성까지 진행
const FGameInstancePIEResult InitializeResult =
    GameInstance->InitializeForPlayInEditor(InPIEInstanceIndex, InPIEParameters);</code></pre>

                <h3>3. GameViewportClient 생성</h3>
                <pre><code class="language-cpp">ViewportClient = NewObject<UGameViewportClient>(this, GameViewportClientClass);</code></pre>

                <h3>4. LocalPlayer 생성</h3>
                <pre><code class="language-cpp">NewLocalPlayer = ViewportClient->SetupInitialLocalPlayer(Error);</code></pre>

                <h3>5. World의 필수 구성요소 생성</h3>
                <pre><code class="language-cpp">// GameMode 생성
FGameInstancePIEResult StartResult =
    GameInstance->StartPlayInEditorGameInstance(NewLocalPlayer, InPIEParameters);</code></pre>

                <h2>처리 흐름도</h2>
                <div class="flow-vertical">
                    <div class="flow-node">PIE 시작</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">GameInstance 생성</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">World 복제</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">GameViewportClient 생성</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">LocalPlayer 생성</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">GameMode / PlayerController / Pawn</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">게임 플레이 시작</div>
                </div>

                <h2>핵심 포인트</h2>
                <div class="callout">
                    <div class="callout-title">생성 순서의 중요성</div>
                    <ul>
                        <li>GameInstance는 Game의 생명주기와 동일하게 유지됩니다</li>
                        <li>GameMode는 서버에만 존재하고, GameState를 통해 클라이언트와 정보를 공유합니다</li>
                        <li>LocalPlayer(Engine 수준)와 PlayerController(World 수준)는 서로 다른 레벨에서 플레이어를 대변합니다</li>
                    </ul>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec12'] = {
            title: '에디터 월드 복제',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>에디터 월드 복제</h1>
                </div>
                <h2>Overview</h2>
                <p>에디터에 있는 월드를 그대로 복제하여 PIE(Play In Editor) 환경의 Game World를 생성하는 과정을 이해합니다.</p>

                <h2>InitializeForPlayInEditor</h2>
                <div class="callout">
                    <div class="callout-title">핵심 질문</div>
                    <p>어떤 식으로 Editor World를 복제하는가?</p>
                </div>

                <h3>1. World Context PIE 환경 세팅</h3>
                <pre><code class="language-cpp">// PIEInstanceIndex는 PIE를 여러개 실행할 때 구분하기 위한 고유 번호
WorldContext = EditorEngine->GetWorldContextFromPIEInstance(PIEInstanceIndex);

// 만약에 WorldContext가 없다면 생성
if (!WorldContext)
{
    WorldContext = &EditorEngine->CreateNewWorldContext(EWorldType::PIE);
    WorldContext->PIEInstance = PIEInstanceIndex;
}

// WorldContext에 GameInstance 설정
WorldContext->OwningGameInstance = this;</code></pre>

                <h3>2. 에디터 월드 복제</h3>
                <pre><code class="language-cpp">// PIE의 맵은 모두 동일해서 Duplicate로 복사로 진행
NewWorld = EditorEngine->CreatePIEWorldByDuplication(*WorldContext, WorldToDuplicate, PIEMapName);</code></pre>

                <h3>3. 복제된 월드 기본 설정</h3>
                <pre><code class="language-cpp">NewWorld->SetPlayInEditorInitialNetMode(...);
NewWorld->SetGameInstance(this);</code></pre>

                <h3>4. Game Instance Subsystem 생성</h3>
                <pre><code class="language-cpp">Init();</code></pre>

                <h3>5. World 필수 구성요소 생성</h3>
                <pre><code class="language-cpp">// 월드에 대한 초기화 진행 (PhysicsWorld, RenderWorld 등등 생성)
EditorEngine->PostCreatePIEWorld(NewWorld);</code></pre>

                <h2>CreatePIEWorldByDuplication</h2>
                <div class="callout">
                    <div class="callout-title">Editor World의 정체</div>
                    <ul>
                        <li>Engine 단계에서의 World는 Editor World</li>
                        <li>GameInstance의 Outer는 Engine</li>
                        <li>World Context를 통해 Editor World를 가져옴</li>
                    </ul>
                </div>

                <h3>PIE Package 설정</h3>
                <pre><code class="language-cpp">// PIE에 사용할 수 있도록 Package 설정
UPackage* PlayWorldPackage = CreatePackage(*PlayWorldMapName);
PlayWorldPackage->SetPackageFlags(PKG_PlayInEditor | PKG_NewlyCreated);
PlayWorldPackage->SetPIEInstanceID(WorldContext.PIEInstance);</code></pre>

                <h3>실제 복제 진행</h3>
                <pre><code class="language-cpp">// PIE World 복제해서 생성
NewPIEWorld = UWorld::GetDuplicatedWorldForPIE(InWorld, PlayWorldPackage, WorldContext.PIEInstance);</code></pre>

                <h2>GetDuplicatedWorldForPIE</h2>
                <div class="callout warning">
                    <div class="callout-title">중요한 복제 함수</div>
                    <p>새로운 Object를 만들 때는 <code>NewObject</code>를 사용하지만, 있는 그대로를 복제할 때는 <code>StaticDuplicateObjectEx</code>를 사용합니다.</p>
                </div>
                <pre><code class="language-cpp">// World 복제
UWorld* DuplicatedWorld = CastChecked<UWorld>(StaticDuplicateObjectEx(Parameters));</code></pre>

                <h2>PostCreatePIEWorld - World 필수 구성요소 생성</h2>
                <div class="callout important">
                    <div class="callout-title">중요한 사실</div>
                    <p>World를 그대로 복제하더라도 PhysicsWorld와 RenderWorld까지는 복제하지 않고 <strong>별도로 생성</strong>합니다.</p>
                </div>

                <pre><code class="language-cpp">// InitWorld 호출
NewPIEWorld->InitWorld();

// Physics World 생성
if (IVS.bCreatePhysicsScene)
{
    CreatePhysicsScene(WorldSettings);
}

// Render World 생성
GetRendererModule().AllocateScene(this, bRequiresHitProxies, IVS.bCreateFXSystem, GetFeatureLevel());

// AI Navigation 생성
if (IVS.bCreateNavigation)
{
    FNavigationSystem::AddNavigationSystemToWorld(...);
}</code></pre>

                <h2>복제 과정 흐름도</h2>
                <div class="flow-vertical">
                    <div class="flow-node">InitializeForPlayInEditor</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">World Context 설정</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">CreatePIEWorldByDuplication</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">StaticDuplicateObjectEx로 World 복제</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">PostCreatePIEWorld</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Physics/Render/Navigation 생성</div>
                </div>

                <h2>핵심 포인트</h2>
                <table>
                    <tr><th>구분</th><th>NewObject</th><th>StaticDuplicateObjectEx</th></tr>
                    <tr><td>용도</td><td>새로운 객체 생성</td><td>기존 객체 복제</td></tr>
                    <tr><td>사용 예</td><td>GameInstance, ViewportClient</td><td>Editor World → PIE World</td></tr>
                    <tr><td>특징</td><td>깨끗한 초기 상태</td><td>기존 상태 그대로 복사</td></tr>
                </table>

                <div class="callout warning">
                    <div class="callout-title">주의사항</div>
                    <p>World를 복제해도 다음 요소들은 복제되지 않고 별도로 생성됩니다:</p>
                    <ul>
                        <li>PhysicsWorld</li>
                        <li>RenderWorld</li>
                        <li>AI Navigation System</li>
                    </ul>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec13'] = {
            title: '로컬플레이어 생성',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>로컬플레이어 생성</h1>
                </div>
                <h2>Overview</h2>
                <p>LocalPlayer를 생성하는 과정과 누가 LocalPlayer를 관리하는지 이해합니다.</p>

                <div class="callout">
                    <div class="callout-title">핵심 질문</div>
                    <p>LocalPlayer를 생성하고 관리하는 주체는 누구인가?</p>
                </div>

                <h2>SetupInitialLocalPlayer</h2>
                <h3>1. UEditorEngine::CreateInnerProcessPIEGameInstance</h3>
                <pre><code class="language-cpp">NewLocalPlayer = ViewportClient->SetupInitialLocalPlayer(Error);</code></pre>
                <p>ViewportClient에서 LocalPlayer를 생성하는 것처럼 보입니다.</p>

                <h3>2. UGameViewportClient::SetupInitialLocalPlayer</h3>
                <p>그런데 내부 로직을 보면 GameInstance를 불러오고 거기서 LocalPlayer를 생성합니다!</p>
                <pre><code class="language-cpp">// ViewPort를 통해 WorldContext를 가져오고 WorldContext를 통해 GameInstance를 가져옴
UGameInstance* ViewportGameInstance =
    GEngine->GetWorldContextFromGameViewportChecked(this).OwningGameInstance;

// Local Player 생성 (반드시 필요한 작업)
return ViewportGameInstance->CreateInitialPlayer(OutError);</code></pre>

                <h3>3. UGameInstance::CreateInitialPlayer</h3>
                <div class="callout">
                    <div class="callout-title">왜 이렇게 단계별로 나누어 놓았을까?</div>
                    <ul>
                        <li>LocalPlayer는 게임에서 나를 대변하는 존재</li>
                        <li>일반적인 게임은 LocalPlayer가 하나지만, 간혹 2개 이상인 경우도 존재</li>
                        <li>예: Xbox 축구 게임 - 두 명이서 플레이 (두 개의 LocalPlayer)</li>
                    </ul>
                </div>

                <h4>플랫폼 사용자 ID</h4>
                <pre><code class="language-cpp">ULocalPlayer* UGameInstance::CreateInitialPlayer(FString& OutError)
{
    return CreateLocalPlayer(
        IPlatformInputDeviceMapper::Get().GetPrimaryPlatformUser(),
        OutError,
        false
    );
}</code></pre>
                <p><code>IPlatformInputDeviceMapper::Get().GetPrimaryPlatformUser()</code>: 플랫폼 사용자 ID 발급. InputDevice → 2인용 게임이면 입력 장치도 2개.</p>

                <h2>LocalPlayer 관리</h2>
                <h3>4. UGameInstance::AddLocalPlayer</h3>
                <div class="callout important">
                    <div class="callout-title">중요!</div>
                    <p><strong>LocalPlayer를 생성하고 관리하는 주체는 GameInstance입니다!</strong></p>
                </div>
                <pre><code class="language-cpp">// LocalPlayer 관리 대상이 GameInstance!
const int32 InsertIndex = LocalPlayers.AddUnique(NewLocalPlayer);</code></pre>

                <h4>LocalPlayers 배열 구조</h4>
                <pre><code class="language-cpp">// GameInstance 내부
TArray<ULocalPlayer*> LocalPlayers;</code></pre>
                <p>2인용 게임 등을 고려해 배열로 관리합니다.</p>

                <h2>LocalPlayer::PlayerAdded</h2>
                <pre><code class="language-cpp">// Viewport 설정
ViewportClient = InViewportClient;

// LocalPlayer SubSystem 생성
SubsystemCollection.Initialize(this);</code></pre>

                <h2>생성 흐름도</h2>
                <div class="flow-vertical">
                    <div class="flow-node">ViewportClient::SetupInitialLocalPlayer</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">GameInstance 가져오기</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">GameInstance::CreateInitialPlayer</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">플랫폼 사용자 ID 발급</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">NewObject로 LocalPlayer 생성</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">LocalPlayers 배열에 추가</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">LocalPlayer::PlayerAdded</div>
                </div>

                <h2>LocalPlayer 관계도</h2>
                <table>
                    <tr><th>컴포넌트</th><th>역할</th><th>관계</th></tr>
                    <tr><td>GameInstance</td><td>LocalPlayer 관리자</td><td>LocalPlayers 배열 소유</td></tr>
                    <tr><td>LocalPlayer</td><td>Engine 수준의 플레이어</td><td>GameInstance에 의해 관리</td></tr>
                    <tr><td>ViewportClient</td><td>화면 출력 및 입력</td><td>LocalPlayer가 참조</td></tr>
                    <tr><td>InputDevice</td><td>입력 장치</td><td>LocalPlayer마다 고유 ID</td></tr>
                </table>

                <h2>다중 플레이어 시나리오</h2>
                <h3>1인 게임</h3>
                <div class="hierarchy-box">GameInstance
└── LocalPlayers[0] (Primary Player)
    ├── ViewportClient
    └── InputDevice (ID: 0)</div>

                <h3>2인 게임 (Split Screen)</h3>
                <div class="hierarchy-box">GameInstance
├── LocalPlayers[0] (Player 1)
│   ├── ViewportClient
│   └── InputDevice (ID: 0)
└── LocalPlayers[1] (Player 2)
    ├── ViewportClient
    └── InputDevice (ID: 1)</div>

                <h2>핵심 정리</h2>
                <ol>
                    <li><strong>LocalPlayer를 생성하고 관리하는 주체</strong>: GameInstance</li>
                    <li><strong>관리 방식</strong>: LocalPlayers 배열로 다중 플레이어 지원</li>
                    <li><strong>각 LocalPlayer는 고유한 InputDevice ID를 가짐</strong></li>
                    <li><strong>ViewportClient와 Subsystem을 LocalPlayer 내부에서 설정</strong></li>
                </ol>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec14'] = {
            title: '월드의 게임 초기화',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>월드의 게임 초기화</h1>
                </div>
                <h2>Overview</h2>
                <p>World의 필수 클래스를 생성하는 과정과 그 순서를 이해합니다.</p>

                <div class="callout">
                    <div class="callout-title">핵심 질문</div>
                    <p>어떤 클래스를 어떤 순서로 생성하는가?</p>
                </div>

                <h2>StartPlayInEditorGameInstance</h2>
                <p>CreateInnerProcessPIEGameInstance → StartPlayInEditorGameInstance 호출</p>

                <h2>초기화 4단계</h2>
                <h3>1. GameMode 생성</h3>
                <div class="callout tip">
                    <div class="callout-title">생성 순서</div>
                    <ul>
                        <li><strong>Game 전체</strong>: GameInstance가 가장 먼저 생성</li>
                        <li><strong>GameWorld 내부</strong>: GameMode가 가장 먼저 생성</li>
                    </ul>
                </div>
                <pre><code class="language-cpp">// World에 GameMode 생성
if (!PlayWorld->SetGameMode(URL))
{
    return FGameInstancePIEResult::Failure;
}</code></pre>

                <h3>2. World의 모든 액터 초기화</h3>
                <div class="callout warning">
                    <div class="callout-title">등록 vs 초기화</div>
                    <ul>
                        <li><strong>등록</strong>: 다른 World에 액터의 존재를 알리는 것 (예: RenderWorld, PhysicsWorld에 액터 등록)</li>
                        <li><strong>초기화</strong>: 클래스에 필요한 속성 등록, 필요한 클래스 생성, 사용 준비 완료</li>
                    </ul>
                </div>
                <pre><code class="language-cpp">PlayWorld->InitializeActorsForPlay(URL, true, &Context);</code></pre>

                <h3>3. PlayerController와 Pawn 생성 및 Possess</h3>
                <div class="callout">
                    <div class="callout-title">LocalPlayer vs Pawn</div>
                    <ul>
                        <li><strong>LocalPlayer</strong>: 게임에서 나를 대변 (Engine 수준)</li>
                        <li><strong>Pawn</strong>: 게임 World에서 나를 대변 (World 수준)</li>
                    </ul>
                </div>
                <pre><code class="language-cpp">// PlayerController + Pawn 생성 Possess 진행
if (!LocalPlayer->SpawnPlayActor(URL.ToString(1), Error, PlayWorld))
{
    return FGameInstancePIEResult::Failure;
}</code></pre>

                <h3>4. World의 시작</h3>
                <pre><code class="language-cpp">// 드디어 월드 시작
PlayWorld->BeginPlay();</code></pre>

                <h2>초기화 흐름도</h2>
                <div class="flow-vertical">
                    <div class="flow-node">StartPlayInEditorGameInstance</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">GameMode 생성</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">모든 액터 초기화</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">PlayerController 생성</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Pawn 생성 & Possess</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">World BeginPlay</div>
                </div>

                <h2>등록 vs 초기화 비교</h2>
                <table>
                    <tr><th>구분</th><th>등록 (Register)</th><th>초기화 (Initialize)</th></tr>
                    <tr><td>목적</td><td>다른 시스템에 존재 알림</td><td>사용 가능한 상태로 준비</td></tr>
                    <tr><td>대상</td><td>RenderWorld, PhysicsWorld</td><td>액터 자신의 속성과 컴포넌트</td></tr>
                    <tr><td>시점</td><td>World에 배치될 때</td><td>게임 시작 전</td></tr>
                    <tr><td>작업</td><td>Render 등록, Physics 등록</td><td>속성 설정, 클래스 생성, 준비 완료</td></tr>
                </table>

                <h2>플레이어 관련 개념 정리</h2>
                <h3>Engine 수준 vs World 수준</h3>
                <div class="hierarchy-box">[Engine 수준]
GameInstance
└── LocalPlayer (나를 대변)
    └── ViewportClient
        └── InputDevice

[World 수준]
World
├── GameMode
└── PlayerController (나를 대변)
    └── Pawn (조종 대상)</div>

                <h3>LocalPlayer와 Pawn의 차이</h3>
                <table>
                    <tr><th>구분</th><th>LocalPlayer</th><th>Pawn</th></tr>
                    <tr><td>수준</td><td>Engine 수준</td><td>World 수준</td></tr>
                    <tr><td>역할</td><td>게임 전체에서 나를 대변</td><td>World 내에서 조종 가능한 캐릭터</td></tr>
                    <tr><td>관리자</td><td>GameInstance</td><td>PlayerController</td></tr>
                    <tr><td>생명주기</td><td>게임 전체</td><td>World 내부</td></tr>
                    <tr><td>입력 처리</td><td>입력 수신</td><td>입력 실행</td></tr>
                </table>

                <h2>초기화 순서 요약</h2>
                <div class="callout tip">
                    <div class="callout-title">4단계 초기화</div>
                    <ol>
                        <li><strong>GameMode 생성</strong>: GameWorld의 규칙 관리자</li>
                        <li><strong>모든 액터 초기화</strong>: 속성 설정 및 준비</li>
                        <li><strong>PlayerController + Pawn 생성 및 Possess</strong>: 플레이어 제어 준비</li>
                        <li><strong>World BeginPlay</strong>: 게임 시작</li>
                    </ol>
                </div>

                <h2>핵심 포인트</h2>
                <div class="callout">
                    <div class="callout-title">생성 순서의 중요성</div>
                    <ul>
                        <li>GameMode가 가장 먼저 생성되어 게임 규칙 수립</li>
                        <li>모든 액터가 초기화된 후 플레이어 관련 요소 생성</li>
                        <li>Possess를 통해 PlayerController와 Pawn 연결</li>
                        <li>모든 준비가 끝난 후 BeginPlay 호출</li>
                    </ul>
                </div>

                <div class="callout warning">
                    <div class="callout-title">주의사항</div>
                    <p>각 단계가 실패하면 다음 단계로 진행하지 않고 즉시 실패를 반환합니다.</p>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec15'] = {
            title: '게임모드 생성',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>게임모드 생성</h1>
                </div>
                <h2>Overview</h2>
                <p>GameMode를 생성하는 과정과 설정 우선순위를 이해합니다.</p>

                <div class="callout">
                    <div class="callout-title">핵심 질문</div>
                    <p>GameMode Class는 어디서 가져오며, 우선순위는 어떻게 되는가?</p>
                </div>

                <h2>SetGameMode</h2>
                <p>UGameInstance::StartPlayInEditorGameInstance → UWorld::SetGameMode 호출</p>

                <h2>GameMode 생성 과정</h2>
                <h3>서버 체크 및 생성</h3>
                <div class="callout warning">
                    <div class="callout-title">중요</div>
                    <p>게임모드는 <strong>서버에만 존재</strong>합니다!</p>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">if (!IsNetMode(NM_Client) && !AuthorityGameMode)
{
    // GameMode 생성 및 저장
    AuthorityGameMode = GetGameInstance()->CreateGameModeForURL(InURL, this);

    if (AuthorityGameMode != NULL)
    {
        return true;
    }
}</code></pre>
                </div>

                <h4>조건 확인</h4>
                <ul>
                    <li><code>!IsNetMode(NM_Client)</code>: 클라이언트가 아닌 경우</li>
                    <li><code>!AuthorityGameMode</code>: 아직 GameMode가 생성되지 않은 경우</li>
                </ul>

                <h2>GameMode Class 로딩 우선순위</h2>
                <div class="callout tip">
                    <div class="callout-title">우선순위</div>
                    <ol>
                        <li><strong>World Setting</strong> (높음)</li>
                        <li><strong>Project Setting - Game Maps Settings</strong> (중간)</li>
                        <li><strong>AGameModeBase::StaticClass()</strong> (기본값)</li>
                    </ol>
                </div>

                <h3>1순위: World Setting에서 가져오기</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">AWorldSettings* Settings = World->GetWorldSettings();

// WorldSetting에 설정되어 있는 GameModeClass 가져옴
TSubclassOf<AGameModeBase> GameClass = Settings->DefaultGameMode;</code></pre>
                </div>
                <div class="callout">
                    <div class="callout-title">World Settings란?</div>
                    <ul>
                        <li>각 레벨(맵)마다 개별적으로 설정 가능</li>
                        <li>특정 맵에만 특별한 GameMode를 적용할 때 사용</li>
                        <li>가장 높은 우선순위를 가짐</li>
                    </ul>
                </div>

                <h3>2순위: Project Setting에서 가져오기</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// WorldSetting에 없으면 Project Setting에 설정되어있는 GameModeClass 가져옴
if (!GameClass)
{
    GameClass = LoadClass<AGameModeBase>(nullptr, *UGameMapsSettings::GetGlobalDefaultGameMode());
}</code></pre>
                </div>

                <h3>3순위: 기본 클래스 사용</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// 둘 다 설정되어 있지 않으면 기본 클래스 사용
if (!GameClass)
{
    GameClass = AGameModeBase::StaticClass();
}</code></pre>
                </div>

                <h2>GameMode 생성</h2>
                <h3>SpawnActor 사용</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// World에 생성하게 되므로 NewObject가 아니라 SpawnActor를 실행
AGameModeBase* GameMode = World->SpawnActor<AGameModeBase>(GameClass, SpawnInfo);</code></pre>
                </div>
                <div class="callout warning">
                    <div class="callout-title">NewObject vs SpawnActor</div>
                    <ul>
                        <li><strong>NewObject</strong>: 일반 UObject 생성 (GameInstance, ViewportClient 등)</li>
                        <li><strong>SpawnActor</strong>: World에 배치되는 Actor 생성 (GameMode, Pawn 등)</li>
                    </ul>
                </div>

                <h2>생성 흐름도</h2>
                <div class="flow-vertical">
                    <div class="flow-node">SetGameMode</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">서버인가?</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">CreateGameModeForURL</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">1순위: World Settings</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">2순위: Project Settings</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">3순위: AGameModeBase</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">SpawnActor</div>
                </div>

                <h2>설정 우선순위 비교표</h2>
                <table>
                    <tr><th>우선순위</th><th>설정 위치</th><th>범위</th><th>용도</th><th>예시</th></tr>
                    <tr><td><strong>1순위</strong></td><td>World Settings</td><td>레벨별</td><td>특정 맵 전용</td><td>보스전 맵 전용 GameMode</td></tr>
                    <tr><td><strong>2순위</strong></td><td>Project Settings</td><td>프로젝트 전체</td><td>기본 GameMode</td><td>일반 플레이 GameMode</td></tr>
                    <tr><td><strong>3순위</strong></td><td>AGameModeBase</td><td>엔진 기본</td><td>폴백(Fallback)</td><td>설정 없을 때 사용</td></tr>
                </table>

                <h2>실제 사용 예시</h2>
                <h3>시나리오 1: 일반 플레이 맵</h3>
                <div class="hierarchy-box">World Settings: None
Project Settings: AMyGameMode
→ 결과: AMyGameMode 사용</div>

                <h3>시나리오 2: 특별한 보스전 맵</h3>
                <div class="hierarchy-box">World Settings: ABossGameMode
Project Settings: AMyGameMode
→ 결과: ABossGameMode 사용 (World Settings 우선)</div>

                <h3>시나리오 3: 설정이 전혀 없는 경우</h3>
                <div class="hierarchy-box">World Settings: None
Project Settings: None
→ 결과: AGameModeBase 사용 (기본값)</div>

                <h2>핵심 포인트</h2>
                <div class="callout tip">
                    <div class="callout-title">우선순위 기억하기</div>
                    <p><strong>World Setting > Project Setting > AGameModeBase</strong></p>
                </div>

                <div class="callout">
                    <div class="callout-title">설계 철학</div>
                    <ul>
                        <li>레벨별 커스터마이징 지원 (World Settings)</li>
                        <li>프로젝트 전체 일관성 유지 (Project Settings)</li>
                        <li>안전한 폴백 메커니즘 (AGameModeBase)</li>
                    </ul>
                </div>

                <div class="callout warning">
                    <div class="callout-title">주의사항</div>
                    <ul>
                        <li>GameMode는 서버에만 존재</li>
                        <li>클라이언트는 GameState를 통해 정보 확인</li>
                        <li>SpawnActor로 생성되므로 World에 배치됨</li>
                    </ul>
                </div>

                <h2>Summary</h2>
                <ul>
                    <li><strong>GameMode 설정 우선순위</strong>: World Setting > Project Setting > 기본 클래스</li>
                    <li><strong>생성 방식</strong>: SpawnActor 사용 (World에 배치)</li>
                    <li><strong>생성 조건</strong>: 서버에만 생성</li>
                    <li><strong>폴백 메커니즘</strong>: 설정 없으면 AGameModeBase 사용</li>
                </ul>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec16'] = {
            title: '월드 액터 초기화',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>월드 액터 초기화</h1>
                </div>
                <h2>Overview</h2>
                <p>World의 모든 액터를 초기화하는 과정과 그 전후 작업을 이해합니다.</p>

                <div class="callout">
                    <div class="callout-title">핵심 질문</div>
                    <p>초기화 전과 후에 어떤 작업이 진행되는지 주목하기</p>
                </div>

                <h2>InitializeActorsForPlay</h2>
                <p>UGameInstance::StartPlayInEditorGameInstance → UWorld::InitializeActorsForPlay</p>

                <h2>초기화 과정</h2>
                <h3>1. bActorsInitialized 플래그 설정</h3>
                <div class="callout warning">
                    <div class="callout-title">매우 중요한 변수!</div>
                    <p>이 변수가 true여야만 초기화 과정이 진행 가능합니다.</p>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">bActorsInitialized = true;</code></pre>
                </div>

                <h4>플래그의 중요성</h4>
                <ul>
                    <li>이 변수가 <code>true</code>여야 초기화 진행 가능</li>
                    <li>모든 액터의 초기화는 이 메서드 실행 후 가능</li>
                    <li><code>false</code>인 경우 SpawnActor 내부의 초기화 로직 모두 차단</li>
                </ul>

                <h3>2. GameMode::InitGame 호출</h3>
                <div class="callout">
                    <div class="callout-title">호출 시점</div>
                    <p>게임 시작 후 Actor가 등록되자마자 <strong>매우 빠른 시점</strong>에 호출됩니다.</p>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// 게임을 초기화하는 단계로 PreInitializeComponents() 보다 먼저 호출
AuthorityGameMode->InitGame(FPaths::GetBaseFilename(InURL.Map), Options, Error);</code></pre>
                </div>
                <p><strong>특징:</strong> PreInitializeComponents() 보다 먼저 호출, GameMode 수준의 게임 설정 초기화</p>

                <h3>3. ULevel::RouteActorInitialize</h3>
                <p>Level에 있는 모든 Actor의 초기화를 진행합니다.</p>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">Level->RouteActorInitialize(ProcessAllRouteActorInitializationGranularity);</code></pre>
                </div>

                <h2>SortActorList - 최적화 기법</h2>
                <h3>4. 액터 정렬</h3>
                <div class="callout tip">
                    <div class="callout-title">훌륭한 최적화 컨셉!</div>
                    <p>네트워크와 연관성이 있는 액터와 없는 액터를 분리하여 정렬합니다.</p>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// 네트워크에 관련있는 액터와 없는 액터를 구분하여 정렬
// 네트워크와 관련이 없는 액터는 앞에 정렬, 네트워크와 관련 있는 액터는 뒤에 정렬
// 특정 유형의 액터 반복자의 성능을 높이기 위한 방식
for(int32 LevelIndex = 0; LevelIndex < Levels.Num(); LevelIndex++)
{
    ULevel* Level = Levels[LevelIndex];
    Level->SortActorList();
}</code></pre>
                </div>

                <h3>최적화 알고리즘</h3>
                <div class="flow-vertical">
                    <div class="flow-node">기존 Actors 배열</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">WorldSettings 분리</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">나머지 액터들 순회</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">네트워크 액터 분류</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">최종 배열 구성</div>
                </div>

                <h4>정렬 과정 상세</h4>
                <div class="hierarchy-box">[초기 상태]
Actors[] = [WorldSettings, Actor1, NetActor1, Actor2, NetActor2, ...]

[1단계: WorldSettings 분리]
WorldSettings
Actors[] = [Actor1, NetActor1, Actor2, NetActor2, ...]

[2단계: 분류]
NewActors[] = [Actor1, Actor2, ...]          // 일반 액터
NewNetActors[] = [NetActor1, NetActor2, ...] // 네트워크 액터

[3단계: 최종 구성]
NewActors[] = [WorldSettings, Actor1, Actor2, ..., NetActor1, NetActor2, ...]</div>

                <h3>최적화 효과</h3>
                <div class="callout tip">
                    <div class="callout-title">성능 향상</div>
                    <p>이 과정을 통해 네트워크가 필요한 액터들만 for문을 순회하는 것이 가능해집니다.</p>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// 네트워크 액터만 순회 (최적화됨)
for (int32 i = iFirstNetRelevantActor; i < Actors.Num(); i++)
{
    AActor* Actor = Actors[i];
    // 네트워크 처리...
}</code></pre>
                </div>

                <h2>후처리 단계</h2>
                <h3>5. Actor Initialize Broadcast</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// Actor의 모든 Init가 끝났으니 BroadCast
OnActorsInitialized.Broadcast(OnActorInitParams);
FWorldDelegates::OnWorldInitializedActors.Broadcast(OnActorInitParams);</code></pre>
                </div>

                <h3>6. AI System 초기화</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">if (NavigationSystem != nullptr)
{
    NavigationSystem->OnInitializeActors();
}

if (AISystem != nullptr)
{
    AISystem->InitializeActorsForPlay(bResetTime);
}</code></pre>
                </div>

                <h2>초기화 단계 요약</h2>
                <table>
                    <tr><th>단계</th><th>작업</th><th>목적</th></tr>
                    <tr><td>1</td><td>bActorsInitialized = true</td><td>초기화 가능 상태로 전환</td></tr>
                    <tr><td>2</td><td>GameMode::InitGame</td><td>게임 수준 초기화</td></tr>
                    <tr><td>3</td><td>Level::RouteActorInitialize</td><td>모든 액터 초기화</td></tr>
                    <tr><td>4</td><td>Level::SortActorList</td><td>네트워크 액터 정렬 (최적화)</td></tr>
                    <tr><td>5</td><td>OnActorsInitialized Broadcast</td><td>초기화 완료 알림</td></tr>
                    <tr><td>6</td><td>AI/Navigation 초기화</td><td>부가 시스템 초기화</td></tr>
                </table>

                <h2>핵심 포인트</h2>
                <div class="callout warning">
                    <div class="callout-title">bActorsInitialized의 중요성</div>
                    <ul>
                        <li>이 변수가 false면 SpawnActor에서 초기화 로직 모두 차단</li>
                        <li>World의 초기화 준비 상태를 나타내는 핵심 플래그</li>
                        <li>모든 액터 초기화의 전제조건</li>
                    </ul>
                </div>

                <div class="callout tip">
                    <div class="callout-title">SortActorList 최적화</div>
                    <ul>
                        <li>네트워크 액터와 일반 액터를 분리</li>
                        <li>네트워크 처리 시 불필요한 액터 순회 방지</li>
                        <li>성능 향상을 위한 훌륭한 설계</li>
                    </ul>
                </div>

                <h2>Summary</h2>
                <ul>
                    <li><strong>bActorsInitialized 변수</strong>: 매우 중요, true여야 초기화 가능</li>
                    <li><strong>GameMode::InitGame</strong>: PreInitializeComponents보다 먼저 호출</li>
                    <li><strong>Level::RouteActorInitialize</strong>: 모든 액터 초기화</li>
                    <li><strong>Level::SortActorList</strong>: 네트워크 액터 정렬 - 훌륭한 최적화 컨셉!</li>
                </ul>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec17'] = {
            title: '월드 액터 초기화 과정',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>월드 액터 초기화 과정</h1>
                </div>
                <h2>Overview</h2>
                <p>월드의 모든 액터를 초기화하는 RouteActorInitialize 함수의 동작 방식을 이해합니다.</p>

                <div class="callout">
                    <div class="callout-title">핵심 질문</div>
                    <p>어떻게 액터를 초기화하는가?</p>
                </div>

                <h2>RouteActorInitialize</h2>
                <p>UGameInstance::StartPlayInEditorGameInstance → UWorld::InitializeActorsForPlay → ULevel::RouteActorInitialize</p>

                <h2>초기화 파라미터</h2>
                <h3>처리 단위 설정</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">const int32 ProcessAllRouteActorInitializationGranularity = 0;
for (int32 LevelIndex = 0; LevelIndex < Levels.Num(); LevelIndex++)
{
    ULevel* const Level = Levels[LevelIndex];
    Level->RouteActorInitialize(ProcessAllRouteActorInitializationGranularity);
}</code></pre>
                </div>
                <div class="callout tip">
                    <div class="callout-title">Granularity = 0의 의미</div>
                    <ul>
                        <li>액터 등록 때와 마찬가지로 '나누어서 처리' 가능</li>
                        <li>0이 들어가면 한 번에 모든 액터를 처리</li>
                    </ul>
                </div>

                <h2>ULevel::RouteActorInitialize</h2>
                <h3>전체 처리 여부 결정</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">const bool bFullProcessing = (NumActorsToProcess <= 0);</code></pre>
                </div>
                <ul>
                    <li><code>NumActorsToProcess <= 0</code>: 모든 액터 처리</li>
                    <li><code>NumActorsToProcess > 0</code>: 지정된 수만큼만 처리</li>
                </ul>

                <h2>액터 초기화 3단계</h2>
                <h3>1. ERouteActorInitializationState::Preinitialize</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">case ERouteActorInitializationState::Preinitialize:
{
    Actor->PreInitializeComponents();

    ++RouteActorInitializationIndex;
    if (!bFullProcessing && (--NumActorsToProcess == 0))
    {
        return;
    }
    break;
}</code></pre>
                </div>
                <p><strong>역할:</strong> 컴포넌트 초기화 전 준비 작업, 필요한 리소스 로딩, 초기 설정 수행</p>

                <h3>2. ERouteActorInitializationState::Initialize</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">case ERouteActorInitializationState::Initialize:
{
    Actor->InitializeComponents();
    Actor->PostInitializeComponents();

    ++RouteActorInitializationIndex;
    if (!bFullProcessing && (--NumActorsToProcess == 0))
    {
        return;
    }
    break;
}</code></pre>
                </div>
                <p><strong>역할:</strong> 컴포넌트 초기화, 초기화 후처리</p>

                <h3>3. BeginPlay 조건부 실행</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">case ERouteActorInitializationState::BeginPlay:
{
    if (OwningWorld->HasBegunPlay())
    {
        Actor->DispatchBeginPlay(bFromLevelStreaming);
    }

    ++RouteActorInitializationIndex;
    if (!bFullProcessing && (--NumActorsToProcess == 0))
    {
        return;
    }
    break;
}</code></pre>
                </div>
                <p><strong>조건:</strong> Owning World가 BeginPlay된 상태라면 실행, Level Streaming 고려</p>

                <h2>처리 제어 로직</h2>
                <h3>공통 조건문 분석</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">++RouteActorInitializationIndex;
if (!bFullProcessing && (--NumActorsToProcess == 0))
{
    return;
}</code></pre>
                </div>

                <h4>시나리오 1: NumActorsToProcess = 0</h4>
                <div class="hierarchy-box">bFullProcessing = true
→ 조건문에서 return 하지 않음
→ 모든 액터를 한번에 초기화</div>

                <h4>시나리오 2: NumActorsToProcess > 0</h4>
                <div class="hierarchy-box">bFullProcessing = false
→ 지정된 개수만큼 차감
→ 0이 되면 return
→ 다음 틱에서 이어서 처리</div>

                <h2>GameMode 초기화 예시</h2>
                <h3>PreInitializeComponents에서 GameState 생성</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// GameState 생성
UWorld* World = GetWorld();
GameState = World->SpawnActor<AGameStateBase>(GameStateClass, SpawnInfo);
World->SetGameState(GameState);
if (GameState)
{
    GameState->AuthorityGameMode = this;
}</code></pre>
                </div>
                <div class="callout">
                    <div class="callout-title">초기화 과정의 의미</div>
                    <p>자신에게 필요한 정보를 설정하고 필요한 클래스를 생성합니다.</p>
                </div>

                <h2>초기화 단계별 비교</h2>
                <table>
                    <tr><th>단계</th><th>함수</th><th>역할</th><th>예시</th></tr>
                    <tr><td><strong>1단계</strong></td><td>PreInitializeComponents</td><td>컴포넌트 초기화 전 준비</td><td>GameMode: GameState 생성</td></tr>
                    <tr><td><strong>2단계</strong></td><td>InitializeComponents</td><td>컴포넌트 초기화</td><td>각 컴포넌트 설정</td></tr>
                    <tr><td><strong>2.5단계</strong></td><td>PostInitializeComponents</td><td>초기화 후처리</td><td>컴포넌트 간 연결</td></tr>
                    <tr><td><strong>3단계</strong></td><td>BeginPlay</td><td>게임 플레이 시작</td><td>게임 로직 시작</td></tr>
                </table>

                <h2>초기화 흐름도</h2>
                <div class="flow-vertical">
                    <div class="flow-node">RouteActorInitialize</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">bFullProcessing 확인</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Preinitialize</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Initialize + PostInitialize</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">BeginPlay (조건부)</div>
                </div>

                <h2>핵심 포인트</h2>
                <div class="callout tip">
                    <div class="callout-title">3단계 초기화</div>
                    <ol>
                        <li><strong>PreInitializeComponents</strong>: 필요한 클래스 생성</li>
                        <li><strong>InitializeComponents + PostInitializeComponents</strong>: 컴포넌트 설정</li>
                        <li><strong>BeginPlay</strong>: 게임 로직 시작 (조건부)</li>
                    </ol>
                </div>

                <div class="callout">
                    <div class="callout-title">분할 처리</div>
                    <ul>
                        <li>Granularity 파라미터로 처리 단위 조절</li>
                        <li>0: 모든 액터 한번에 처리</li>
                        <li>N: N개씩 나누어 처리 (다음 틱에서 이어서)</li>
                    </ul>
                </div>

                <h2>Summary</h2>
                <ul>
                    <li><strong>액터 초기화 함수</strong>: RouteActorInitialize</li>
                    <li><strong>3단계 초기화</strong>: PreInitializeComponents (준비) → InitializeComponents + PostInitializeComponents (설정) → BeginPlay (시작)</li>
                    <li><strong>GameMode 예시</strong>: PreInitialize 단계에서 GameState 생성</li>
                    <li><strong>분할 처리</strong>: Granularity 파라미터로 조절 가능</li>
                </ul>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec18'] = {
            title: '플레이어 구성 요소 생성',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>플레이어 구성 요소 생성</h1>
                </div>
                <h2>Overview</h2>
                <p>플레이어의 구성 요소(PlayerController, Pawn 등)를 생성하는 과정을 이해합니다.</p>

                <div class="callout">
                    <div class="callout-title">핵심 질문</div>
                    <ul>
                        <li>어떤 구성요소가 생성되는가?</li>
                        <li>Spawn 주체는 누구인가?</li>
                    </ul>
                </div>

                <h2>SpawnPlayActor 호출 체인</h2>
                <p>CreateInnerProcessPIEGameInstance → StartPlayInEditorGameInstance</p>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">if (LocalPlayer)
{
    FString Error;
    // PlayerController + Pawn 생성 Possess 진행
    if (!LocalPlayer->SpawnPlayActor(URL.ToString(1), Error, PlayWorld))
    {
        return FGameInstancePIEResult::Failure;
    }
}</code></pre>
                </div>

                <h2>플레이어 생성 3단계</h2>
                <h3>1. ULocalPlayer::SpawnPlayActor</h3>
                <p>World의 SpawnPlayActor를 호출합니다.</p>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">PlayerController = InWorld->SpawnPlayActor(
    this,                                            // LocalPlayer
    ROLE_SimulatedProxy,                             // RemoteRole
    PlayerURL,                                       // URL
    UniqueId,                                        // Player ID
    OutError,                                        // Error
    GEngine->GetGamePlayers(InWorld).Find(this)      // Player Index
);</code></pre>
                </div>
                <div class="callout">
                    <div class="callout-title">왜 LocalPlayer를 거쳐서 호출하는가?</div>
                    <p>Actor의 관리 주체는 World이지만, LocalPlayer의 고유 ID가 필요하기 때문입니다.</p>
                </div>

                <h4>Player Index의 중요성</h4>
                <ul>
                    <li><strong>마지막 인자</strong>: <code>GEngine->GetGamePlayers(InWorld).Find(this)</code></li>
                    <li><strong>역할</strong>: Player의 고유 ID</li>
                    <li><strong>용도</strong>: <code>GetPlayerController(Index)</code> 할 때 사용하는 바로 그 Index</li>
                </ul>

                <h3>2. UWorld::SpawnPlayActor - PlayerController 생성</h3>
                <p>GameMode의 Login 함수를 통해 PlayerController를 생성합니다.</p>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">if (AGameModeBase* const GameMode = GetAuthGameMode())
{
    // 언리얼은 데디케이트를 중심으로 만들어진 프레임워크라서
    // 유저가 접속할 때마다 PlayerController를 생성
    APlayerController* const NewPlayerController = GameMode->Login(
        NewPlayer,
        RemoteRole,
        *InURL.Portal,
        Options,
        UniqueId,
        Error
    );

    if (NewPlayerController == NULL)
    {
        return nullptr;
    }
}</code></pre>
                </div>
                <div class="callout">
                    <div class="callout-title">Login 함수명의 의미</div>
                    <p>네트워크 관점에서 보면:</p>
                    <ul>
                        <li>PlayerController가 생성되는 시점 = 새로운 유저가 Login하는 상황</li>
                        <li>게임 전반의 상태를 관리하는 것 = GameMode</li>
                    </ul>
                </div>

                <h4>PostInitializeComponents에서 추가 생성</h4>
                <p>PlayerController의 PostInitializeComponents에서:</p>
                <ul>
                    <li>PlayerState 생성</li>
                    <li>CameraManager 생성</li>
                </ul>

                <h3>3. PlayerController와 LocalPlayer 연결</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// Player를 PlayerController에 연결 + PlayerInput 생성
// NewPlayer는 UPlayer*
NewPlayerController->SetPlayer(NewPlayer);</code></pre>
                </div>
                <p><strong>생성되는 것:</strong> PlayerInput (입력 처리 객체)</p>

                <h3>4. Pawn 생성 및 Possess</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// Pawn 생성과 Possess 진행
GameMode->PostLogin(NewPlayerController);</code></pre>
                </div>
                <p><strong>작업 내용:</strong> Pawn 생성, PlayerController가 Pawn을 Possess</p>

                <h2>생성 흐름도</h2>
                <div class="flow-vertical">
                    <div class="flow-node">LocalPlayer::SpawnPlayActor</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Player Index 계산</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">World::SpawnPlayActor</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">GameMode::Login</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">PlayerController 생성</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">PostInitializeComponents</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">SetPlayer</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">PostLogin (Pawn + Possess)</div>
                </div>

                <h2>플레이어 구성 요소</h2>
                <h3>생성 순서와 역할</h3>
                <table>
                    <tr><th>순서</th><th>구성 요소</th><th>생성 위치</th><th>역할</th></tr>
                    <tr><td>1</td><td><strong>PlayerController</strong></td><td>GameMode::Login</td><td>World 내에서 플레이어 대변</td></tr>
                    <tr><td>2</td><td><strong>PlayerState</strong></td><td>PlayerController::PostInitializeComponents</td><td>PlayerController 정보 복제</td></tr>
                    <tr><td>3</td><td><strong>CameraManager</strong></td><td>PlayerController::PostInitializeComponents</td><td>카메라 관리</td></tr>
                    <tr><td>4</td><td><strong>PlayerInput</strong></td><td>PlayerController::SetPlayer</td><td>입력 처리</td></tr>
                    <tr><td>5</td><td><strong>Pawn</strong></td><td>GameMode::PostLogin</td><td>조종 가능한 캐릭터</td></tr>
                </table>

                <h2>플레이어 구조</h2>
                <h3>Engine 수준과 World 수준</h3>
                <div class="hierarchy-box">[Engine 수준]
LocalPlayer (GameInstance 관리)
├── ViewportClient
├── InputDevice (ID)
└── PlayerController에 연결 ──┐
                              │
[World 수준]                   │
PlayerController <─────────────┘
├── PlayerState (네트워크 복제)
├── CameraManager
├── PlayerInput
└── Pawn (Possess)
    └── 실제 조종하는 캐릭터</div>

                <h2>핵심 포인트</h2>
                <div class="callout tip">
                    <div class="callout-title">생성 순서</div>
                    <ol>
                        <li><strong>GameMode::Login</strong> → PlayerController 생성</li>
                        <li><strong>PostInitializeComponents</strong> → PlayerState + CameraManager 생성</li>
                        <li><strong>SetPlayer</strong> → LocalPlayer 연결 + PlayerInput 생성</li>
                        <li><strong>PostLogin</strong> → Pawn 생성 + Possess</li>
                    </ol>
                </div>

                <div class="callout">
                    <div class="callout-title">네트워크 중심 설계</div>
                    <ul>
                        <li>Login 함수: 새로운 플레이어 접속 개념</li>
                        <li>PlayerController: 유저마다 생성</li>
                        <li>데디케이티드 서버 중심 프레임워크</li>
                    </ul>
                </div>

                <div class="callout">
                    <div class="callout-title">LocalPlayer와 PlayerController</div>
                    <ul>
                        <li><strong>LocalPlayer</strong>: Engine 수준, GameInstance 관리</li>
                        <li><strong>PlayerController</strong>: World 수준, GameMode가 생성</li>
                        <li>둘을 연결하는 것이 Player Index</li>
                    </ul>
                </div>

                <h2>Summary</h2>
                <ul>
                    <li><strong>GameMode::Login</strong> → PlayerController 생성 (PostInit 과정에서 PlayerState와 CameraManager도 생성)</li>
                    <li><strong>PlayerController::SetPlayer</strong> → LocalPlayer와 연결 (PlayerInput도 이때 생성)</li>
                    <li><strong>GameMode::PostLogin</strong> → Pawn 생성 및 Possess</li>
                </ul>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec19'] = {
            title: '플레이어 컨트롤러 생성',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>플레이어 컨트롤러 생성</h1>
                </div>
                <h2>Overview</h2>
                <p>Login 과정에서 PlayerController를 생성하는 방법을 분석합니다.</p>

                <div class="callout">
                    <div class="callout-title">핵심 질문</div>
                    <ul>
                        <li>어떤 방식으로 PlayerController를 생성하는가?</li>
                        <li>어떤 방식으로 입장 처리를 진행하는가?</li>
                    </ul>
                </div>

                <h2>PlayerController 생성 과정</h2>
                <h3>두 가지 단계</h3>
                <div class="flow-diagram">
                    <div class="flow-node">SpawnPlayerController</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">생성</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">InitNewPlayer</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">초기화 및 검증</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">PlayerController 완성</div>
                </div>

                <h2>코드 분석</h2>
                <h3>PlayerController 생성 및 초기화</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// PlayerController + PlayerState + PlayerCameraManager 생성
APlayerController* const NewPlayerController = SpawnPlayerController(InRemoteRole, Options);
if (NewPlayerController == nullptr)
{
    ErrorMessage = FString::Printf(TEXT("Failed to spawn player controller"));
    return nullptr;
}

// 새로운 컨트롤러에 대한 초기화 로직을 구현할 수 있도록 제공하는 함수
ErrorMessage = InitNewPlayer(NewPlayerController, UniqueId, Options, Portal);</code></pre>
                </div>

                <h2>1단계: PlayerController 생성</h2>
                <h3>SpawnPlayerController</h3>
                <div class="callout">
                    <div class="callout-title">내부 구현</div>
                    <p>내부적으로 SpawnPlayerControllerCommon만 호출합니다. 앞으로 SpawnPlayerController는 없어지고 SpawnPlayerControllerCommon만 남을 예정입니다.</p>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">return SpawnPlayerControllerCommon(InRemoteRole, FVector::ZeroVector, FRotator::ZeroRotator, PlayerControllerClass);</code></pre>
                </div>

                <h3>SpawnPlayerControllerCommon</h3>
                <p>PlayerController 생성만 하는 것처럼 보이지만, 중요한 건 PostInitializeComponents를 봐야 합니다.</p>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// PlayerController 생성
APlayerController* NewPC = GetWorld()->SpawnActor<APlayerController>(
    InPlayerControllerClass,
    SpawnLocation,
    SpawnRotation,
    SpawnInfo
);</code></pre>
                </div>

                <h2>PostInitializeComponents: 추가 생성 과정</h2>
                <p>PlayerState와 CameraManager를 생성합니다.</p>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">if (IsValid(this) && (GetNetMode() != NM_Client))
{
    // PlayerState 생성
    InitPlayerState();
}

// PlayerCameraManager 생성
SpawnPlayerCameraManager();

//CheatManager 생성</code></pre>
                </div>

                <h2>PlayerState 생성</h2>
                <h3>InitPlayerState</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// GameMode를 통해서 PlayerState의 Class를 가져옴
TSubclassOf<APlayerState> PlayerStateClassToSpawn = GameMode->PlayerStateClass;

if (PlayerStateClassToSpawn.Get() == nullptr)
{
    PlayerStateClassToSpawn = APlayerState::StaticClass();
}

// PlayerState 생성과 동시에 저장까지 진행
SetPlayerState(World->SpawnActor<APlayerState>(PlayerStateClassToSpawn, SpawnInfo));</code></pre>
                </div>

                <h3>SetPlayerState</h3>
                <p>변수에 대입이 전부입니다.</p>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">PlayerState = InPlayerState;</code></pre>
                </div>

                <h2>PlayerCameraManager 생성</h2>
                <h3>SpawnPlayerCameraManager</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// PlayerCameraManagerClass Override에 맞게 생성
if (PlayerCameraManagerClass != NULL)
{
    PlayerCameraManager = GetWorld()->SpawnActor<APlayerCameraManager>(PlayerCameraManagerClass, SpawnInfo);
}
else
{
    PlayerCameraManager = GetWorld()->SpawnActor<APlayerCameraManager>(SpawnInfo);
}

// 플레이어 컨트롤러를 이용해 PlayerCameraManager를 초기화 + 플레이어 컨트롤러 저장
if (PlayerCameraManager != NULL)
{
    PlayerCameraManager->InitializeFor(this);
}</code></pre>
                </div>
                <div class="callout tip">
                    <div class="callout-title">Custom 설정</div>
                    <ul>
                        <li>PlayerController 내부에 CameraManager class 설정 가능</li>
                        <li>내부에 세팅된 값이 있으면 해당 값 사용</li>
                        <li>없으면 일반 APlayerCameraManager 스폰</li>
                    </ul>
                </div>

                <h2>2단계: 초기화 및 검증</h2>
                <h3>InitNewPlayer</h3>
                <div class="callout">
                    <div class="callout-title">왜 별도의 초기화 과정이 필요한가?</div>
                    <ol>
                        <li><strong>안정적인 초기화 시점 보장</strong>: SpawnPlayerController 과정을 거치고 호출되기 때문에 Player와 관련된 핵심 주체가 확실히 존재함을 보장</li>
                        <li><strong>최종 Player 검증, 접속 과정 처리</strong>: 접속 과정에서 player를 검증 후 에러 메시지를 받을 수 있음. 에러 메시지를 받으면 PlayerController를 파괴하고 퇴장 처리</li>
                    </ol>
                </div>

                <h3>검증 및 에러 처리</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// 새로운 컨트롤러에 대한 초기화 로직을 구현할 수 있도록 제공하는 함수
ErrorMessage = InitNewPlayer(NewPlayerController, UniqueId, Options, Portal);

// ErrorMessage에 어떠한 값이라도 있으면 Controller 파괴 + 실패 처리
if (!ErrorMessage.IsEmpty())
{
    NewPlayerController->Destroy();
    return nullptr;
}

return NewPlayerController;</code></pre>
                </div>

                <h2>생성 프로세스 요약</h2>
                <div class="flow-vertical">
                    <div class="flow-node">SpawnPlayerController</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">SpawnPlayerControllerCommon</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">PlayerController 생성</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">PostInitializeComponents</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">PlayerState + CameraManager 생성</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">InitNewPlayer (검증)</div>
                </div>

                <h2>Summary</h2>
                <h3>두 가지 단계</h3>
                <div class="callout tip">
                    <div class="callout-title">1단계: Spawn</div>
                    <ul>
                        <li><strong>PlayerController 생성</strong></li>
                        <li>해당 생성 과정에서 <strong>PlayerState, CameraManager 생성</strong></li>
                    </ul>
                </div>

                <div class="callout tip">
                    <div class="callout-title">2단계: 초기화</div>
                    <ul>
                        <li><strong>초기화와 PlayerController의 입장을 검증하는 단계</strong></li>
                        <li>커스텀 검증 로직 구현 가능</li>
                    </ul>
                </div>

                <h3>핵심 포인트</h3>
                <table>
                    <tr><th>단계</th><th>생성 객체</th><th>설명</th></tr>
                    <tr><td>1단계</td><td>PlayerController</td><td>SpawnPlayerControllerCommon 통해 생성</td></tr>
                    <tr><td></td><td>PlayerState</td><td>InitPlayerState 통해 생성</td></tr>
                    <tr><td></td><td>PlayerCameraManager</td><td>SpawnPlayerCameraManager 통해 생성</td></tr>
                    <tr><td>2단계</td><td>-</td><td>InitNewPlayer로 검증 및 초기화</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec20'] = {
            title: '플레이어 입력 시스템',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>플레이어 입력 시스템</h1>
                </div>
                <h2>개념 설명</h2>
                <h3>핵심 구성 요소</h3>
                <table>
                    <tr><th>컴포넌트</th><th>위치</th><th>역할</th></tr>
                    <tr><td><strong>UPlayerInput</strong></td><td>PlayerController</td><td>Input Stack을 차곡차곡 쌓아두는 곳</td></tr>
                    <tr><td><strong>UInputComponent</strong></td><td>Actor</td><td>입력을 받아 게임 내의 행동을 수행하도록 연결하는 Component</td></tr>
                </table>

                <div class="callout">
                    <div class="callout-title">UPlayerInput</div>
                    <ul>
                        <li><strong>위치</strong>: PlayerController에 존재</li>
                        <li><strong>역할</strong>: Input Stack을 차곡차곡 쌓아두는 곳</li>
                    </ul>
                </div>

                <div class="callout">
                    <div class="callout-title">UInputComponent</div>
                    <ul>
                        <li><strong>위치</strong>: Actor에 존재</li>
                        <li><strong>역할</strong>: UPlayerInput에서 입력을 받아 게임 내의 행동을 수행하도록 연결</li>
                        <li><strong>기능</strong>: BindAction 함수를 제공하여 입력과 메서드를 binding</li>
                    </ul>
                </div>

                <h2>입력 처리 프로세스</h2>
                <h3>입력 처리의 시작점</h3>
                <div class="callout">
                    <div class="callout-title">APlayerController::TickActor</div>
                    <ul>
                        <li>입력 처리는 PlayerController의 Tick에서 진행됩니다.</li>
                        <li><strong>Input 처리가 일반 Tick 함수 처리보다 빠르게 진행됩니다.</strong></li>
                    </ul>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// Input 전용 Tick
if (PlayerInput)
{
    TickPlayerInput(DeltaSeconds, true);
}

// 일반 Tick
if (IsValid(this))
{
    Tick(DeltaSeconds);
}</code></pre>
                </div>

                <h2>1단계: 입력 처리 시작</h2>
                <h3>TickPlayerInput</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">PlayerInput->Tick(DeltaSeconds);

// 본격적인 입력 처리 시작
ProcessPlayerInput(DeltaSeconds, bGamePaused);</code></pre>
                </div>

                <h3>ProcessPlayerInput</h3>
                <p>InputStack에 입력받은 Input을 저장합니다.</p>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">static TArray<UInputComponent*> InputStack;

// PlayerController를 통해 InputComponent 저장
BuildInputStack(InputStack);</code></pre>
                </div>

                <h3>BuildInputStack</h3>
                <div class="callout tip">
                    <div class="callout-title">InputStack 구성</div>
                    <ul>
                        <li>컨트롤러에 빙의한 폰의 InputComponent를 InputStack에 Push</li>
                        <li>만약 해당 폰의 컴포넌트 중에 InputComponent가 존재한다면 그것도 InputStack에 Push</li>
                    </ul>
                </div>

                <h2>2단계: 본격적인 입력 처리</h2>
                <h3>입력 처리 전후 타이밍</h3>
                <div class="callout">
                    <div class="callout-title">커스텀 타이밍 포인트</div>
                    <ul>
                        <li>Input 처리 전과 후 타이밍 파악 가능</li>
                        <li>실제로 Lyra Project도 GAS Input을 PostProcessInput에서 처리</li>
                    </ul>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">if (PlayerController)
{
    PlayerController->PreProcessInput(DeltaTime, bGamePaused);
}

if (PlayerController)
{
    PlayerController->PostProcessInput(DeltaTime, bGamePaused);
}</code></pre>
                </div>

                <h3>Key 이벤트 평가</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// KeysWithEvents에 InputKey들 저장
EvaluateKeyMapState(DeltaTime, bGamePaused, OUT KeysWithEvents);</code></pre>
                </div>
                <div class="callout">
                    <div class="callout-title">UPlayerInput::EvaluateKeyMapState</div>
                    <p>해당 Tick에서 Key를 눌렀는지 떴는지 등등의 Event를 KeysWithEvents에 저장</p>
                </div>

                <h3>델리게이트 실행</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// InputComponent들에 등록된 InputKey에 맞게 델리게이트 실행
EvaluateInputDelegates(InputComponentStack, DeltaTime, bGamePaused, KeysWithEvents);</code></pre>
                </div>
                <div class="callout tip">
                    <div class="callout-title">인자 구성</div>
                    <ul>
                        <li><code>InputComponentStack</code>: InputComponent들을 담고 있는 Stack</li>
                        <li><code>KeysWithEvents</code>: EvaluateKeyMapState에서 받아온 KeyEvent</li>
                    </ul>
                </div>

                <h3>입력 처리 종료</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// 이 프레임에 대한 입력 처리를 완료하고 다음 업데이트를 위해 정리
FinishProcessingPlayerInput();</code></pre>
                </div>

                <h2>입력 관리 초기화</h2>
                <h3>FinishProcessingPlayerInput</h3>
                <div class="callout">
                    <div class="callout-title">효율적인 구조</div>
                    <ul>
                        <li>입력할 수 있는 모든 Key는 KeyStateMap에 모두 생성해두고 <strong>flag 상태 변경으로 처리</strong></li>
                        <li>매번 생성하지 않고 재사용하는 효율적 구조</li>
                    </ul>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// 모든 Key에 대한 값을 매번 생성하는게 아니라
// 사용하는 Key는 저장해놓고 bConsumed을 통해 체크
for (TMap<FKey, FKeyState>::TIterator It(KeyStateMap); It; ++It)
{
    FKeyState& KeyState = It.Value();
    KeyState.bDownPrevious = KeyState.bDown;
    KeyState.bConsumed = false;
}</code></pre>
                </div>

                <h2>입력 처리 플로우</h2>
                <div class="flow-vertical">
                    <div class="flow-node">TickActor</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">TickPlayerInput</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">ProcessPlayerInput</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">BuildInputStack</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">PreProcessInput</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">EvaluateKeyMapState</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">EvaluateInputDelegates</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">PostProcessInput</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">FinishProcessingPlayerInput</div>
                </div>

                <h2>Summary</h2>
                <h3>입력 시스템 구조</h3>
                <div class="callout tip">
                    <div class="callout-title">UPlayerInput</div>
                    <ul>
                        <li>PlayerController에 존재</li>
                        <li>Input Stack 관리</li>
                        <li>모든 Key를 KeyStateMap에 저장하고 flag로 상태 관리</li>
                    </ul>
                </div>

                <div class="callout tip">
                    <div class="callout-title">UInputComponent</div>
                    <ul>
                        <li>Actor에 존재</li>
                        <li>BindAction을 통해 입력과 메서드 연결</li>
                        <li>InputStack에 쌓여 순차적으로 처리</li>
                    </ul>
                </div>

                <h3>입력 처리 순서</h3>
                <table>
                    <tr><th>순서</th><th>단계</th><th>설명</th></tr>
                    <tr><td>1</td><td>TickPlayerInput</td><td>Input 전용 Tick 실행</td></tr>
                    <tr><td>2</td><td>BuildInputStack</td><td>InputComponent들을 Stack에 수집</td></tr>
                    <tr><td>3</td><td>EvaluateKeyMapState</td><td>Key 이벤트 평가 및 저장</td></tr>
                    <tr><td>4</td><td>EvaluateInputDelegates</td><td>등록된 델리게이트 실행</td></tr>
                    <tr><td>5</td><td>FinishProcessingPlayerInput</td><td>프레임 정리</td></tr>
                </table>

                <h3>핵심 포인트</h3>
                <div class="callout">
                    <div class="callout-title">타이밍</div>
                    <ul>
                        <li>Input 처리가 일반 Tick보다 먼저 실행</li>
                        <li>PreProcessInput / PostProcessInput으로 커스텀 타이밍 제공</li>
                        <li>Lyra는 GAS Input을 PostProcessInput에서 처리</li>
                    </ul>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec21'] = {
            title: '플레이어 입력 생성',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>플레이어 입력 생성</h1>
                </div>
                <h2>Overview</h2>
                <p>SetPlayer - LocalPlayer와 PlayerController의 연결 및 InputComponent 생성</p>

                <div class="callout">
                    <div class="callout-title">핵심 질문</div>
                    <ul>
                        <li>연결이란 무엇인가?</li>
                        <li>InputComponent를 어떤 방식으로 생성하는가?</li>
                    </ul>
                </div>

                <h2>PlayerController와 LocalPlayer 연결</h2>
                <h3>SetPlayer</h3>
                <h4>1. 양방향 연결</h4>
                <p>PlayerController와 LocalPlayer가 <strong>서로를 저장</strong>합니다.</p>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// Player <-> PlayerController 연결
Player = InPlayer;
InPlayer->PlayerController = this;</code></pre>
                </div>
                <div class="callout tip">
                    <div class="callout-title">양방향 연결</div>
                    <ul>
                        <li>PlayerController가 LocalPlayer를 참조</li>
                        <li>LocalPlayer가 PlayerController를 참조</li>
                        <li>서로 접근 가능한 구조</li>
                    </ul>
                </div>

                <h4>2. 네트워크 설정</h4>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">SetAsLocalPlayerController();</code></pre>
                </div>

                <h4>3. PlayerInput 생성</h4>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// PlayerInput 생성
InitInputSystem();</code></pre>
                </div>

                <h2>Input 시스템 초기화</h2>
                <h3>InitInputSystem</h3>
                <h4>PlayerInput 생성</h4>
                <div class="callout">
                    <div class="callout-title">Custom 설정</div>
                    <ul>
                        <li>Engine 세팅에서 InputComponent를 Custom 설정 가능</li>
                        <li>Override 클래스가 있으면 해당 클래스 사용</li>
                        <li>없으면 기본 UPlayerInput 클래스 사용</li>
                    </ul>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// PlayerInput 생성
if (PlayerInput == nullptr)
{
    const UClass* OverrideClass = OverridePlayerInputClass.Get();
    PlayerInput = NewObject<UPlayerInput>(
        this,
        OverrideClass ? OverrideClass : UInputSettings::GetDefaultPlayerInputClass()
    );
}</code></pre>
                </div>

                <h4>InputComponent 생성</h4>
                <p>모든 액터는 InputComponent를 가질 수 있습니다. PlayerController 또한 Actor이므로 InputComponent를 생성하고 저장합니다.</p>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// InputComponent 생성 후 저장
SetupInputComponent();</code></pre>
                </div>

                <h2>InputComponent 설정</h2>
                <h3>SetupInputComponent</h3>
                <div class="callout">
                    <div class="callout-title">Input Binding 시점</div>
                    <ul>
                        <li>보통 Input Binding을 SetupInputComponent에서 진행</li>
                        <li><strong>Super에서 InputComponent가 생성되기 때문에 가능</strong></li>
                        <li>따라서 override 시 반드시 <code>Super::SetupInputComponent()</code> 호출 필요</li>
                    </ul>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">if (InputComponent == NULL)
{
    InputComponent = NewObject<UInputComponent>(
        this,
        UInputSettings::GetDefaultInputComponentClass(),
        TEXT("PC_InputComponent0")
    );
    InputComponent->RegisterComponent();
}</code></pre>
                </div>

                <h2>생성 프로세스</h2>
                <div class="flow-vertical">
                    <div class="flow-node">SetPlayer</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">양방향 연결</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">SetAsLocalPlayerController</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">InitInputSystem</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">PlayerInput 생성</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">SetupInputComponent</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">InputComponent 생성 & 등록</div>
                </div>

                <h2>상세 코드 분석</h2>
                <h3>전체 흐름</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">void APlayerController::SetPlayer(UPlayer* InPlayer)
{
    // 1. 양방향 연결
    Player = InPlayer;
    InPlayer->PlayerController = this;

    // 2. 네트워크 설정
    SetAsLocalPlayerController();

    // 3. Input 시스템 초기화
    InitInputSystem();
}</code></pre>
                </div>

                <h3>Input 시스템 초기화 상세</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">void APlayerController::InitInputSystem()
{
    // PlayerInput 생성
    if (PlayerInput == nullptr)
    {
        const UClass* OverrideClass = OverridePlayerInputClass.Get();
        PlayerInput = NewObject<UPlayerInput>(
            this,
            OverrideClass ? OverrideClass : UInputSettings::GetDefaultPlayerInputClass()
        );
    }

    // InputComponent 생성 및 등록
    SetupInputComponent();
}</code></pre>
                </div>

                <h2>핵심 개념</h2>
                <h3>InputComponent의 의미</h3>
                <div class="callout">
                    <div class="callout-title">InputComponent 생성 타이밍</div>
                    <p>PlayerController에서 먼저 InputComponent를 생성하는 이유:</p>
                    <ul>
                        <li>PlayerController도 Actor이므로 InputComponent를 가질 수 있음</li>
                        <li>Pawn뿐만 아니라 Controller 레벨에서도 Input 처리 가능</li>
                        <li>Input Stack에서 우선순위 관리 가능</li>
                    </ul>
                </div>

                <h3>Input 구조</h3>
                <table>
                    <tr><th>요소</th><th>위치</th><th>역할</th></tr>
                    <tr><td><strong>PlayerInput</strong></td><td>PlayerController</td><td>Input Stack 관리</td></tr>
                    <tr><td><strong>InputComponent</strong></td><td>PlayerController, Pawn</td><td>실제 Input Binding 처리</td></tr>
                    <tr><td><strong>SetupInputComponent</strong></td><td>Override 지점</td><td>Input Binding 커스터마이징</td></tr>
                </table>

                <h2>주의사항</h2>
                <div class="callout warning">
                    <div class="callout-title">Super 호출 필수</div>
                    <pre><code class="language-cpp">void AMyPlayerController::SetupInputComponent()
{
    // 반드시 Super를 먼저 호출!
    Super::SetupInputComponent();

    // 이후 커스텀 Binding
    InputComponent->BindAction("Jump", IE_Pressed, this, &AMyPlayerController::OnJump);
}</code></pre>
                </div>

                <h2>Summary</h2>
                <h3>3단계 프로세스</h3>
                <div class="callout tip">
                    <div class="callout-title">1단계: 연결</div>
                    <ul>
                        <li>PlayerController와 LocalPlayer가 <strong>양방향 연결</strong></li>
                        <li>서로를 참조할 수 있는 구조 구축</li>
                    </ul>
                </div>

                <div class="callout tip">
                    <div class="callout-title">2단계: PlayerInput 생성</div>
                    <ul>
                        <li>UPlayerInput 객체 생성</li>
                        <li>Engine 세팅에 따라 Custom 클래스 사용 가능</li>
                    </ul>
                </div>

                <div class="callout tip">
                    <div class="callout-title">3단계: InputComponent 생성</div>
                    <ul>
                        <li>PlayerController에도 UInputComponent 생성</li>
                        <li>SetupInputComponent에서 Input Binding 가능</li>
                    </ul>
                </div>

                <h3>핵심 포인트</h3>
                <table>
                    <tr><th>항목</th><th>내용</th></tr>
                    <tr><td><strong>연결 방식</strong></td><td>PlayerController ↔ LocalPlayer 양방향</td></tr>
                    <tr><td><strong>PlayerInput</strong></td><td>Controller에서 생성 및 관리</td></tr>
                    <tr><td><strong>InputComponent</strong></td><td>Controller, Pawn 모두 가질 수 있음</td></tr>
                    <tr><td><strong>Binding 시점</strong></td><td>SetupInputComponent override</td></tr>
                </table>

                <h3>알아두기</h3>
                <div class="callout">
                    <div class="callout-title">SetupInputComponent가 호출되는 이유</div>
                    <ul>
                        <li>Super에서 InputComponent를 생성하므로</li>
                        <li>생성 직후 Binding을 설정할 수 있도록 제공</li>
                        <li>Override 시 반드시 Super 호출 필요</li>
                    </ul>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec22'] = {
            title: '플레이어 시작',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>플레이어 시작</h1>
                </div>
                <h2>Overview</h2>
                <p>PostLogin - 폰을 생성하고 Possess를 하는 함수입니다. Player가 시작되는 과정에 집중합니다.</p>

                <h2>플레이어 시작 프로세스</h2>
                <h3>시작점: PostLogin</h3>
                <p>핵심 로직은 HandleStartingNewPlayer_Implementation에서 처리됩니다.</p>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// Pawn 생성과 Possess 진행
HandleStartingNewPlayer(NewPlayer);</code></pre>
                </div>

                <h2>HandleStartingNewPlayer</h2>
                <div class="callout warning">
                    <div class="callout-title">함수 이름 주의!</div>
                    <p>함수 이름의 '<strong>Restart</strong>'에 속지 말기! 실제로는 최초 시작 시에도 호출됩니다.</p>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// APlayerController* NewPlayer
if (PlayerCanRestart(NewPlayer))
{
    RestartPlayer(NewPlayer);
}</code></pre>
                </div>

                <h2>플레이어 시작 조건 확인</h2>
                <h3>PlayerCanRestart_Implementation</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">if (Player == nullptr || Player->IsPendingKillPending())
{
    return false;
}

return Player->CanRestartPlayer();</code></pre>
                </div>

                <h3>APlayerController::CanRestartPlayer</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// PlayerState가 있어야 시작 가능!
return PlayerState;</code></pre>
                </div>

                <div class="callout important">
                    <div class="callout-title">플레이어 Start의 조건</div>
                    <p><strong>PlayerController</strong>와 <strong>PlayerState</strong>가 존재해야 합니다!</p>
                </div>

                <h2>프레임워크 동작 원리</h2>
                <div class="callout">
                    <div class="callout-title">언리얼의 순차적 구조</div>
                    <ul>
                        <li>이미 이전 과정에서 PlayerController가 생성됨</li>
                        <li>PostInit 과정을 통해 PlayerState도 생성됨</li>
                        <li>이후에 PlayerCanRestart 로직이 호출됨</li>
                        <li>따라서 언리얼 자체적인 순서상에서는 해당 메서드가 <strong>false를 반환할 일이 없습니다</strong></li>
                    </ul>
                </div>

                <h2>커스터마이징 시 주의사항</h2>
                <div class="callout warning">
                    <div class="callout-title">유령 Player 문제</div>
                    <p><strong>PlayerCanRestart Override 시 주의:</strong></p>
                    <ul>
                        <li>해당 함수가 false를 반환하면 → Pawn이 생성되지 않음</li>
                        <li>Possess도 진행되지 않음 → <strong>유령 Player</strong>가 됨</li>
                        <li>유령 Player에게 시간이 지나면 다시 PlayerStart를 시도하는 로직이 <strong>없음</strong></li>
                        <li>한 번 유령 Player가 되면 그 상태가 계속해서 지속됨</li>
                    </ul>
                </div>

                <div class="callout tip">
                    <div class="callout-title">해결 방법</div>
                    <p>PlayerCanRestart를 Custom하거나, PlayerStart 타이밍이 변경되는 경우:</p>
                    <ul>
                        <li><strong>'일정 시간이 지난 후 다시 시도'</strong>와 같은 처리 필요</li>
                        <li>재시도 로직 구현</li>
                        <li>타임아웃 처리</li>
                    </ul>
                </div>

                <h2>RestartPlayer 진입</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// Pawn 생성 할 위치 결정
AActor* StartSpot = FindPlayerStart(NewPlayer);

// 없으면 PlayerController에 저장되어 있는거 사용
if (StartSpot == nullptr)
{
    if (NewPlayer->StartSpot != nullptr)
    {
        StartSpot = NewPlayer->StartSpot.Get();
    }
}

// Pawn 생성과 Possess 진행
RestartPlayerAtPlayerStart(NewPlayer, StartSpot);</code></pre>
                </div>

                <h2>플레이어 시작 플로우</h2>
                <div class="flow-vertical">
                    <div class="flow-node">PostLogin</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">HandleStartingNewPlayer</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">PlayerCanRestart?</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">RestartPlayer</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">FindPlayerStart</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">RestartPlayerAtPlayerStart</div>
                </div>

                <h2>Summary</h2>
                <table>
                    <tr><th>순서</th><th>함수</th><th>역할</th></tr>
                    <tr><td>1</td><td>PostLogin</td><td>플레이어 시작 진입점</td></tr>
                    <tr><td>2</td><td>HandleStartingNewPlayer</td><td>시작 처리 오케스트레이션</td></tr>
                    <tr><td>3</td><td>PlayerCanRestart</td><td>시작 가능 여부 확인</td></tr>
                    <tr><td>4</td><td>RestartPlayer</td><td>실제 시작 처리</td></tr>
                    <tr><td>5</td><td>FindPlayerStart</td><td>스폰 위치 결정</td></tr>
                    <tr><td>6</td><td>RestartPlayerAtPlayerStart</td><td>Pawn 생성 및 Possess</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec23'] = {
            title: '폰 생성 위치 결정',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>폰 생성 위치 결정</h1>
                </div>
                <h2>Overview</h2>
                <p>폰 생성 위치를 결정하는 방법과 프로세스를 분석합니다. 폰 생성 위치를 결정한다는 것은 <strong>PlayerStart 위치를 찾는 것</strong>입니다.</p>

                <div class="callout warning">
                    <div class="callout-title">잠재적 문제</div>
                    <p>만약 PlayerStart Actor가 캐릭터가 위치할 수 없는 곳(collision 안)에 위치해 있다면?</p>
                    <p>→ 해당 Player는 스폰되지 못하는 문제가 발생</p>
                    <p><strong>따라서</strong>: 생성 위치는 <strong>수단과 방법을 가리지 말고</strong> 정해져야 합니다.</p>
                </div>

                <h2>4가지 위치 결정 방법 (우선순위 순)</h2>
                <h3>1️⃣ 특정 PlayerStart 지정 방식</h3>
                <p>A, B, C PlayerStart Actor가 존재할 때, 특정 PlayerStart를 지정 (ex: B)</p>

                <h3>2️⃣ PlayerController 저장 위치 사용</h3>
                <p>PlayerController에 저장되어 있는 PlayerStart 위치에 생성</p>

                <h3>3️⃣ ChoosePlayerStart로 탐색 ⭐ (주요 방법)</h3>
                <ul>
                    <li>World에 배치된 모든 PlayerStart 순회</li>
                    <li>Player Spawn이 실제로 가능한 곳과 그렇지 않은 곳을 구분</li>
                    <li>처음부터 스폰 가능한 위치는 별도 배열에 저장</li>
                    <li>스폰 불가능한 위치는 조정하여 가능한 곳 확인 후 저장</li>
                    <li>배열에서 무작위로 하나 선택</li>
                </ul>

                <h3>4️⃣ 최후의 수단: WorldSettings 위치</h3>
                <p>PlayerStart가 하나도 없다면 Persistent Level의 WorldSetting 위치 사용 (보통 원점)</p>

                <h2>IncomingName으로 특정 PlayerStart 찾기</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// const FString& IncomingName

// 이름 값을 넘겼으면 동일한 PlayerStart를 World에서 찾아서 반환
if (!IncomingName.IsEmpty())
{
    const FName IncomingPlayerStartTag = FName(*IncomingName);
    for (TActorIterator<APlayerStart> It(World); It; ++It)
    {
        APlayerStart* Start = *It;
        if (Start && Start->PlayerStartTag == IncomingPlayerStartTag)
        {
            return Start;
        }
    }
}</code></pre>
                </div>

                <h2>ChoosePlayerStart 상세 로직</h2>
                <h3>두 가지 배열 사용</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// Pawn이 즉시 배치될 수 있는 충돌 없는 시작 지점 목록
TArray<APlayerStart*> UnOccupiedStartPoints;

// 원래 위치는 막혔지만, 약간의 조정을 통해 Pawn이 배치될 수 있는 시작 지점 목록
TArray<APlayerStart*> OccupiedStartPoints;</code></pre>
                </div>

                <h3>PlayerStart 분류</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">for (TActorIterator<APlayerStart> It(World); It; ++It)
{
    APlayerStart* PlayerStart = *It;

    // 에디터에서 Play From Here을 사용했다면 해당 지점으로 결정
    if (PlayerStart->IsA<APlayerStartPIE>())
    {
        FoundPlayerStart = PlayerStart;
        break;
    }
    else
    {
        FVector ActorLocation = PlayerStart->GetActorLocation();
        const FRotator ActorRotation = PlayerStart->GetActorRotation();

        // Pawn이 지정된 위치/회전에 배치될 때 다른 물체와 겹치는지 검사
        if (!World->EncroachingBlockingGeometry(PawnToFit, ActorLocation, ActorRotation))
        {
            UnOccupiedStartPoints.Add(PlayerStart);
        }
        // 겹친다면, 그 근처에 Pawn이 안전하게 이동될 수 있는 지점이 있는지 검사
        else if (World->FindTeleportSpot(PawnToFit, ActorLocation, ActorRotation))
        {
            OccupiedStartPoints.Add(PlayerStart);
        }
    }
}</code></pre>
                </div>

                <h3>최종 선택</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">if (FoundPlayerStart == nullptr)
{
    // UnOccupiedStartPoints에 항목이 있으면 그중 하나를 무작위로 선택
    if (UnOccupiedStartPoints.Num() > 0)
    {
        FoundPlayerStart = UnOccupiedStartPoints[FMath::RandRange(0, UnOccupiedStartPoints.Num() - 1)];
    }
    // OccupiedStartPoints에 항목이 있으면 그중 하나를 무작위로 선택
    else if (OccupiedStartPoints.Num() > 0)
    {
        FoundPlayerStart = OccupiedStartPoints[FMath::RandRange(0, OccupiedStartPoints.Num() - 1)];
    }
}

return FoundPlayerStart;</code></pre>
                </div>

                <h2>최후의 수단: WorldSettings</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">if (BestStart == nullptr)
{
    // 모든 케이스에서 없다면 WorldSetting이라도 사용 (이건 없을 수 없음)
    // nullptr을 반환하면 이후 로직에서 많은 문제가 생김
    // 기본적으로 적절한 플레이어 시작을 찾지 못하면 0,0,0에 스폰
    BestStart = World->GetWorldSettings();
}</code></pre>
                </div>

                <h2>우선순위 정리</h2>
                <table>
                    <tr><th>우선순위</th><th>방법</th><th>조건</th><th>검증</th></tr>
                    <tr><td>1</td><td>Play From Here</td><td>APlayerStartPIE 존재</td><td>없음 ⚠️</td></tr>
                    <tr><td>2</td><td>IncomingName</td><td>Name 지정</td><td>없음 ⚠️</td></tr>
                    <tr><td>3</td><td>Controller StartSpot</td><td>StartSpot 저장됨</td><td>있음</td></tr>
                    <tr><td>4</td><td>UnOccupied</td><td>충돌 없는 위치</td><td>있음 ✅</td></tr>
                    <tr><td>5</td><td>Occupied</td><td>조정 가능한 위치</td><td>있음 ✅</td></tr>
                    <tr><td>6</td><td>WorldSettings</td><td>모두 실패</td><td>없음</td></tr>
                </table>

                <h2>Summary</h2>
                <div class="callout tip">
                    <div class="callout-title">ChoosePlayerStart 핵심</div>
                    <ul>
                        <li><strong>UnOccupiedStartPoints</strong>: 즉시 스폰 가능한 위치 (우선순위 높음)</li>
                        <li><strong>OccupiedStartPoints</strong>: 조정 후 스폰 가능한 위치 (차선책)</li>
                        <li>무작위 선택으로 플레이어 분산 배치</li>
                    </ul>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec24'] = {
            title: '폰 생성과 빙의',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>폰 생성과 빙의</h1>
                </div>
                <h2>Overview</h2>
                <p>RestartPlayerAtPlayerStart - 정해진 위치에 Player를 생성하고 빙의까지 진행합니다. 전체적인 흐름의 순서에 주목합니다.</p>

                <h2>전체 프로세스</h2>
                <div class="flow-vertical">
                    <div class="flow-node">RestartPlayerAtPlayerStart</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Controller 유효?</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">StartSpot 유효?</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Pawn 생성</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">SetPawn</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">FinishRestartPlayer (Possess)</div>
                </div>

                <h2>1단계: 유효성 검증</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// AController* NewPlayer, AActor* StartSpot

if (NewPlayer == nullptr || NewPlayer->IsPendingKillPending())
{
    return;
}

if (!StartSpot)
{
    return;
}</code></pre>
                </div>

                <div class="callout warning">
                    <div class="callout-title">StartSpot의 중요성</div>
                    <p><strong>수단과 방법을 가리지 않고 APlayerStart를 찾아야 하는 이유는 여기에서 나옵니다.</strong></p>
                    <ul>
                        <li>StartSpot이 없으면 <strong>바로 반환</strong></li>
                        <li>Pawn 생성도 안 되고 빙의도 안 됨</li>
                    </ul>
                </div>

                <h2>2단계: Pawn 생성</h2>
                <h3>1️⃣ PlayerController에 이미 Pawn이 있는 경우</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">FRotator SpawnRotation = StartSpot->GetActorRotation();

// 기존에 Controller에 Pawn이 존재하면 Rotation 그대로 사용
if (NewPlayer->GetPawn() != nullptr)
{
    SpawnRotation = NewPlayer->GetPawn()->GetActorRotation();
}</code></pre>
                </div>

                <h3>2️⃣ PlayerController에 Pawn이 없는 경우 (일반적)</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// DefaultPawn Class가 존재하는지 확인
else if (GetDefaultPawnClassForController(NewPlayer) != nullptr)
{
    // Pawn 생성
    APawn* NewPawn = SpawnDefaultPawnFor(NewPlayer, StartSpot);
    if (IsValid(NewPawn))
    {
        // Controller Pawn 설정
        // Controller <-> Pawn Attach + Pawn Tick 순서 조정
        NewPlayer->SetPawn(NewPawn);
    }
}</code></pre>
                </div>

                <div class="callout important">
                    <div class="callout-title">SetPawn의 역할</div>
                    <ul>
                        <li>Controller에 Pawn을 저장</li>
                        <li><strong>아직 빙의 단계는 아님</strong></li>
                        <li>빙의는 <strong>양방향</strong>이어야 함</li>
                        <li>Pawn도 Controller와 연결되어야 빙의라고 할 수 있음</li>
                    </ul>
                </div>

                <h2>3단계: 빙의 처리</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">if (!IsValid(NewPlayer->GetPawn()))
{
    FailedToRestartPlayer(NewPlayer);
}
else
{
    // StartSpot을 변경할 수 있는 마지막 오버라이딩 함수
    InitStartSpot(StartSpot, NewPlayer);

    // Possess 진행 및 Controller 회전 값 설정
    FinishRestartPlayer(NewPlayer, SpawnRotation);
}</code></pre>
                </div>

                <h2>SetPawn vs Possess</h2>
                <table>
                    <tr><th>항목</th><th>SetPawn</th><th>Possess</th></tr>
                    <tr><td><strong>시점</strong></td><td>Pawn 생성 직후</td><td>SetPawn 이후</td></tr>
                    <tr><td><strong>Controller → Pawn</strong></td><td>✅ 연결됨</td><td>✅ 연결 유지</td></tr>
                    <tr><td><strong>Pawn → Controller</strong></td><td>❌ 연결 안 됨</td><td>✅ 연결됨</td></tr>
                    <tr><td><strong>빙의 상태</strong></td><td>❌ 아직 아님</td><td>✅ 완료</td></tr>
                    <tr><td><strong>Attach</strong></td><td>✅ 진행</td><td>-</td></tr>
                    <tr><td><strong>Tick 순서</strong></td><td>✅ 조정</td><td>-</td></tr>
                </table>

                <h2>4단계 요약</h2>
                <div class="flow-diagram">
                    <div class="flow-node">1. Get Default Pawn Class</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">2. Pawn 생성</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">3. SetPawn</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">4. Possess</div>
                </div>

                <h2>Summary</h2>
                <div class="callout tip">
                    <div class="callout-title">핵심 개념</div>
                    <ul>
                        <li><strong>SetPawn</strong>: Controller → Pawn 단방향 연결</li>
                        <li><strong>Possess</strong>: Controller ↔ Pawn 양방향 연결</li>
                        <li>Possess가 완료되어야 진정한 빙의!</li>
                    </ul>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec25'] = {
            title: '폰 생성',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>폰 생성</h1>
                </div>
                <h2>Overview</h2>
                <p>Default Pawn은 어떻게 가져오는지, 이전에 결정된 위치를 어떻게 활용하여 생성하는지 분석합니다.</p>

                <h2>Pawn 생성 프로세스</h2>
                <div class="flow-diagram">
                    <div class="flow-node">RestartPlayerAtPlayerStart</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">GetDefaultPawnClassForController</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">SpawnDefaultPawnFor</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">SpawnDefaultPawnAtTransform</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Pawn 생성 완료</div>
                </div>

                <h2>1단계: Pawn Class 가져오기</h2>
                <h3>GetDefaultPawnClassForController_Implementation</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">UClass* AGameModeBase::GetDefaultPawnClassForController_Implementation(AController* InController)
{
    return DefaultPawnClass;
}</code></pre>
                </div>

                <div class="callout tip">
                    <div class="callout-title">왜 함수를 사용하는가?</div>
                    <p>그냥 DefaultPawnClass 멤버변수를 가져와서 쓰면 되지 않나?</p>
                    <ul>
                        <li>해당 함수는 <strong>override가 가능</strong></li>
                        <li>개발자가 원하는 Pawn을 고를 수 있도록 Custom할 수 있음</li>
                        <li>생성할 Pawn을 결정하는 곳에서는 이 함수를 사용해줘야 override했을 때도 의미가 있음</li>
                    </ul>
                </div>

                <h2>2단계: Pawn 실제 생성</h2>
                <h3>SpawnDefaultPawnFor_Implementation</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// AController* NewPlayer, AActor* StartSpot

// 생성 지점에서 Yaw값만 반영하도록 설정
FRotator StartRotation(ForceInit);
StartRotation.Yaw = StartSpot->GetActorRotation().Yaw;
FVector StartLocation = StartSpot->GetActorLocation();

// 지정된 위치에 Pawn 생성
FTransform Transform = FTransform(StartRotation, StartLocation);
return SpawnDefaultPawnAtTransform(NewPlayer, Transform);</code></pre>
                </div>

                <div class="callout">
                    <div class="callout-title">Rotation 처리</div>
                    <ul>
                        <li>APlayerStart의 <strong>위치값</strong>과 <strong>Yaw 회전값만</strong> 반영</li>
                        <li>Pitch, Roll은 무시</li>
                        <li>Transform으로 저장하고 스폰 함수 호출</li>
                    </ul>
                </div>

                <h2>3단계: Transform 기반 생성</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// AController* NewPlayer, const FTransform& SpawnTransform

FActorSpawnParameters SpawnInfo;
SpawnInfo.Instigator = GetInstigator();
SpawnInfo.ObjectFlags |= RF_Transient;

// Pawn 생성
UClass* PawnClass = GetDefaultPawnClassForController(NewPlayer);
APawn* ResultPawn = GetWorld()->SpawnActor<APawn>(PawnClass, SpawnTransform, SpawnInfo);

return ResultPawn;</code></pre>
                </div>

                <h2>StartSpot 활용 방식</h2>
                <h3>Rotation 처리</h3>
                <table>
                    <tr><th>Rotation 요소</th><th>사용 여부</th><th>설명</th></tr>
                    <tr><td><strong>Yaw</strong></td><td>✅ 사용</td><td>좌우 회전 (수평 방향)</td></tr>
                    <tr><td><strong>Pitch</strong></td><td>❌ 무시</td><td>상하 회전</td></tr>
                    <tr><td><strong>Roll</strong></td><td>❌ 무시</td><td>좌우 기울기</td></tr>
                </table>

                <div class="callout">
                    <div class="callout-title">Yaw만 사용하는 이유</div>
                    <ul>
                        <li>캐릭터는 보통 수평 방향만 필요</li>
                        <li>Pitch, Roll은 캐릭터 제어에서 일반적으로 사용하지 않음</li>
                        <li>필요하다면 Override하여 변경 가능</li>
                    </ul>
                </div>

                <h2>커스터마이징 예시</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">UClass* AMyGameMode::GetDefaultPawnClassForController_Implementation(AController* InController)
{
    // 플레이어 타입에 따라 다른 Pawn 사용
    if (APlayerController* PC = Cast<APlayerController>(InController))
    {
        if (PC->GetPlayerState<AMyPlayerState>()->SelectedCharacter == ECharacterType::Warrior)
        {
            return WarriorPawnClass;
        }
        else
        {
            return MagePawnClass;
        }
    }

    return Super::GetDefaultPawnClassForController_Implementation(InController);
}</code></pre>
                </div>

                <h2>Summary</h2>
                <table>
                    <tr><th>단계</th><th>함수</th><th>주요 작업</th></tr>
                    <tr><td>1</td><td>GetDefaultPawnClassForController</td><td>Pawn 클래스 결정</td></tr>
                    <tr><td>2</td><td>SpawnDefaultPawnFor</td><td>StartSpot → Transform 변환</td></tr>
                    <tr><td>3</td><td>SpawnDefaultPawnAtTransform</td><td>실제 World에 Spawn</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec26'] = {
            title: '컨트롤러 폰 수정',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>컨트롤러 폰 수정</h1>
                </div>
                <h2>Overview</h2>
                <p>SetPawn - Controller가 Pawn을 저장 (빙의 X). Controller가 Pawn을 연결하는 것이 무슨 의미인가에 주목합니다.</p>

                <h2>SetPawn 프로세스</h2>
                <div class="flow-diagram">
                    <div class="flow-node">SetPawn</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Controller에 Pawn 저장</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Controller를 Pawn에 Attach</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Pawn Tick 순서 조정</div>
                </div>

                <h2>3가지 단계</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// Controller에 Pawn 저장
Pawn = InPawn;
Character = (Pawn ? Cast<ACharacter>(Pawn) : NULL);

// Controller를 Pawn에 Attach
AttachToPawn(Pawn);

// Pawn Tick 조건 설정
AddPawnTickDependency(Pawn);</code></pre>
                </div>

                <h2>1단계: Pawn 저장</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// Controller에 Pawn 저장
Pawn = InPawn;
Character = (Pawn ? Cast<ACharacter>(Pawn) : NULL);</code></pre>
                </div>
                <div class="callout">
                    <div class="callout-title">두 가지 변수</div>
                    <ul>
                        <li><strong>Pawn</strong>: 모든 Pawn 타입</li>
                        <li><strong>Character</strong>: Pawn이 ACharacter인 경우 캐스팅하여 저장</li>
                        <li>Character는 편의를 위한 캐싱</li>
                    </ul>
                </div>

                <h2>2단계: Attach 처리</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// Controller를 Pawn에 Attach 진행
if (InPawn)
{
    if (InPawn->GetRootComponent() && RootComponent->GetAttachParent() != InPawn->GetRootComponent())
    {
        RootComponent->DetachFromComponent(FDetachmentTransformRules::KeepRelativeTransform);
        RootComponent->SetRelativeLocationAndRotation(FVector::ZeroVector, FRotator::ZeroRotator);
        RootComponent->AttachToComponent(InPawn->GetRootComponent(), FAttachmentTransformRules::KeepRelativeTransform);
    }
}
else
{
    DetachFromPawn();
}</code></pre>
                </div>

                <div class="callout tip">
                    <div class="callout-title">왜 Controller를 Pawn에 Attach하나?</div>
                    <p><strong>위치 동기화</strong>:</p>
                    <ul>
                        <li>로직을 구성할 때 항상 Controller의 location은 쓰면 안 되고 Character의 location을 써야 함</li>
                        <li>두 개의 위치를 같은 곳으로 위치시켜 실수 방지</li>
                        <li>Controller의 위치가 자동으로 Pawn을 따라감</li>
                        <li>WorldPartition에서 Controller 위치가 중요한 역할</li>
                    </ul>
                </div>

                <h2>3단계: Tick 순서 조정</h2>
                <div class="callout warning">
                    <div class="callout-title">Input 처리 지연 문제</div>
                    <p><strong>문제 상황</strong>:</p>
                    <ul>
                        <li>PlayerController에서 해당 tick에 들어온 input을 받음</li>
                        <li>이를 Pawn의 InputComponent에 넘겨주어 Bind된 함수를 호출</li>
                        <li>PlayerController Tick이 Pawn의 Tick보다 <strong>늦게</strong> 돌면</li>
                        <li><strong>입력 처리가 1틱씩 늦게 처리되는 문제</strong> 발생</li>
                    </ul>
                    <p><strong>해결책</strong>: PlayerController의 Tick이 먼저 돌 수 있도록 수정</p>
                </div>

                <h2>Tick 순서 비교</h2>
                <table>
                    <tr><th>상황</th><th>Tick 순서</th><th>문제</th></tr>
                    <tr><td><strong>기본 Attach</strong></td><td>Pawn → Controller</td><td>❌ Input 1틱 지연</td></tr>
                    <tr><td><strong>AddPawnTickDependency</strong></td><td>Controller → Pawn</td><td>✅ 즉시 처리</td></tr>
                </table>

                <h2>단계별 상태 변화</h2>
                <table>
                    <tr><th>단계</th><th>Controller → Pawn</th><th>Pawn → Controller</th><th>Attach</th><th>Tick 순서</th></tr>
                    <tr><td><strong>Before</strong></td><td>❌</td><td>❌</td><td>❌</td><td>-</td></tr>
                    <tr><td><strong>1단계 후</strong></td><td>✅</td><td>❌</td><td>❌</td><td>-</td></tr>
                    <tr><td><strong>2단계 후</strong></td><td>✅</td><td>❌</td><td>✅</td><td>Pawn → Controller</td></tr>
                    <tr><td><strong>3단계 후</strong></td><td>✅</td><td>❌</td><td>✅</td><td>Controller → Pawn</td></tr>
                </table>

                <div class="callout important">
                    <div class="callout-title">아직 빙의는 아님</div>
                    <ul>
                        <li>Controller가 Pawn을 알고 있음 (단방향)</li>
                        <li>Pawn은 아직 Controller를 모름</li>
                        <li><strong>빙의는 양방향 연결이 필요</strong></li>
                    </ul>
                </div>

                <h2>Summary</h2>
                <div class="callout tip">
                    <div class="callout-title">SetPawn ≠ Possess</div>
                    <ul>
                        <li>SetPawn은 <strong>Controller → Pawn</strong> 단방향 연결</li>
                        <li>Possess는 <strong>Controller ↔ Pawn</strong> 양방향 연결</li>
                        <li>SetPawn만으로는 빙의가 완료되지 않음</li>
                    </ul>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec27'] = {
            title: '빙의 (Possess)',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>빙의 (Possess)</h1>
                </div>
                <h2>빙의 시나리오</h2>
                <div class="callout">
                    <div class="callout-title">상황 설정</div>
                    <ul>
                        <li>현재 <strong>PlayerController A</strong>가 소유한 <strong>Pawn A'</strong>가 있음</li>
                        <li>다른 <strong>Pawn B'</strong>로 변경하려 함</li>
                        <li>그런데 <strong>B'</strong> 역시 다른 <strong>PlayerController B</strong>에 의해 빙의된 상태</li>
                    </ul>
                </div>

                <h2>관련 로직 4단계</h2>
                <div class="flow-vertical">
                    <div class="flow-node">1. Controller A와 Pawn A' 연결 해제</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">2. Pawn B'와 Controller B 연결 해제</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">3. Pawn B'에 Controller A 정보 전달</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">4. Controller A가 Pawn B' 연결</div>
                </div>

                <h2>Possess 메인 로직</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">APawn* CurrentPawn = GetPawn();

// Pawn Possess 시도
OnPossess(InPawn);

// Possess된 Pawn이 변경되면 BroadCast로 알려줌
APawn* NewPawn = GetPawn();
const bool bNotificationRequired = (CurrentPawn != nullptr) && (CurrentPawn->GetController() == nullptr);
if ((NewPawn != CurrentPawn) || bNotificationRequired)
{
    ReceivePossess(NewPawn);
    OnNewPawn.Broadcast(NewPawn);
    OnPossessedPawnChanged.Broadcast(bNotificationRequired ? nullptr : CurrentPawn, NewPawn);
}</code></pre>
                </div>

                <h2>OnPossess: 4단계 빙의 로직</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// APawn* PawnToPossess

// 1단계: 이미 Controller에 Pawn이 존재하면? UnPossess 먼저 진행
if (GetPawn() && bNewPawn)
{
    UnPossess();
}

// 2단계: Possess할 Pawn에 Controller가 있으면 UnPossess 진행
if (PawnToPossess->Controller != NULL)
{
    PawnToPossess->Controller->UnPossess();
}

// 3단계: Pawn이 연결!
PawnToPossess->PossessedBy(this);

// Controller의 Rotation을 Pawn의 Rotation으로 설정
SetControlRotation(PawnToPossess->GetActorRotation());

// 4단계: Controller가 연결!
SetPawn(PawnToPossess);</code></pre>
                </div>

                <h2>1단계: 기존 Pawn 연결 해제 (UnPossess)</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">if (GetPawn() != NULL)
{
    // 폰의 연결 해제
    GetPawn()->UnPossessed();

    if (GetViewTarget() == GetPawn())
    {
        SetViewTarget(this);
    }
}

// 컨트롤러의 연결 해제
SetPawn(NULL);</code></pre>
                </div>

                <h3>APawn::UnPossessed</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">AController* const OldController = Controller;

PlayerState = nullptr;
Owner = nullptr;
Controller = nullptr;

// Pawn의 InputComponent 파괴
DestroyPlayerInputComponent();</code></pre>
                </div>

                <div class="callout tip">
                    <div class="callout-title">Pawn의 Owner는 Controller</div>
                    <p>PlayerState, Owner, Controller 모두 nullptr로 설정됨</p>
                </div>

                <h2>3단계: Pawn에서 Controller 설정 (PossessedBy)</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// Controller 설정
Owner = NewController;
Controller = NewController;

// Controller의 PlayerState로 변경
if (Controller->PlayerState != nullptr)
{
    SetPlayerState(Controller->PlayerState);
}

// Controller가 변경된게 맞으면 BroadCast
if (OldController != NewController)
{
    ReceivePossessed(Controller);
    NotifyControllerChanged();
}</code></pre>
                </div>

                <h2>4단계: Controller에서 Pawn 설정</h2>
                <div class="callout important">
                    <div class="callout-title">SetPawn 중복 호출 이유</div>
                    <p>AGameModeBase::RestartPlayerAtPlayerStart에서 분명히 SetPawn을 통해 Controller에 Pawn의 정보가 세팅되었는데 왜 또다시 세팅하는가?</p>
                    <ul>
                        <li><strong>RestartPlayerAtPlayerStart</strong>는 <strong>프레임워크 과정</strong></li>
                        <li><strong>OnPossess</strong>는 <strong>런타임 중 얼마든지</strong> Controller의 Pawn을 변경하며 호출할 수 있는 함수</li>
                        <li>OnPossess에서 SetPawn을 호출해주지 않으면 런타임 중에 Controller의 Pawn을 다른 Pawn으로 변경하는 경우에 연결이 제대로 이루어지지 않을 수 있음</li>
                    </ul>
                </div>

                <h2>빙의 vs 연결 해제 비교</h2>
                <h3>Possess (빙의)</h3>
                <table>
                    <tr><th>단계</th><th>Controller → Pawn</th><th>Pawn → Controller</th></tr>
                    <tr><td>SetPawn 후</td><td>✅ 저장</td><td>❌</td></tr>
                    <tr><td>PossessedBy 후</td><td>✅</td><td>✅ 저장</td></tr>
                    <tr><td><strong>최종</strong></td><td><strong>✅ 양방향 연결</strong></td><td><strong>✅ 양방향 연결</strong></td></tr>
                </table>

                <h3>UnPossess (연결 해제)</h3>
                <table>
                    <tr><th>단계</th><th>Controller → Pawn</th><th>Pawn → Controller</th></tr>
                    <tr><td>UnPossessed 후</td><td>✅ 아직 연결</td><td>❌ nullptr</td></tr>
                    <tr><td>SetPawn(NULL) 후</td><td>❌ nullptr</td><td>❌ nullptr</td></tr>
                    <tr><td><strong>최종</strong></td><td><strong>❌ 연결 없음</strong></td><td><strong>❌ 연결 없음</strong></td></tr>
                </table>

                <h2>Summary</h2>
                <div class="callout tip">
                    <div class="callout-title">빙의는 양방향 연결</div>
                    <ul>
                        <li><strong>Controller → Pawn</strong> 연결 필요</li>
                        <li><strong>Pawn → Controller</strong> 연결 필요</li>
                        <li>둘 다 완료되어야 진정한 빙의!</li>
                    </ul>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec28'] = {
            title: '카메라 타겟과 입력 설정',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>카메라 타겟 설정과 폰의 입력 설정</h1>
                </div>
                <h2>Overview</h2>
                <p>ClientRestart_Implementation - 빙의 후 후속 처리를 담당합니다.</p>

                <div class="callout important">
                    <div class="callout-title">클라이언트에서 진행</div>
                    <ul>
                        <li>명칭에서 알 수 있듯 <strong>클라이언트에서 진행</strong></li>
                        <li>서버에서 빙의가 끝나면 클라에게 요청</li>
                        <li><strong>입력과 카메라(화면)는 클라에서만 필요</strong></li>
                    </ul>
                </div>

                <h2>후속 처리 프로세스</h2>
                <div class="flow-vertical">
                    <div class="flow-node">ClientRestart_Implementation</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">카메라 타겟 설정</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">InputComponent 생성 및 등록</div>
                </div>

                <h2>DispatchRestart</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">void APawn::DispatchRestart(bool bCallClientRestart)
{
    if (bCallClientRestart)
    {
        PawnClientRestart();
    }
    else
    {
        Restart();
    }

    NotifyRestarted();
}</code></pre>
                </div>

                <h2>카메라 처리</h2>
                <h3>PawnClientRestart</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// 폰으로 카메라 타겟 설정
if (PC->bAutoManageActiveCameraTarget)
{
    PC->AutoManageActiveCameraTarget(this);
}

// InputComponent 생성 및 등록
if (InputComponent == nullptr)
{
    InputComponent = CreatePlayerInputComponent();
    if (InputComponent)
    {
        SetupPlayerInputComponent(InputComponent);
        InputComponent->RegisterComponent();
    }
}</code></pre>
                </div>

                <h2>카메라 타겟 설정</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// AActor* SuggestedTarget
if (bAutoManageActiveCameraTarget)
{
    // 자동 카메라 활성모드인 경우
    ACameraActor* AutoCameraTarget = GetAutoActivateCameraForPlayer();
    if (AutoCameraTarget)
    {
        SetViewTarget(AutoCameraTarget);
        return;
    }

    // Camera가 바라보는 대상 ViewTarget을 설정
    SetViewTarget(SuggestedTarget);
}</code></pre>
                </div>

                <h2>Input 처리 3단계</h2>
                <h3>1️⃣ InputComponent 생성</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">InputComponent = CreatePlayerInputComponent();</code></pre>
                </div>

                <h3>2️⃣ SetupPlayerInputComponent 호출 ⭐</h3>
                <div class="callout important">
                    <div class="callout-title">SetupPlayerInputComponent</div>
                    <p><strong>입력에 대한 Binding 함수를 처리할 때 호출하는 함수</strong></p>
                    <ul>
                        <li>InputComponent가 생성되고 호출됨</li>
                        <li><strong>무조건 InputComponent가 있다고 보장 받을 수 있는 시점</strong></li>
                        <li>여기서 Input Binding 처리</li>
                    </ul>
                </div>

                <h3>3️⃣ RegisterComponent</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">InputComponent->RegisterComponent();</code></pre>
                </div>

                <h2>SetupPlayerInputComponent의 중요성</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">void AMyCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
    // Super 호출 (필수는 아니지만 권장)
    Super::SetupPlayerInputComponent(PlayerInputComponent);

    // Input Binding
    PlayerInputComponent->BindAxis("MoveForward", this, &AMyCharacter::MoveForward);
    PlayerInputComponent->BindAxis("MoveRight", this, &AMyCharacter::MoveRight);
    PlayerInputComponent->BindAction("Jump", IE_Pressed, this, &ACharacter::Jump);
}</code></pre>
                </div>

                <h2>서버 vs 클라이언트</h2>
                <table>
                    <tr><th>처리</th><th>서버</th><th>클라이언트</th></tr>
                    <tr><td><strong>빙의</strong></td><td>✅ Possess 실행</td><td>-</td></tr>
                    <tr><td><strong>카메라</strong></td><td>❌ 불필요</td><td>✅ ViewTarget 설정</td></tr>
                    <tr><td><strong>Input</strong></td><td>❌ 불필요</td><td>✅ InputComponent 생성</td></tr>
                    <tr><td><strong>후속 처리 요청</strong></td><td>✅ ClientRestart 호출</td><td>-</td></tr>
                </table>

                <h2>Summary</h2>
                <div class="callout tip">
                    <div class="callout-title">SetupPlayerInputComponent 가장 중요한 타이밍</div>
                    <ul>
                        <li>InputComponent가 <strong>확실히 생성된 후</strong> 호출</li>
                        <li>nullptr 걱정 없이 Binding 가능</li>
                        <li>Character/Pawn에서 Override하여 Input 설정</li>
                    </ul>
                </div>

                <div class="callout warning">
                    <div class="callout-title">SetupPlayerInputComponent 타이밍</div>
                    <ul>
                        <li>빙의가 완료되어야 호출됨</li>
                        <li>생성자나 BeginPlay에서는 InputComponent가 없을 수 있음</li>
                        <li>반드시 이 함수에서 Binding 처리</li>
                    </ul>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec29'] = {
            title: '빙의 완료 후 세부 설정',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>빙의 완료 후 세부 설정</h1>
                </div>
                <h2>Overview</h2>
                <p>AGameModeBase::FinishRestartPlayer에서 Possess 과정 이후의 로직을 확인합니다.</p>

                <h2>FinishRestartPlayer 전체 구조</h2>
                <div class="flow-vertical">
                    <div class="flow-node">FinishRestartPlayer</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Possess 실행</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Pawn 유효?</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Rotation 설정</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">SetPlayerDefaults</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">K2_OnRestartPlayer</div>
                </div>

                <h2>코드 분석</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// AController* NewPlayer, const FRotator& StartRotation

NewPlayer->Possess(NewPlayer->GetPawn());

if (!IsValid(NewPlayer->GetPawn()))
{
    FailedToRestartPlayer(NewPlayer);
}
else
{
    // Pawn의 Rotation 설정
    NewPlayer->ClientSetRotation(NewPlayer->GetPawn()->GetActorRotation(), true);

    FRotator NewControllerRot = StartRotation;
    NewControllerRot.Roll = 0.f;
    NewPlayer->SetControlRotation(NewControllerRot);

    // 폰의 초기값을 설정할 수 있도록 제공하는 함수
    SetPlayerDefaults(NewPlayer->GetPawn());

    K2_OnRestartPlayer(NewPlayer);
}</code></pre>
                </div>

                <h2>ClientSetRotation</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// FRotator NewRotation

SetControlRotation(NewRotation);
if (Pawn != NULL)
{
    Pawn->FaceRotation(NewRotation, 0.f);
}</code></pre>
                </div>

                <h2>FaceRotation 상세</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// FRotator NewControlRotation, float DeltaTime

if (bUseControllerRotationPitch || bUseControllerRotationYaw || bUseControllerRotationRoll)
{
    const FRotator CurrentRotation = GetActorRotation();

    if (!bUseControllerRotationPitch)
    {
        NewControlRotation.Pitch = CurrentRotation.Pitch;
    }

    if (!bUseControllerRotationYaw)
    {
        NewControlRotation.Yaw = CurrentRotation.Yaw;
    }

    if (!bUseControllerRotationRoll)
    {
        NewControlRotation.Roll = CurrentRotation.Roll;
    }

    SetActorRotation(NewControlRotation);
}</code></pre>
                </div>

                <h2>Rotation 플래그 동작</h2>
                <table>
                    <tr><th>플래그</th><th>True</th><th>False</th></tr>
                    <tr><td><strong>bUseControllerRotationPitch</strong></td><td>Controller의 Pitch 사용</td><td>Pawn의 Pitch 유지</td></tr>
                    <tr><td><strong>bUseControllerRotationYaw</strong></td><td>Controller의 Yaw 사용</td><td>Pawn의 Yaw 유지</td></tr>
                    <tr><td><strong>bUseControllerRotationRoll</strong></td><td>Controller의 Roll 사용</td><td>Pawn의 Roll 유지</td></tr>
                </table>

                <h2>실용적 예시</h2>
                <h3>3인칭 캐릭터</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// 일반적인 3인칭 설정
bUseControllerRotationPitch = false;
bUseControllerRotationYaw = false;    // 캐릭터가 자체 회전
bUseControllerRotationRoll = false;</code></pre>
                </div>

                <h3>1인칭 캐릭터</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">// 일반적인 1인칭 설정
bUseControllerRotationPitch = true;   // 위아래 볼 때
bUseControllerRotationYaw = true;     // 좌우 볼 때
bUseControllerRotationRoll = false;</code></pre>
                </div>

                <h2>SetPlayerDefaults</h2>
                <div class="callout tip">
                    <div class="callout-title">커스터마이징 포인트</div>
                    <p>폰의 초기값을 설정할 수 있도록 제공하는 함수</p>
                    <ul>
                        <li>GameMode에서 Override하여 구현</li>
                        <li>초기 체력, 스탯 등 설정 가능</li>
                        <li>시작 아이템 지급 등</li>
                    </ul>
                </div>

                <h2>커스터마이징 예시</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">void AMyGameMode::SetPlayerDefaults(APawn* PlayerPawn)
{
    Super::SetPlayerDefaults(PlayerPawn);

    if (AMyCharacter* MyCharacter = Cast<AMyCharacter>(PlayerPawn))
    {
        // 초기 체력 설정
        MyCharacter->SetHealth(100.0f);

        // 시작 무기 지급
        MyCharacter->GiveStartWeapon();

        // 초기 위치 미세 조정
        FVector Location = MyCharacter->GetActorLocation();
        Location.Z += 10.0f;
        MyCharacter->SetActorLocation(Location);
    }
}</code></pre>
                </div>

                <h2>Summary</h2>
                <table>
                    <tr><th>순서</th><th>작업</th><th>설명</th></tr>
                    <tr><td>1</td><td>Possess</td><td>빙의 실행</td></tr>
                    <tr><td>2</td><td>유효성 검사</td><td>Pawn 유효 여부 확인</td></tr>
                    <tr><td>3</td><td>ClientSetRotation</td><td>Controller/Pawn Rotation 설정</td></tr>
                    <tr><td>4</td><td>SetPlayerDefaults</td><td>초기값 설정 (Override 가능)</td></tr>
                    <tr><td>5</td><td>K2_OnRestartPlayer</td><td>Blueprint 이벤트</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['fw-sec30'] = {
            title: '월드 시작',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Framework</div>
                    <h1>월드 시작</h1>
                </div>
                <h2>Overview</h2>
                <p>UWorld::BeginPlay - World를 시작하는 BeginPlay입니다.</p>

                <h3>핵심 질문</h3>
                <ul>
                    <li>World를 시작하는 주체는 누구인가?</li>
                    <li>World를 시작한다는 것은 어떤 의미인가?</li>
                </ul>

                <h2>World 시작 프로세스</h2>
                <div class="flow-diagram">
                    <div class="flow-node">World</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">GameMode</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">GameState</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">WorldSettings</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">모든 Actor BeginPlay</div>
                </div>

                <h2>코드 분석</h2>
                <h3>UWorld::BeginPlay</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">AGameModeBase* const GameMode = GetAuthGameMode();
if (GameMode)
{
    // BeginPlay!
    GameMode->StartPlay();
}</code></pre>
                </div>

                <div class="callout important">
                    <div class="callout-title">World가 아닌 GameMode</div>
                    <p><strong>World의 시작은 World가 아닌 GameMode</strong>에서 진행됩니다!</p>
                </div>

                <h3>AGameModeBase::StartPlay</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">void AGameModeBase::StartPlay()
{
    GameState->HandleBeginPlay();
}</code></pre>
                </div>

                <h3>AGameStateBase::HandleBeginPlay</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">void AGameStateBase::HandleBeginPlay()
{
    bReplicatedHasBegunPlay = true;

    GetWorldSettings()->NotifyBeginPlay();
}</code></pre>
                </div>

                <h2>주목해야 할 2가지</h2>
                <h3>1️⃣ WorldSetting으로부터 시작되는 BeginPlay 로직</h3>
                <div class="callout important">
                    <div class="callout-title">Persistent Level의 WorldSettings</div>
                    <p><strong>매우 중요해서 절대 사라지지 않는</strong> Persistent Level에 WorldSettings이 존재하는 이유:</p>
                    <ul>
                        <li>WorldSettings가 없으면 <strong>World 시작이 안 됨</strong></li>
                        <li>반드시 존재해야 하는 핵심 Actor</li>
                    </ul>
                </div>

                <h3>2️⃣ GameMode로부터 시작되는 BeginPlay 로직</h3>
                <div class="callout tip">
                    <div class="callout-title">네트워크를 고려하라</div>
                    <p>그냥 World로부터 WorldSettings를 가져와서 시작하면 안 되나?</p>
                    <ul>
                        <li><strong>제일 먼저 시작되어야 할 World는 서버에 있는 World</strong></li>
                        <li>클라이언트가 먼저 World가 시작되면 뒤죽박죽</li>
                        <li><strong>GameMode는 서버에만 있음</strong> → 서버에서 Start 보장</li>
                    </ul>
                </div>

                <h2>WorldSettings의 NotifyBeginPlay</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <pre><code class="language-cpp">UWorld* World = GetWorld();
if (!World->GetBegunPlay())
{
    // World PreBeginPlay BroadCast
    World->OnWorldPreBeginPlay.Broadcast();

    // World에 있는 모든 Actor BeginPlay 호출
    for (FActorIterator It(World); It; ++It)
    {
        const bool bFromLevelLoad = true;
        It->DispatchBeginPlay(bFromLevelLoad);
    }

    World->SetBegunPlay(true);
}</code></pre>
                </div>

                <div class="callout important">
                    <div class="callout-title">실제 BeginPlay 실행</div>
                    <p><strong>World의 BeginPlay가 불린 적이 없다면</strong>:</p>
                    <ol>
                        <li>PreBeginPlay 이벤트 BroadCast</li>
                        <li>모든 Actor를 순회하며 BeginPlay 호출</li>
                        <li>BeginPlay flag를 true로 전환</li>
                    </ol>
                </div>

                <h2>역할 분담</h2>
                <table>
                    <tr><th>클래스</th><th>역할</th><th>이유</th></tr>
                    <tr><td><strong>UWorld</strong></td><td>시작 요청</td><td>진입점</td></tr>
                    <tr><td><strong>GameMode</strong></td><td>시작 오케스트레이션</td><td>서버에만 존재 → 서버 우선 보장</td></tr>
                    <tr><td><strong>GameState</strong></td><td>네트워크 동기화</td><td>클라이언트들에게 알림</td></tr>
                    <tr><td><strong>WorldSettings</strong></td><td>실제 실행</td><td>로직적 분리, Persistent Level 보장</td></tr>
                </table>

                <h2>네트워크 동작 원리</h2>
                <div class="flow-vertical">
                    <div class="flow-node">Server: GameMode</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Server: GameState</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">bReplicatedHasBegunPlay = true</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Client: GameState 복제</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Client: WorldSettings</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Client: BeginPlay 실행</div>
                </div>

                <h2>Summary</h2>
                <div class="callout tip">
                    <div class="callout-title">호출 체인</div>
                    <p><strong>World → GameMode → GameState → WorldSettings</strong></p>
                    <ol>
                        <li>UWorld::BeginPlay (진입점)</li>
                        <li>GameMode::StartPlay (서버 제어)</li>
                        <li>GameState::HandleBeginPlay (네트워크 동기화)</li>
                        <li>WorldSettings::NotifyBeginPlay (실제 실행)</li>
                        <li>모든 Actor BeginPlay 호출</li>
                    </ol>
                </div>

                <div class="callout">
                    <div class="callout-title">설계 이유</div>
                    <ul>
                        <li><strong>네트워크</strong>: 서버 우선 시작 보장</li>
                        <li><strong>안정성</strong>: WorldSettings 필수 존재</li>
                        <li><strong>확장성</strong>: 각 단계 Override 가능</li>
                        <li><strong>로직 분리</strong>: 책임 명확히 구분</li>
                    </ul>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        // ========================================
        // Tick: Tick 시스템 (3.43~3.54)
        // ========================================

        sectionData['tick-sec1'] = {
            title: '언리얼 Tick 방식 개념',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>언리얼 Tick 방식 개념</h1>
                </div>
                <h2>Overview</h2>
                <p>언리얼 엔진의 Tick 시스템은 일반적인 게임 엔진의 Tick 방식과 완전히 다르게 설계되어 있습니다. 이 문서에서는 언리얼 엔진이 왜 독특한 Tick 방식을 채택했는지, 그리고 그 핵심 개념들을 설명합니다.</p>

                <h2>Tick이 중요한 이유</h2>
                <p>Tick은 <strong>매 프레임 반복</strong>되기 때문에 게임의 핵심 로직을 처리합니다.</p>
                <ul>
                    <li>입력 처리</li>
                    <li>이동 및 애니메이션 업데이트</li>
                    <li>게임 로직 실행</li>
                    <li>물리 시뮬레이션</li>
                </ul>

                <h2>언리얼 엔진의 Tick 방식 특징</h2>
                <h3>기본 구조</h3>
                <p>언리얼에서 Tick을 사용하려면 다음 두 가지 조건이 필요합니다:</p>
                <ol>
                    <li><strong>TickFunction 구조체 소유</strong> - Tick 전용 구조체를 객체가 소유해야 함</li>
                    <li><strong>TickFunction 등록</strong> - TickFunction 구조체를 언리얼 Tick 시스템에 Register 해야 함</li>
                </ol>

                <h3>독립적인 Tick 소유</h3>
                <p>액터와 컴포넌트는 각자 독립적으로 TickFunction 구조체를 소유합니다.</p>
                <div class="hierarchy-box">Level
 ├── Actor0 ────────────────────────► TickFunction0
 │    ├── ActorComponent0 ─────────► TickFunction1
 │    └── ActorComponent1 ─────────► TickFunction2
 └── Actor1 ────────────────────────► TickFunction3
      └── ActorComponent2 ─────────► TickFunction4</div>

                <h2>핵심 개념: Tick의 주체는 TickFunction</h2>
                <div class="callout important">
                    <div class="callout-title">중요</div>
                    <p>액터의 Tick이 꺼져있어도 해당 액터의 컴포넌트 Tick은 동작할 수 있습니다. Tick은 액터 단위가 아닌 <strong>TickFunction 단위</strong>로 관리됩니다.</p>
                </div>

                <h2>언리얼이 이런 방식을 선택한 이유</h2>
                <h3>1. 모듈화 (Modularity)</h3>
                <h4>설계 질문: Tick을 어느 단위부터 구현할 것인가?</h4>
                <p><strong>UObject에 구현한다면?</strong></p>
                <ul>
                    <li>문제점: 월드에 배치되지 않는 UObject에도 Tick이 구현됨</li>
                    <li>결과: 불필요한 성능 오버헤드 발생</li>
                </ul>
                <p><strong>Actor에만 구현한다면?</strong></p>
                <ul>
                    <li>문제점: UStruct에서 Tick 기능을 수행하고 싶을 때 불가능</li>
                    <li>결과: 확장성 제한</li>
                </ul>
                <p><strong>해결책: TickFunction 생성</strong></p>
                <ul>
                    <li>필요한 곳에 직접 넣어서 사용</li>
                    <li>대표적인 예시: ActorComponent - UObject를 상속받지만 Tick 활성화 가능</li>
                </ul>

                <h3>2. 효율적인 Tick 활성화/비활성화</h3>
                <h4>일반적인 구현 방식의 문제점</h4>
                <pre><code class="language-cpp">// 일반적으로 생각하는 구현 방식
if(bShouldTick)
{
    Super::Tick(DeltaTime);
}</code></pre>
                <p><strong>문제점:</strong></p>
                <ul>
                    <li>매 프레임 조건 체크 오버헤드</li>
                    <li>flag가 false여도 Tick 함수는 계속 호출됨</li>
                    <li>flag와 상관없이 함수 호출 비용 발생</li>
                </ul>

                <h4>언리얼의 해결 방식</h4>
                <p>TickFunction을 TickTaskLevel 등록에서 제거하면:</p>
                <ul>
                    <li>✅ Tick 함수 자체가 호출되지 않음</li>
                    <li>✅ 불필요한 함수 호출 오버헤드 제거</li>
                    <li>✅ 성능 최적화</li>
                </ul>

                <h3>3. 선행조건 (Prerequisite)</h3>
                <p>언리얼 Tick 시스템은 Tick 실행 순서를 정밀하게 제어할 수 있습니다.</p>
                <p><strong>예시:</strong> A Component의 Tick이 실행되기 전에 B Component의 Tick이 먼저 실행되어야 한다는 선행조건 설정 가능</p>
                <p><strong>장점:</strong></p>
                <ul>
                    <li>복잡한 의존성 관계를 명확하게 표현</li>
                    <li>실행 순서 보장</li>
                    <li>버그 방지</li>
                </ul>

                <h2>요약</h2>
                <table>
                    <tr><th>특징</th><th>설명</th></tr>
                    <tr><td>독립적인 구조체</td><td>TickFunction을 필요한 곳에 추가</td></tr>
                    <tr><td>효율적인 제어</td><td>등록/해제로 실행 여부 관리</td></tr>
                    <tr><td>선행조건 지원</td><td>실행 순서를 명확하게 제어</td></tr>
                    <tr><td>모듈화</td><td>유연한 확장성 제공</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec2'] = {
            title: 'TickFunction 구조',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>TickFunction 구조</h1>
                </div>
                <h2>Overview</h2>
                <p>이 문서에서는 TickFunction이 어떤 방식으로 존재하고 Actor와 Component에서 어떻게 사용되는지 설명합니다.</p>

                <h2>개념 복습</h2>
                <h3>TickFunction의 분리 이유</h3>
                <div class="hierarchy-box">         Level─────────────────────────────────►TickTaskLevel
          │                                      │
          ├──Actor0────────────────────────────► ├──TickFunction0
          │   │                                  │
          │   ├──ActorComponent0───────────────► ├──TickFunction1
          │   │                                  │
          │   └──ActorComponent1───────────────► ├──TickFunction2
          │                                      │
          └──Actor1────────────────────────────► ├──TickFunction3
              │                                  │
              └──ActorComponent2───────────────► └──TickFunction4</div>

                <h3>핵심 특징</h3>
                <ul>
                    <li>Actor와 Component는 독립적으로 TickFunction을 보유</li>
                    <li>TickTaskLevel에 등록되어야 Tick이 진행됨</li>
                </ul>

                <h2>Actor의 Tick 시스템</h2>
                <h3>1. AActor 클래스의 TickFunction</h3>
                <p>Actor는 <code>PrimaryActorTick</code>이라는 FActorTickFunction 구조체를 소유합니다.</p>
                <pre><code class="language-cpp">class AActor : public UObject
{
    // Actor의 Tick을 담당하는 구조체
    UPROPERTY(EditDefaultsOnly, Category=Tick)
    struct FActorTickFunction PrimaryActorTick;
}</code></pre>

                <h3>2. FActorTickFunction 구조체</h3>
                <pre><code class="language-cpp">struct FActorTickFunction : public FTickFunction
{
    // Tick의 대상이 되는 Actor
    class AActor* Target;

    // Tick 실행 함수 (virtual이므로 커스터마이징 가능)
    virtual void ExecuteTick(
        float DeltaTime,
        ELevelTick TickType,
        ENamedThreads::Type CurrentThread,
        const FGraphEventRef& MyCompletionGraphEvent) override
    {
        if (IsValid(Target))
        {
            // Target Actor의 TickActor 호출
            Target->TickActor(
                DeltaTime * Target->CustomTimeDilation,
                TickType,
                *this
            );
        }
    }
};</code></pre>

                <h2>Component의 Tick 시스템</h2>
                <h3>1. UActorComponent 클래스의 TickFunction</h3>
                <pre><code class="language-cpp">class UActorComponent
{
    // Component의 Tick을 담당하는 구조체
    UPROPERTY(EditDefaultsOnly, Category="ComponentTick")
    struct FActorComponentTickFunction PrimaryComponentTick;
}</code></pre>

                <h3>2. FActorComponentTickFunction 구조체</h3>
                <pre><code class="language-cpp">struct FActorComponentTickFunction : public FTickFunction
{
    // Tick의 대상이 되는 ActorComponent
    class UActorComponent* Target;

    // Tick 실행 함수
    virtual void ExecuteTick(...) override
    {
        if (IsValid(Target))
        {
            Target->TickComponent(DilatedTime, TickType, this);
        }
    }
}</code></pre>

                <h2>Actor vs Component TickFunction 비교</h2>
                <table>
                    <tr><th>항목</th><th>Actor</th><th>Component</th></tr>
                    <tr><td>TickFunction 타입</td><td>FActorTickFunction</td><td>FActorComponentTickFunction</td></tr>
                    <tr><td>변수명</td><td>PrimaryActorTick</td><td>PrimaryComponentTick</td></tr>
                    <tr><td>Target 타입</td><td>AActor*</td><td>UActorComponent*</td></tr>
                    <tr><td>호출 함수</td><td>TickActor()</td><td>TickComponent()</td></tr>
                    <tr><td>공통점</td><td colspan="2">모두 FTickFunction 상속, ExecuteTick() virtual 함수 제공</td></tr>
                </table>

                <h2>TickFunction 계층 구조</h2>
                <div class="hierarchy-box">FTickFunction (기본 구조체)
├── FActorTickFunction
│   └── Target: AActor*
│   └── ExecuteTick() → TickActor()
│
└── FActorComponentTickFunction
    └── Target: UActorComponent*
    └── ExecuteTick() → TickComponent()</div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec3'] = {
            title: 'TickFunction - Flag',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>TickFunction - Flag</h1>
                </div>
                <h2>Overview</h2>
                <p>TickFunction의 Flag 설정값이 무엇을 의미하고, 어떻게 Tick 동작에 영향을 미치는지 설명합니다.</p>

                <h2>TickFunction의 주요 Flag</h2>
                <pre><code class="language-cpp">// 틱 사용 여부 - 틱이 작동할 수 있는가 없는가
uint8 bCanEverTick:1;

// 틱을 시작할 때 활성화된 상태로 시작할지 여부
// bCanEverTick이 true가 아니면 의미없음
uint8 bStartWithTickEnabled:1;</code></pre>

                <h2>Flag 의미 분석</h2>
                <h3>bCanEverTick</h3>
                <ul>
                    <li><strong>true</strong>: Tick 기능을 사용할 수 있는 권한 부여</li>
                    <li><strong>false</strong>: Tick 기능 완전히 비활성화</li>
                </ul>

                <h3>bStartWithTickEnabled</h3>
                <ul>
                    <li><strong>true</strong>: 게임 시작 시 Tick이 활성화된 상태로 시작</li>
                    <li><strong>false</strong>: 게임 시작 시 Tick이 비활성화 상태 (나중에 활성화 가능)</li>
                    <li><strong>전제조건</strong>: bCanEverTick이 true여야 의미가 있음</li>
                </ul>

                <h2>Flag 조합 결과표</h2>
                <table>
                    <tr><th>bCanEverTick</th><th>bStartWithTickEnabled</th><th>시작 시 Tick 활성화</th><th>Tick 사용 가능</th></tr>
                    <tr><td>true</td><td>true</td><td>✅ 활성화됨</td><td>✅ 사용 가능</td></tr>
                    <tr><td>true</td><td>false</td><td>❌ 비활성화됨</td><td>✅ 사용 가능</td></tr>
                    <tr><td>false</td><td>true</td><td>❌ 비활성화됨</td><td>❌ 사용 불가</td></tr>
                    <tr><td>false</td><td>false</td><td>❌ 비활성화됨</td><td>❌ 사용 불가</td></tr>
                </table>

                <h2>사용 시나리오</h2>
                <h3>시나리오 1: 일반적인 Tick 사용</h3>
                <pre><code class="language-cpp">// 게임 시작부터 매 프레임 Tick 실행
bCanEverTick = true;
bStartWithTickEnabled = true;</code></pre>
                <p><strong>활용</strong>: 플레이어 캐릭터, 지속적으로 업데이트가 필요한 오브젝트</p>

                <h3>시나리오 2: 조건부 Tick 활성화</h3>
                <pre><code class="language-cpp">// Tick 사용 가능하지만 시작 시에는 비활성화
bCanEverTick = true;
bStartWithTickEnabled = false;</code></pre>
                <p><strong>활용</strong>: 트리거 발동 시에만 동작하는 오브젝트, 최적화가 필요한 오브젝트</p>

                <h3>시나리오 3: Tick 완전 비활성화</h3>
                <pre><code class="language-cpp">// Tick을 전혀 사용하지 않음
bCanEverTick = false;</code></pre>
                <p><strong>활용</strong>: 정적 오브젝트, Tick이 필요 없는 데이터 컨테이너</p>

                <h2>중요한 규칙</h2>
                <h3>1. 우선순위</h3>
                <div class="hierarchy-box">bCanEverTick이 최우선
    ↓
bCanEverTick == false면 bStartWithTickEnabled 무시
    ↓
bCanEverTick == true일 때만 bStartWithTickEnabled 의미 있음</div>

                <h3>2. 성능 최적화</h3>
                <pre><code class="language-cpp">// 나쁜 예: Tick 함수 내부에서 조건 체크
void Tick(float DeltaTime)
{
    if (!bShouldTick) return; // 매 프레임 불필요한 호출
}

// 좋은 예: Flag로 제어
bCanEverTick = false; // 또는
SetTickFunctionEnable(false); // Tick 함수 자체가 호출되지 않음</code></pre>

                <h2>요약</h2>
                <table>
                    <tr><th>특징</th><th>설명</th></tr>
                    <tr><td>bCanEverTick</td><td>Tick 기능의 근본적인 활성화 여부</td></tr>
                    <tr><td>bStartWithTickEnabled</td><td>시작 시 Tick 활성화 상태 (bCanEverTick이 true일 때만 유효)</td></tr>
                    <tr><td>최적화 효과</td><td>Flag로 제어하면 함수 호출 자체를 방지</td></tr>
                    <tr><td>유연성</td><td>런타임에 동적으로 Tick 활성화/비활성화 가능</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec4'] = {
            title: 'TickFunction - State',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>TickFunction - State</h1>
                </div>
                <h2>Overview</h2>
                <p>TickFunction의 세 가지 상태(State)와 각 상태별 관리 방식을 설명합니다.</p>

                <h2>Tick의 세 가지 상태</h2>
                <pre><code class="language-cpp">struct FTickFunction
{
    enum class ETickState : uint8
    {
        Disabled,    // 비활성화
        Enabled,     // 활성화
        CoolingDown  // 일정 주기마다 발동
    };

    ETickState TickState;
    float TickInterval;  // 실행 주기 (0 이하면 매 프레임)
}</code></pre>

                <h3>1. Enabled (활성화)</h3>
                <ul>
                    <li><strong>의미</strong>: 일반적으로 매 프레임 실행되는 상태</li>
                    <li><strong>사용 사례</strong>: 플레이어 입력, 캐릭터 이동, 지속적인 업데이트</li>
                </ul>

                <h3>2. Disabled (비활성화)</h3>
                <ul>
                    <li><strong>의미</strong>: Tick이 잠시 멈춰있는 상태</li>
                    <li><strong>특징</strong>: 언제든 다시 활성화 가능</li>
                    <li><strong>사용 사례</strong>: 일시적으로 업데이트가 필요 없는 오브젝트</li>
                </ul>

                <h3>3. CoolingDown (쿨다운)</h3>
                <ul>
                    <li><strong>의미</strong>: 일정 주기마다 반복 실행되는 상태</li>
                    <li><strong>설정</strong>: TickInterval 값으로 주기 조절</li>
                    <li><strong>사용 사례</strong>: 주기적인 체크, 최적화가 필요한 로직</li>
                </ul>

                <h2>상태별 관리: TickTaskLevel</h2>
                <pre><code class="language-cpp">class FTickTaskLevel
{
    // 활성화된 TickFunction 집합
    TSet<FTickFunction*> AllEnabledTickFunctions;

    // 비활성화된 TickFunction 집합
    TSet<FTickFunction*> AllDisabledTickFunctions;

    // 리스케줄링 대기 목록 (배열)
    TArray<FTickScheduleDetails> TickFunctionsToReschedule;

    // CoolingDown 실행 목록 (LinkedList)
    FCoolingDownTickFunctionList AllCoolingDownTickFunctions;
}</code></pre>

                <h2>상태별 저장 구조</h2>
                <h3>Enabled 상태</h3>
                <pre><code class="language-cpp">TSet<FTickFunction*> AllEnabledTickFunctions</code></pre>
                <ul>
                    <li><strong>자료구조</strong>: Set</li>
                    <li><strong>이유</strong>: 중복 방지 (한 Tick에서 같은 TickFunction이 두 번 호출되는 문제 방지)</li>
                </ul>

                <h3>CoolingDown 상태</h3>
                <p><strong>두 가지 데이터 구조로 관리:</strong></p>
                <ul>
                    <li><strong>TickFunctionsToReschedule (Array)</strong>: 시간 주기가 짧은 순서대로 정렬, 스케줄링 대기</li>
                    <li><strong>AllCoolingDownTickFunctions (LinkedList)</strong>: 실제 실행 관리</li>
                </ul>

                <h2>상태 전환 다이어그램</h2>
                <div class="hierarchy-box">       SetTickFunctionEnable(true)
    ┌──────────────────────────────┐
    │                              │
    ▼                              │
[Enabled] ◄─────────► [Disabled]
    │                     │
    │ TickInterval > 0    │
    │                     │
    ▼                     │
[CoolingDown] ────────────┘
    │         주기 도달 후
    │         일시적 활성화
    └─────────────────────►</div>

                <h2>Set 자료구조 사용 이유</h2>
                <h3>문제 상황</h3>
                <pre><code class="language-cpp">// 배열을 사용한다면?
TArray<FTickFunction*> EnabledTicks;

// 문제: 실수로 같은 TickFunction이 두 번 추가될 수 있음
EnabledTicks.Add(MyTickFunction);  // 첫 번째 추가
EnabledTicks.Add(MyTickFunction);  // 실수로 중복 추가

// 결과: 한 프레임에 같은 Tick이 두 번 실행됨!</code></pre>

                <h3>해결책: Set 사용</h3>
                <pre><code class="language-cpp">TSet<FTickFunction*> AllEnabledTickFunctions;

// Set은 자동으로 중복을 방지
AllEnabledTickFunctions.Add(MyTickFunction);  // 추가됨
AllEnabledTickFunctions.Add(MyTickFunction);  // 무시됨 (이미 존재)</code></pre>

                <h2>요약</h2>
                <table>
                    <tr><th>상태</th><th>자료구조</th><th>실행 주기</th><th>사용 목적</th></tr>
                    <tr><td>Enabled</td><td>TSet</td><td>매 프레임</td><td>지속적 업데이트</td></tr>
                    <tr><td>Disabled</td><td>TSet</td><td>실행 안 함</td><td>일시적 정지</td></tr>
                    <tr><td>CoolingDown</td><td>Array + LinkedList</td><td>TickInterval 주기</td><td>주기적 실행</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec5'] = {
            title: 'TickFunction - Group',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>TickFunction - Group</h1>
                </div>
                <h2>Overview</h2>
                <p>Tick Group은 Tick이 진행되는 순서를 제어하는 시스템입니다.</p>

                <h2>Tick Group이란?</h2>
                <p><strong>정의</strong>: Tick이 진행되는 순서를 제어하는 방식</p>
                <h3>필요성 예시: 카메라 촬영</h3>
                <div class="hierarchy-box">올바른 순서:
1. 플레이어 이동
2. 카메라 촬영

잘못된 순서:
1. 카메라 촬영  ← 이전 프레임의 위치를 찍음!
2. 플레이어 이동</div>

                <h2>Tick Group의 종류 (8개)</h2>
                <h3>1. TG_PrePhysics</h3>
                <ul>
                    <li><strong>실행 시점</strong>: 물리 계산 전</li>
                    <li><strong>용도</strong>: 물리 계산에 필요한 데이터 준비</li>
                    <li><strong>예시</strong>: 입력에 따른 캐릭터 이동 벡터 계산</li>
                </ul>

                <h3>2. TG_StartPhysics (엔진 전용)</h3>
                <ul>
                    <li><strong>특징</strong>: 엔진 내부에서만 사용</li>
                    <li><strong>Hidden</strong>: 개발자가 직접 설정 불가</li>
                </ul>

                <h3>3. TG_DuringPhysics</h3>
                <ul>
                    <li><strong>실행 시점</strong>: 물리 시뮬레이션 진행 중</li>
                    <li><strong>특징</strong>: 물리와 병렬 처리 가능</li>
                    <li><strong>예시</strong>: UI 업데이트 로직</li>
                </ul>

                <h3>4. TG_EndPhysics (엔진 전용)</h3>
                <ul>
                    <li><strong>특징</strong>: 엔진 내부에서만 사용</li>
                    <li><strong>용도</strong>: 물리 계산 종료 처리</li>
                </ul>

                <h3>5. TG_PostPhysics</h3>
                <ul>
                    <li><strong>실행 시점</strong>: 물리 시뮬레이션 완료 후</li>
                    <li><strong>예시</strong>: 카메라가 캐릭터를 따라가는 로직</li>
                </ul>

                <h3>6. TG_PostUpdateWork</h3>
                <ul>
                    <li><strong>실행 시점</strong>: 모든 주요 업데이트 이후</li>
                    <li><strong>용도</strong>: 정리 작업, 후처리</li>
                </ul>

                <h3>7. TG_LastDemotable (엔진 전용)</h3>
                <ul>
                    <li><strong>용도</strong>: Tick Group 강등 시 마지막 방어선</li>
                </ul>

                <h3>8. TG_NewlySpawned (엔진 전용)</h3>
                <ul>
                    <li><strong>용도</strong>: 새로 스폰된 Actor의 1프레임 지연 제거</li>
                </ul>

                <h2>Tick Group 실행 순서</h2>
                <div class="hierarchy-box">┌─────────────────────────────────────────────┐
│  TG_PrePhysics                              │ ← 개발자 사용 가능
├─────────────────────────────────────────────┤
│  TG_StartPhysics                            │ ← 엔진 전용
├─────────────────────────────────────────────┤
│  TG_DuringPhysics                           │ ← 개발자 사용 가능
├─────────────────────────────────────────────┤
│  TG_EndPhysics                              │ ← 엔진 전용
├─────────────────────────────────────────────┤
│  TG_PostPhysics                             │ ← 개발자 사용 가능
├─────────────────────────────────────────────┤
│  TG_PostUpdateWork                          │ ← 개발자 사용 가능
├─────────────────────────────────────────────┤
│  TG_LastDemotable                           │ ← 엔진 전용
└─────────────────────────────────────────────┘
      ↓ (모든 Tick 완료 후)
┌─────────────────────────────────────────────┐
│  TG_NewlySpawned                            │ ← 엔진 전용
└─────────────────────────────────────────────┘</div>

                <h2>TickFunction에서의 Tick Group</h2>
                <pre><code class="language-cpp">struct FTickFunction
{
    // 시작 Tick Group (이상적인 실행 시점)
    TEnumAsByte<enum ETickingGroup> TickGroup;

    // 종료 Tick Group (반드시 완료되어야 하는 마지노선)
    TEnumAsByte<enum ETickingGroup> EndTickGroup;
}</code></pre>

                <h3>사용 예시</h3>
                <pre><code class="language-cpp">// 예시: Animation Tick Function
TickGroup = TG_PrePhysics;    // PrePhysics에서 시작하면 좋음
EndTickGroup = TG_PostPhysics; // 늦어도 PostPhysics에서는 반드시 실행

// 의미: PrePhysics에서 Tick이 호출되면 가장 좋지만,
//      안된다면 PostPhysics에서는 무조건 호출되어야 한다</code></pre>

                <h2>TickTaskSequencer의 2차원 배열</h2>
                <pre><code class="language-cpp">class FTickTaskSequencer
{
    // [시작 Tick Group][종료 Tick Group]
    TArray<FBaseGraphTask*> TickTasks[TG_MAX][TG_MAX];
    TArray<FBaseGraphTask*> HiPriTickTasks[TG_MAX][TG_MAX];
}</code></pre>

                <h3>중요한 규칙: 역행 불가</h3>
                <table>
                    <tr><th>시작 \\ 종료</th><th>PrePhysics</th><th>StartPhysics</th><th>EndPhysics</th></tr>
                    <tr><td>PrePhysics</td><td>✅</td><td>✅</td><td>✅</td></tr>
                    <tr><td>StartPhysics</td><td>❌ 불가</td><td>✅</td><td>✅</td></tr>
                    <tr><td>EndPhysics</td><td>❌ 불가</td><td>❌ 불가</td><td>✅</td></tr>
                </table>

                <h2>요약</h2>
                <table>
                    <tr><th>항목</th><th>설명</th></tr>
                    <tr><td>Tick Group 개수</td><td>8개 (개발자 4개, 엔진 전용 4개)</td></tr>
                    <tr><td>시작 Tick Group</td><td>이상적인 실행 시점</td></tr>
                    <tr><td>종료 Tick Group</td><td>보장되어야 하는 마지노선</td></tr>
                    <tr><td>2차원 배열</td><td>[시작][종료]로 우선순위 자동 관리</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec6'] = {
            title: 'TickFunction - Prerequisite',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>TickFunction - Prerequisite</h1>
                </div>
                <h2>Overview</h2>
                <p>TickFunction의 선행조건(Prerequisite) 시스템은 Tick 실행 순서를 보장하는 핵심 메커니즘입니다.</p>

                <h2>선행조건(Prerequisite)이란?</h2>
                <p>특정 TickFunction이 실행되기 전에 반드시 먼저 실행되어야 하는 다른 TickFunction을 지정하는 시스템입니다.</p>

                <h2>코드 구조</h2>
                <h3>FTickFunction의 선행조건 배열</h3>
                <pre><code class="language-cpp">struct FTickFunction
{
    // 해당 틱 발동 전에 선행으로 발동되어야 하는 FTickFunction 리스트
    TArray<struct FTickPrerequisite> Prerequisites;
}</code></pre>

                <h3>FTickPrerequisite 구조체</h3>
                <pre><code class="language-cpp">struct FTickPrerequisite
{
    // 선행 조건 대상자의 UObject (Valid 체크용)
    TWeakObjectPtr<class UObject> PrerequisiteObject;

    // 선행 조건 대상자의 TickFunction
    struct FTickFunction* PrerequisiteTickFunction;
}</code></pre>

                <h2>왜 PrerequisiteObject가 필요한가?</h2>
                <div class="callout important">
                    <div class="callout-title">FTickFunction은 소유자를 모른다!</div>
                    <p>FTickFunction은 소유자 정보를 가지고 있지 않습니다. 파생 클래스에서 Target으로 관리합니다.</p>
                </div>
                <ul>
                    <li><code>FActorTickFunction</code> → <code>AActor* Target</code></li>
                    <li><code>FActorComponentTickFunction</code> → <code>UActorComponent* Target</code></li>
                </ul>
                <p><strong>중요성</strong>: 선행조건을 가진 UObject가 중간에 사라지면 그 뒤 Tick이 영원히 안 불릴 수 있음 → WeakPtr로 Valid 체크</p>

                <h2>선행조건 등록 과정: AddPrerequisite</h2>
                <pre><code class="language-cpp">void FTickFunction::AddPrerequisite(
    UObject* TargetObject,
    FTickFunction& TargetTickFunction)
{
    // 1단계: Tick 사용 가능 여부 체크
    const bool bThisCanTick =
        (bCanEverTick || IsTickFunctionRegistered());
    const bool bTargetCanTick =
        (TargetTickFunction.bCanEverTick ||
         TargetTickFunction.IsTickFunctionRegistered());

    // 2단계: 선행 조건 추가
    if (bThisCanTick && bTargetCanTick)
    {
        Prerequisites.AddUnique(
            FTickPrerequisite(TargetObject, TargetTickFunction)
        );
    }
}</code></pre>

                <h2>사용 예시</h2>
                <h3>물리 Tick 선행조건</h3>
                <pre><code class="language-cpp">// World의 물리 Tick 설정
void UWorld::SetupPhysicsTickFunctions(float DeltaSeconds)
{
    // EndPhysics는 StartPhysics 이후에 실행되어야 함
    EndPhysicsTickFunction.AddPrerequisite(
        this,  // World 객체
        StartPhysicsTickFunction  // 선행 TickFunction
    );
}</code></pre>

                <h3>실무 활용 예시</h3>
                <pre><code class="language-cpp">// 카메라가 캐릭터를 따라가기
CameraComponent->AddTickPrerequisite(
    Character,
    Character->PrimaryActorTick
);
// 의미: 캐릭터 이동 → 카메라 업데이트 순서 보장

// 부모-자식 관계
ChildComponent->AddTickPrerequisite(
    ParentComponent,
    ParentComponent->PrimaryComponentTick
);
// 의미: 부모 처리 → 자식 처리 순서 보장</code></pre>

                <h2>선행조건 실행 흐름</h2>
                <div class="hierarchy-box">┌─────────────────────────────────────────┐
│ Tick 실행 요청                            │
└─────────────────┬───────────────────────┘
                  ↓
         ┌────────────────┐
         │ Prerequisites  │
         │  확인          │
         └────────┬───────┘
                  ↓
        선행 조건이 있는가?
                  │
      ┌───────────┴───────────┐
      ↓                       ↓
     있음                     없음
      │                       │
      ↓                       ↓
 선행 Tick 먼저 실행      바로 실행
      │
      ↓
 선행 Tick 완료 대기
      │
      ↓
 현재 Tick 실행</div>

                <h2>주의사항</h2>
                <h3>1. 순환 참조 방지</h3>
                <pre><code class="language-cpp">// 잘못된 예: 순환 참조
A->AddPrerequisite(B);
B->AddPrerequisite(A);
// → 무한 대기 발생!</code></pre>

                <h2>요약</h2>
                <table>
                    <tr><th>항목</th><th>설명</th></tr>
                    <tr><td>자료구조</td><td>TArray&lt;FTickPrerequisite&gt;</td></tr>
                    <tr><td>구성 요소</td><td>PrerequisiteObject (WeakPtr) + PrerequisiteTickFunction</td></tr>
                    <tr><td>목적</td><td>Tick 실행 순서 보장</td></tr>
                    <tr><td>안전장치</td><td>Valid 체크, 중복 방지, Tick 사용 가능 체크</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec7'] = {
            title: 'TickFunction - InternalData',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>TickFunction - InternalData</h1>
                </div>
                <h2>Overview</h2>
                <p>InternalData는 Tick 등록 이후 실제 실행에 필요한 데이터를 관리하는 구조체입니다.</p>

                <h2>InternalData란?</h2>
                <p>TickFunction에는 다양한 설정 정보(Tick Group, Tick Interval, Prerequisite)가 있지만, <strong>등록 과정에서 실제 값이 변경될 수 있습니다</strong>.</p>
                <p><strong>정의</strong>: Tick Register(등록) 단계 이후에 필요한 실제 실행 데이터를 모아놓은 구조체</p>

                <h2>FInternalData 구조체</h2>
                <pre><code class="language-cpp">struct FInternalData
{
    //========================================
    // Tick 등록 정보
    //========================================
    bool bRegistered : 1;  // 등록 여부

    //========================================
    // Tick Group 정보
    //========================================
    ETickingGroup ActualStartTickGroup;  // 실제 시작 그룹
    ETickingGroup ActualEndTickGroup;    // 실제 종료 그룹

    //========================================
    // CoolingDown 관련
    //========================================
    bool bWasInterval:1;        // CoolingDown 목록에 있는지
    float RelativeTickCooldown; // 상대적 Tick Cooldown
    FTickFunction* Next;        // LinkedList 다음 대상

    //========================================
    // Tick Task Level
    //========================================
    FTickTaskLevel* TickTaskLevel;

    //========================================
    // Tick Task 정보
    //========================================
    FBaseGraphTask* TaskPointer;
}</code></pre>

                <h2>주요 데이터 분류</h2>
                <h3>1. 실제 Tick Group</h3>
                <pre><code class="language-cpp">// FTickFunction의 설정값 (희망사항)
ETickingGroup TickGroup;

// FInternalData의 실제값 (확정값)
ETickingGroup ActualStartTickGroup;</code></pre>
                <p><strong>왜 분리하는가?</strong> 선행조건에 의해 Tick Group이 변경될 수 있음</p>

                <h3>2. CoolingDown 정보: RelativeTickCooldown</h3>
                <div class="hierarchy-box">AllCoolingDownTickFunctions (LinkedList)
 ┌─────────┬─────────┬─────────┐
 │ Tick0   │ Tick1   │ Tick2   │
 │ 5.0f    │ 12.0f   │ 18.0f   │
 └─────────┴─────────┴─────────┘
    절대시간  절대시간   절대시간

 ┌─────────┬─────────┬─────────┐
 │ Tick0   │ Tick1   │ Tick2   │
 │ 5.0f    │ 7.0f    │ 6.0f    │
 └─────────┴─────────┴─────────┘
    첫 번째  차이(상대) 차이(상대)</div>
                <p><strong>계산 방식:</strong></p>
                <ul>
                    <li>Tick0: 5.0f (첫 번째는 절대값)</li>
                    <li>Tick1: 12.0f - 5.0f = 7.0f</li>
                    <li>Tick2: 18.0f - 12.0f = 6.0f</li>
                </ul>

                <h3>3. TaskPointer</h3>
                <p>Tick이 최종 실행될 때는 <strong>Task 형태로 Wrapping</strong>됨 → 비동기 실행, 의존성 관리</p>

                <h2>게으른 초기화 패턴</h2>
                <pre><code class="language-cpp">TUniquePtr<FInternalData> InternalData;

// 등록 성공 시에만 할당
if (InternalData == nullptr)
{
    InternalData.Reset(new FInternalData());
}</code></pre>
                <p><strong>장점:</strong></p>
                <ul>
                    <li>메모리 효율: 필요할 때만 할당</li>
                    <li>명확한 상태 구분: InternalData가 있으면 등록됨</li>
                </ul>

                <h2>설정값 vs 실제값 비교</h2>
                <table>
                    <tr><th>항목</th><th>FTickFunction (설정값)</th><th>FInternalData (실제값)</th></tr>
                    <tr><td>Tick Group</td><td>TickGroup</td><td>ActualStartTickGroup</td></tr>
                    <tr><td>End Group</td><td>EndTickGroup</td><td>ActualEndTickGroup</td></tr>
                    <tr><td>등록 여부</td><td>-</td><td>bRegistered</td></tr>
                    <tr><td>Interval</td><td>TickInterval</td><td>RelativeTickCooldown</td></tr>
                </table>

                <h2>요약</h2>
                <table>
                    <tr><th>특징</th><th>설명</th></tr>
                    <tr><td>생성 시점</td><td>Tick 등록 성공 시</td></tr>
                    <tr><td>메모리 관리</td><td>UniquePtr (게으른 초기화)</td></tr>
                    <tr><td>주요 목적</td><td>등록 후 실제 실행 데이터 관리</td></tr>
                    <tr><td>설정 vs 실제</td><td>설정값이 실제 실행값으로 변환됨</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec8'] = {
            title: 'Tick 관리자 3대장',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>Tick 관리자 3대장</h1>
                </div>
                <h2>Overview</h2>
                <p>언리얼의 Tick 시스템은 세 가지 핵심 관리자로 구성됩니다. 각 관리자는 명확한 역할 분담을 통해 효율적인 Tick 관리를 실현합니다.</p>

                <h2>3대장 소개</h2>
                <div class="hierarchy-box">┌─────────────────────────────────────────┐
│        FTickTaskManager                 │  ← 최고 총괄 관리자
│       (Tick 시스템 총괄)                 │
└───────────────┬─────────────────────────┘
                │
        ┌───────┴───────┐
        ↓               ↓
┌───────────────┐ ┌────────────────────┐
│FTickTaskLevel │ │FTickTaskSequencer  │
│(저장 및 관리)   │ │(실행 및 스케줄링)    │
└───────────────┘ └────────────────────┘</div>

                <h2>1. TickTaskLevel</h2>
                <h3>역할</h3>
                <p><strong>등록된 모든 TickFunction을 관리하고 저장</strong></p>
                <ul>
                    <li>TickFunction 등록 / 해제</li>
                    <li>내부 상태 파악</li>
                    <li>효율적인 관리</li>
                </ul>

                <h3>핵심 데이터 구조</h3>
                <pre><code class="language-cpp">class FTickTaskLevel
{
    // 활성화된 TickFunction 집합
    TSet<FTickFunction*> AllEnabledTickFunctions;

    // 비활성화된 TickFunction 집합
    TSet<FTickFunction*> AllDisabledTickFunctions;

    // 리스케줄링 대기 목록 (배열)
    TArray<FTickScheduleDetails> TickFunctionsToReschedule;

    // 쿨다운 실행 목록 (LinkedList)
    FCoolingDownTickFunctionList AllCoolingDownTickFunctions;
}</code></pre>

                <h2>2. TickTaskSequencer</h2>
                <h3>역할</h3>
                <p><strong>TickFunction의 Tick을 실제로 실행</strong></p>

                <h3>핵심 데이터 구조</h3>
                <pre><code class="language-cpp">class FTickTaskSequencer
{
    // 높은 우선순위 TickTask 2차원 배열
    TArray<FBaseGraphTask*> HiPriTickTasks[TG_MAX][TG_MAX];

    // 기본 우선순위 TickTask 2차원 배열
    TArray<FBaseGraphTask*> TickTasks[TG_MAX][TG_MAX];

    // TickGroup 완료 이벤트
    TArray<FGraphEventRef> TickCompletionEvents[TG_MAX];
}</code></pre>

                <h2>3. TickTaskManager</h2>
                <h3>역할</h3>
                <p><strong>Tick 시스템 전체를 총괄하는 최고 수준의 매니저</strong></p>

                <div class="callout tip">
                    <div class="callout-title">Manager 패턴의 장점</div>
                    <p>Manager가 내부 모듈 관리 → 개발자는 Manager하고만 소통 → 복잡도 감소</p>
                </div>

                <h2>역할 비교표</h2>
                <table>
                    <tr><th>관리자</th><th>비유</th><th>주요 역할</th><th>핵심 데이터</th></tr>
                    <tr><td>TickTaskLevel</td><td>창고 관리자</td><td>TickFunction 저장 및 관리</td><td>Set (Enabled/Disabled)</td></tr>
                    <tr><td>TickTaskSequencer</td><td>현장 감독</td><td>Tick 실행 및 순서 제어</td><td>2차원 배열</td></tr>
                    <tr><td>TickTaskManager</td><td>CEO</td><td>전체 시스템 총괄</td><td>Level과 Sequencer 참조</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec9'] = {
            title: 'Tick 등록 과정',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>Tick 등록 과정</h1>
                </div>
                <h2>Overview</h2>
                <p>Tick 등록이 BeginPlay에서 이루어지는 이유와 전체 등록 과정을 설명합니다.</p>

                <h2>왜 BeginPlay에서 등록되는가?</h2>
                <div class="callout">
                    <div class="callout-title">BeginPlay의 정의</div>
                    <p>"BeginPlay는 월드가 시작되고 액터의 모든 컴포넌트의 등록과 속성이 초기화된 이후 시작될 때 한 번만 호출된다."</p>
                </div>

                <h2>Tick 등록 4단계</h2>
                <table>
                    <tr><th>단계</th><th>설명</th></tr>
                    <tr><td>1. Target 설정</td><td>Tick 함수가 누구를 기준으로 작동하는가</td></tr>
                    <tr><td>2. Tick 활성화 상태로 등록</td><td>TickState: Enabled</td></tr>
                    <tr><td>3. InternalData 생성</td><td>등록 이후 실제 실행 데이터</td></tr>
                    <tr><td>4. TickTaskLevel 저장</td><td>활성화 set에 TickFunction 저장</td></tr>
                </table>

                <h2>등록 흐름 다이어그램</h2>
                <div class="hierarchy-box">BeginPlay
    ↓
RegisterAllActorTickFunctions
    ↓
RegisterActorTickFunctions
    ↓
    ├─→ Target 설정
    ├─→ SetTickFunctionEnable (Enabled로)
    └─→ RegisterTickFunction
            ↓
            ├─→ InternalData 생성
            └─→ FTickTaskManager::AddTickFunction
                    ↓
                    FTickTaskLevel::AddTickFunction
                        ↓
                        AllEnabledTickFunctions.Add()</div>

                <h2>요약</h2>
                <table>
                    <tr><th>단계</th><th>설명</th><th>핵심 함수</th></tr>
                    <tr><td>BeginPlay</td><td>등록 시작</td><td>AActor::BeginPlay</td></tr>
                    <tr><td>Target 설정</td><td>Tick 대상 지정</td><td>PrimaryActorTick.Target = this</td></tr>
                    <tr><td>Enable 설정</td><td>활성화 상태로</td><td>SetTickFunctionEnable</td></tr>
                    <tr><td>등록</td><td>시스템에 추가</td><td>RegisterTickFunction</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec10'] = {
            title: 'Tick 처리 전체 과정',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>Tick 처리 전체 과정 (개념)</h1>
                </div>
                <h2>Overview</h2>
                <p>World로부터 시작하여 6개의 단계로 Tick이 처리됩니다.</p>

                <h2>Tick 처리 6단계</h2>
                <div class="hierarchy-box">┌──────────────────────────────────────────┐
│ 1. 물리 Tick 설정                          │
│  StartPhysicsTickFunction 등록             │
│  EndPhysicsTickFunction 등록               │
└────────────────┬─────────────────────────┘
                 ↓
┌──────────────────────────────────────────┐
│ 2. TickTasks 초기화                       │
│  2차원 배열 Reset                         │
└────────────────┬─────────────────────────┘
                 ↓
┌──────────────────────────────────────────┐
│ 3. 쿨타임 스케줄링                         │
│  Reschedule → CoolingDown 이동            │
└────────────────┬─────────────────────────┘
                 ↓
┌──────────────────────────────────────────┐
│ 4. TickTask 배정                          │
│  TickFunction → TickTask 변환             │
└────────────────┬─────────────────────────┘
                 ↓
┌──────────────────────────────────────────┐
│ 5. Tick 실행                              │
│  2차원 배열 순회                          │
└────────────────┬─────────────────────────┘
                 ↓
┌──────────────────────────────────────────┐
│ 6. Tick 마무리                            │
│  재스케줄링, 상태 정리                    │
└──────────────────────────────────────────┘</div>

                <h2>각 단계별 주요 함수</h2>
                <table>
                    <tr><th>단계</th><th>주요 함수</th><th>담당 클래스</th></tr>
                    <tr><td>1. 물리 Tick</td><td>SetupPhysicsTickFunctions</td><td>UWorld</td></tr>
                    <tr><td>2. 초기화</td><td>StartFrame</td><td>FTickTaskSequencer</td></tr>
                    <tr><td>3. 스케줄링</td><td>ScheduleTickFunctionCooldowns</td><td>FTickTaskLevel</td></tr>
                    <tr><td>4. 배정</td><td>QueueAllTicks</td><td>FTickTaskLevel</td></tr>
                    <tr><td>5. 실행</td><td>RunTickGroup</td><td>UWorld</td></tr>
                    <tr><td>6. 마무리</td><td>EndFrame</td><td>FTickTaskManager</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec11'] = {
            title: '월드 Tick',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>월드 Tick</h1>
                </div>
                <h2>Overview</h2>
                <p>Tick은 엔진에서 시작하여 World로 전달되며, World에서 6단계 처리를 시작합니다.</p>

                <h2>주요 Tick Group 순서</h2>
                <div class="hierarchy-box">1. TG_PrePhysics      ← 물리 전 처리
2. TG_StartPhysics    ← 물리 시작 (엔진 전용)
3. TG_DuringPhysics   ← 물리 중 병렬 처리
4. TG_EndPhysics      ← 물리 종료 (엔진 전용)
5. TG_PostPhysics     ← 물리 후 처리
   ↓
[TimerManager, TickableGameObject, Camera 처리]
   ↓
6. TG_PostUpdateWork  ← 모든 업데이트 후
7. TG_LastDemotable   ← 강등 처리 (엔진 전용)</div>

                <h2>UWorld::Tick 함수</h2>
                <pre><code class="language-cpp">if (bDoingActorTicks)
{
    // 1단계: 물리 Tick 설정
    SetupPhysicsTickFunctions(DeltaSeconds);

    // 2~4단계: 준비 작업
    FTickTaskManager::Get().StartFrame(
        this, DeltaSeconds, TickType, LevelsToTick
    );

    // 5단계: Tick 실행
    RunTickGroup(TG_PrePhysics);
    RunTickGroup(TG_StartPhysics);
    RunTickGroup(TG_DuringPhysics, false);  // 비차단
    RunTickGroup(TG_EndPhysics);
    RunTickGroup(TG_PostPhysics);
}

// 기타 Tick 처리
GetTimerManager().Tick(DeltaSeconds);
FTickableGameObject::TickObjects(...);

// 카메라 업데이트
for (PlayerController : Controllers)
{
    PlayerController->UpdateCameraManager(DeltaSeconds);
}

// 6단계: Tick 마무리
FTickTaskManagerInterface::Get().EndFrame();</code></pre>

                <h2>요약</h2>
                <table>
                    <tr><th>단계</th><th>함수</th><th>설명</th></tr>
                    <tr><td>준비</td><td>SetupPhysicsTickFunctions</td><td>물리 Tick 등록</td></tr>
                    <tr><td>준비</td><td>StartFrame</td><td>초기화, 스케줄링, 배정</td></tr>
                    <tr><td>실행</td><td>RunTickGroup × 7</td><td>Tick Group별 실행</td></tr>
                    <tr><td>기타</td><td>TimerManager, TickableGameObject</td><td>특수 Tick 처리</td></tr>
                    <tr><td>후처리</td><td>UpdateCameraManager</td><td>카메라 업데이트</td></tr>
                    <tr><td>마무리</td><td>EndFrame</td><td>정리 및 재스케줄링</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec12'] = {
            title: '물리 Tick 설정',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>첫 번째 - 물리 Tick 설정</h1>
                </div>
                <h2>Overview</h2>
                <p>물리 Tick 함수를 어떤 그룹으로, 어디에 등록하는지 설명합니다.</p>

                <h2>물리 Tick이 필요한 이유</h2>
                <p>물리 시뮬레이션의 시작과 끝을 <strong>World에서만 처리</strong>하기 위함</p>

                <h2>UWorld::SetupPhysicsTickFunctions</h2>
                <h3>1. 물리 TickFunction 기본 설정</h3>
                <pre><code class="language-cpp">// StartPhysicsTickFunction 설정
StartPhysicsTickFunction.bCanEverTick = true;
StartPhysicsTickFunction.Target = this;  // World

// EndPhysicsTickFunction 설정
EndPhysicsTickFunction.bCanEverTick = true;
EndPhysicsTickFunction.Target = this;  // World</code></pre>

                <h3>2. 등록 필요 여부 확인</h3>
                <pre><code class="language-cpp">bool bEnablePhysics = bShouldSimulatePhysics;

// 둘 중 하나라도 등록되지 않았는지 체크
bool bNeedToUpdateTickRegistration =
    (bEnablePhysics != StartPhysicsTickFunction.IsTickFunctionRegistered()) ||
    (bEnablePhysics != EndPhysicsTickFunction.IsTickFunctionRegistered());</code></pre>

                <h3>3. StartPhysicsTickFunction 등록</h3>
                <pre><code class="language-cpp">if (bEnablePhysics && !StartPhysicsTickFunction.IsTickFunctionRegistered())
{
    // Tick Group 설정
    StartPhysicsTickFunction.TickGroup = TG_StartPhysics;

    // PersistentLevel에 등록 (중요!)
    StartPhysicsTickFunction.RegisterTickFunction(PersistentLevel);
}</code></pre>

                <div class="callout important">
                    <div class="callout-title">PersistentLevel에 등록하는 이유</div>
                    <ul>
                        <li>Tick은 Level 단위(TickTaskLevel)로 관리됨</li>
                        <li>일반 Level은 Unload될 수 있음</li>
                        <li>물리 Tick이 사라지면 물리 동작 불가</li>
                        <li><strong>PersistentLevel은 게임 실행 중 절대 사라지지 않음</strong></li>
                    </ul>
                </div>

                <h3>4. EndPhysicsTickFunction 등록</h3>
                <pre><code class="language-cpp">if (bEnablePhysics && !EndPhysicsTickFunction.IsTickFunctionRegistered())
{
    // Tick Group 설정
    EndPhysicsTickFunction.TickGroup = TG_EndPhysics;

    // PersistentLevel에 등록
    EndPhysicsTickFunction.RegisterTickFunction(PersistentLevel);

    // 선행 조건 설정 (중요!)
    EndPhysicsTickFunction.AddPrerequisite(
        this,  // World
        StartPhysicsTickFunction  // 선행 TickFunction
    );
}</code></pre>

                <h2>물리 Tick 구조</h2>
                <div class="hierarchy-box">UWorld
 ├── StartPhysicsTickFunction
 │   ├── TickGroup: TG_StartPhysics
 │   ├── Target: UWorld
 │   ├── 등록 위치: PersistentLevel
 │   └── ExecuteTick() → StartPhysicsSim()
 │
 └── EndPhysicsTickFunction
     ├── TickGroup: TG_EndPhysics
     ├── Target: UWorld
     ├── 등록 위치: PersistentLevel
     ├── Prerequisite: StartPhysicsTickFunction
     └── ExecuteTick() → EndPhysicsSim()</div>

                <h2>물리 엔진: Chaos</h2>
                <ul>
                    <li>언리얼 4.27까지: NVIDIA PhysX</li>
                    <li>언리얼 5부터: 자체 개발 <strong>Chaos</strong> 물리 엔진</li>
                </ul>

                <h2>요약</h2>
                <table>
                    <tr><th>항목</th><th>StartPhysicsTickFunction</th><th>EndPhysicsTickFunction</th></tr>
                    <tr><td>Tick Group</td><td>TG_StartPhysics</td><td>TG_EndPhysics</td></tr>
                    <tr><td>Target</td><td>UWorld</td><td>UWorld</td></tr>
                    <tr><td>등록 위치</td><td>PersistentLevel</td><td>PersistentLevel</td></tr>
                    <tr><td>선행 조건</td><td>없음</td><td>StartPhysicsTickFunction</td></tr>
                    <tr><td>실행 함수</td><td>StartPhysicsSim()</td><td>EndPhysicsSim()</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec13'] = {
            title: 'TickTasks 초기화',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>두 번째 - TickTasks 초기화</h1>
                </div>
                <h2>Overview</h2>
                <p>TickTask 초기화는 <strong>Start 시점</strong>에 이루어지며, 다양한 배열을 초기화합니다.</p>

                <h2>FTickTaskManager::StartFrame</h2>
                <pre><code class="language-cpp">// Context 설정
Context.TickGroup = ETickingGroup(0);  // TickGroup Reset
Context.DeltaSeconds = InDeltaSeconds;
Context.TickType = InTickType;
Context.Thread = ENamedThreads::GameThread;
Context.World = InWorld;

bTickNewlySpawned = true;

// ========== 2단계: 초기화 ==========
TickTaskSequencer.StartFrame();

// Level 목록 저장
FillLevelList(LevelsToTick);</code></pre>

                <h2>FTickTaskSequencer::StartFrame</h2>
                <pre><code class="language-cpp">// 모든 Tick 관련 데이터 초기화
for (int32 Index = 0; Index < TG_MAX; Index++)
{
    // 1. TickCompletionEvents 초기화
    TickCompletionEvents[Index].Reset();

    for (int32 IndexInner = 0; IndexInner < TG_MAX; IndexInner++)
    {
        // 2. TickTasks 초기화
        TickTasks[Index][IndexInner].Reset();

        // 3. HiPriTickTasks 초기화
        HiPriTickTasks[Index][IndexInner].Reset();
    }
}

// 4. WaitForTickGroup 초기화
WaitForTickGroup = (ETickingGroup)0;</code></pre>

                <h2>초기화되는 배열 설명</h2>
                <h3>1. TickCompletionEvents</h3>
                <pre><code class="language-cpp">TArray<FGraphEventRef> TickCompletionEvents[TG_MAX];</code></pre>
                <p>각 Tick Group의 완료 여부를 확인하는 배열</p>

                <h3>2. TickTasks (2차원 배열)</h3>
                <pre><code class="language-cpp">TArray<FBaseGraphTask*> TickTasks[TG_MAX][TG_MAX];</code></pre>
                <p>[시작 Tick Group][종료 Tick Group] 형태로 관리</p>

                <h3>3. HiPriTickTasks (2차원 배열)</h3>
                <pre><code class="language-cpp">TArray<FBaseGraphTask*> HiPriTickTasks[TG_MAX][TG_MAX];</code></pre>
                <p>높은 우선순위 TickTask 저장, 일반 TickTasks보다 먼저 실행</p>

                <h2>왜 Start에서 초기화하는가?</h2>
                <div class="hierarchy-box">이전 프레임 End
    ↓
현재 프레임 Start  ← 여기서 초기화!
    ↓
Tick 배정 및 실행
    ↓
현재 프레임 End</div>
                <p><strong>이유:</strong> 깨끗한 상태에서 새 프레임 시작, 이전 프레임 데이터와 명확한 분리</p>

                <h2>초기화 흐름</h2>
                <div class="hierarchy-box">FTickTaskManager::StartFrame()
    ↓
WaitForCleanup() - 이전 프레임 잔여 처리
    ↓
TickTaskSequencer.StartFrame() - 배열 초기화
    │
    ├─→ TickCompletionEvents.Reset()
    ├─→ TickTasks.Reset()
    ├─→ HiPriTickTasks.Reset()
    └─→ WaitForTickGroup = 0
    ↓
FillLevelList() - Level 목록 수집</div>

                <h2>요약</h2>
                <table>
                    <tr><th>항목</th><th>설명</th><th>초기화 시점</th></tr>
                    <tr><td>TickCompletionEvents</td><td>Tick Group 완료 확인</td><td>Start</td></tr>
                    <tr><td>TickTasks</td><td>기본 우선순위 Task 배열</td><td>Start</td></tr>
                    <tr><td>HiPriTickTasks</td><td>높은 우선순위 Task 배열</td><td>Start</td></tr>
                    <tr><td>WaitForTickGroup</td><td>시작 Tick Group</td><td>Start (0으로)</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec14'] = {
            title: '쿨타임 스케줄링 (개념)',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>세 번째 - 쿨타임 스케줄링 (개념)</h1>
                </div>
                <h2>Overview</h2>
                <p>쿨타임 스케줄링은 대기 그룹의 TickFunction들을 실행 그룹으로 옮기는 로직입니다.</p>

                <h2>쿨타임 스케줄링이란?</h2>
                <p><strong>정의</strong>: <code>TickFunctionsToReschedule</code> → <code>AllCoolingDownTickFunctions</code>로 이동</p>

                <h2>두 가지 저장소</h2>
                <h3>TickFunctionsToReschedule (대기 그룹)</h3>
                <pre><code class="language-cpp">TArray<FTickScheduleDetails> TickFunctionsToReschedule;

struct FTickScheduleDetails
{
    FTickFunction* TickFunction;
    float Cooldown;  // 절대 시간 (현재 프레임 기준)
}</code></pre>
                <ul>
                    <li><strong>역할</strong>: Tick 실행을 위해 CoolingDown 배정을 기다리는 곳</li>
                    <li><strong>Cooldown 의미</strong>: 현재 프레임 기준 이 시간 후 실행</li>
                    <li><strong>특징</strong>: 한 번 정해지면 바뀌지 않는 <strong>절대적 시간</strong></li>
                </ul>

                <h3>AllCoolingDownTickFunctions (실행 그룹)</h3>
                <pre><code class="language-cpp">struct FCoolingDownTickFunctionList
{
    FTickFunction* Head;  // LinkedList
}

// InternalData의 정보
float RelativeTickCooldown;  // 상대 시간
FTickFunction* Next;         // 다음 TickFunction</code></pre>
                <ul>
                    <li><strong>역할</strong>: 시간이 된 TickFunction을 실행시켜주는 곳</li>
                    <li><strong>RelativeTickCooldown 의미</strong>: 내 앞 TickFunction으로부터 실행까지 남은 시간</li>
                    <li><strong>특징</strong>: <strong>상대적인 시간</strong></li>
                </ul>

                <h2>왜 상대 시간을 사용하는가?</h2>
                <h3>절대 시간 사용 시 문제점</h3>
                <div class="hierarchy-box">World Tick 시간: 5.0f

A - 3.0f  (TickInterval)
B - 8.0f
C - 10.0f

World Tick 3초 후 (모두 차감하는 경우):
A - 0.0f  (실행됨)
B - 5.0f  (3초 차감)
C - 7.0f  (3초 차감)

문제: 매 프레임 모든 TickFunction 순회하며 차감 → 엄청난 비용!</div>

                <h3>상대 시간 해결책</h3>
                <div class="hierarchy-box">AllCoolingDownTickFunctions (LinkedList)

Head → A(3.0f) → B(5.0f) → C(2.0f) → NULL
       절대시간   차이(상대)  차이(상대)

World Tick 3초 후:
Head → A(0.0f) → B(5.0f) → C(2.0f) → NULL
       실행됨     5초 남음    2초 남음

맨 앞 하나만 차감!  ← 효율적!</div>
                <p><strong>장점:</strong> 맨 앞 TickFunction의 상대 시간만 차감 → O(1) 시간 복잡도</p>

                <h2>스케줄링 과정: Two Cursor 방식</h2>
                <div class="hierarchy-box">1. Reschedule 배열을 정렬 (오름차순)
2. CumulativeCooldown = 0 (누적합 변수)
3. RescheduleIndex = 0 (Reschedule 배열 포인터)
4. ComparisonTickFunction = Head (CoolingDown 리스트 포인터)

while (둘 다 끝나지 않음)
{
    Reschedule 절대 시간 vs (누적합 + CoolingDown 상대 시간)

    if (Reschedule이 더 작음)
        → Reschedule 항목을 CoolingDown에 삽입
    else
        → 누적합 += 현재 CoolingDown 상대 시간
        → ComparisonTickFunction = Next
}

5. 남은 Reschedule 항목들을 CoolingDown 끝에 추가</div>

                <h2>요약</h2>
                <table>
                    <tr><th>개념</th><th>설명</th></tr>
                    <tr><td>절대 시간</td><td>현재 프레임 기준 실행 시간 (Reschedule)</td></tr>
                    <tr><td>상대 시간</td><td>이전 항목으로부터 차이 (CoolingDown)</td></tr>
                    <tr><td>누적합</td><td>상대 시간을 절대 시간으로 변환</td></tr>
                    <tr><td>Two Cursor</td><td>두 포인터로 병합 정렬</td></tr>
                    <tr><td>효율성</td><td>맨 앞 하나만 시간 차감 (O(1))</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec15'] = {
            title: '쿨타임 스케줄링 (코드)',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>세 번째 - 쿨타임 스케줄링 (코드)</h1>
                </div>
                <h2>Overview</h2>
                <p>쿨타임 스케줄링의 실제 코드 구현을 설명합니다.</p>

                <h2>FTickTaskLevel::ScheduleTickFunctionCooldowns</h2>
                <h3>1단계: Reschedule 정렬</h3>
                <pre><code class="language-cpp">// [4, 5, 1, 2] → [1, 2, 4, 5]
// CoolDown을 이용해서 오름차순 정렬
TickFunctionsToReschedule.Sort([](const FTickScheduleDetails& A, const FTickScheduleDetails& B)
{
    return A.Cooldown < B.Cooldown;
});</code></pre>

                <h3>2단계: 변수 초기화</h3>
                <pre><code class="language-cpp">// 시간 누적합 - CoolingDown 진행 기준
float CumulativeCooldown = 0.f;

// Reschedule에서 선택된 Index
int32 RescheduleIndex = 0;

// CoolingDownList에서 선택된 TickFunction
FTickFunction* ComparisonTickFunction = AllCoolingDownTickFunctions.Head;

// 이전 TickFunction 저장 (삽입을 위해 필요)
FTickFunction* PrevComparisonTickFunction = nullptr;</code></pre>

                <h3>3단계: Two Cursor 알고리즘</h3>
                <pre><code class="language-cpp">// 둘 중 하나라도 끝까지 가면 종료
while (ComparisonTickFunction && RescheduleIndex < TickFunctionsToReschedule.Num())
{
    const FTickScheduleDetails& ScheduleDetails = TickFunctionsToReschedule[RescheduleIndex];
    float CooldownTime = ScheduleDetails.Cooldown;

    // CoolingDown 누적시간 + 상대시간 vs Reschedule 절대시간 비교
    if ((CumulativeCooldown + ComparisonTickFunction->InternalData->RelativeTickCooldown) > CooldownTime)
    {
        // Reschedule이 더 작음 → 여기에 삽입
        // ... 삽입 로직 ...
        RescheduleIndex++;
    }
    else
    {
        // CoolingDown이 더 작음 → 누적합 계산 후 다음으로
        CumulativeCooldown += ComparisonTickFunction->InternalData->RelativeTickCooldown;
        PrevComparisonTickFunction = ComparisonTickFunction;
        ComparisonTickFunction = ComparisonTickFunction->InternalData->Next;
    }
}</code></pre>

                <h2>삽입 로직 상세</h2>
                <pre><code class="language-cpp">FTickFunction* TickFunctionToSchedule = ScheduleDetails.TickFunction;

// 1. 상대 시간 계산
float NewRelativeTickCooldown = CooldownTime - CumulativeCooldown;
TickFunctionToSchedule->InternalData->RelativeTickCooldown = NewRelativeTickCooldown;

// 2. LinkedList 연결
TickFunctionToSchedule->InternalData->Next = ComparisonTickFunction;

// 3. 이전 노드와 연결
if (PrevComparisonTickFunction)
{
    PrevComparisonTickFunction->InternalData->Next = TickFunctionToSchedule;
}
else
{
    // Head에 삽입
    AllCoolingDownTickFunctions.Head = TickFunctionToSchedule;
}

// 4. 다음 항목의 상대 시간 조정
if (ComparisonTickFunction)
{
    ComparisonTickFunction->InternalData->RelativeTickCooldown -= NewRelativeTickCooldown;
}

// 5. 누적합 갱신
CumulativeCooldown += NewRelativeTickCooldown;</code></pre>

                <h2>예시로 이해하기</h2>
                <div class="hierarchy-box">초기 상태:
Reschedule: [1.5f, 4.0f]
CoolingDown: Head → 1.0f → 2.0f → NULL

Step 1:
비교: (0 + 1.0f) vs 1.5f → 1.0f < 1.5f → CoolingDown 먼저
CumulativeCooldown = 1.0f

Step 2:
비교: (1.0f + 2.0f) vs 1.5f → 3.0f > 1.5f → Reschedule 삽입!
삽입 위치: 1.0f 다음, 새 상대시간: 0.5f

결과: Head → 1.0f → 0.5f → 1.5f → NULL
            기존    삽입    조정됨</div>

                <h2>요약</h2>
                <table>
                    <tr><th>단계</th><th>설명</th><th>핵심 변수</th></tr>
                    <tr><td>1. 정렬</td><td>Reschedule 오름차순 정렬</td><td>Sort()</td></tr>
                    <tr><td>2. 초기화</td><td>변수 설정</td><td>CumulativeCooldown, Indexes</td></tr>
                    <tr><td>3. 병합</td><td>Two Cursor 알고리즘</td><td>누적합 vs 절대시간</td></tr>
                    <tr><td>4. 추가</td><td>남은 항목 끝에 추가</td><td>for loop</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec16'] = {
            title: '쿨타임 활성화',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>네 번째 - 쿨타임 활성화</h1>
                </div>
                <h2>Overview</h2>
                <p>AllCoolingDownTickFunctions에서 누적 시간을 활용하여 실행될 TickFunction을 활성화합니다.</p>

                <h2>개념</h2>
                <ul>
                    <li>현재 DeltaTime으로부터 실행되어야 할 TickFunction 활성화</li>
                    <li>실행되지 않을 TickFunction의 RelativeTickCooldown 수정</li>
                </ul>

                <h2>FTickTaskLevel::StartFrame</h2>
                <pre><code class="language-cpp">// 누적 시간 변수
float CumulativeCooldown = 0.f;
FTickFunction* TickFunction = AllCoolingDownTickFunctions.Head;

while (TickFunction)
{
    // 누적 시간 + 상대 시간 >= DeltaSeconds?
    if (CumulativeCooldown + TickFunction->InternalData->RelativeTickCooldown >= Context.DeltaSeconds)
    {
        // 실행 안 될 TickFunction → 상대 시간 갱신하고 종료
        TickFunction->InternalData->RelativeTickCooldown -= (Context.DeltaSeconds - CumulativeCooldown);
        break;
    }

    // 누적 시간 계산
    CumulativeCooldown += TickFunction->InternalData->RelativeTickCooldown;

    // CoolingDown → Enable로 변경
    TickFunction->TickState = FTickFunction::ETickState::Enabled;
    TickFunction = TickFunction->InternalData->Next;
}</code></pre>

                <h2>로직 설명</h2>
                <h3>Case 1: 실행 안 됨 (조건 참)</h3>
                <div class="hierarchy-box">CumulativeCooldown = 0.4초
RelativeTickCooldown = 0.8초
Context.DeltaSeconds = 1.0초

누적 + 상대 = 0.4 + 0.8 = 1.2초
DeltaSeconds = 1.0초
→ 1.2 >= 1.0 (참)
→ 아직 실행 안 됨!

처리: 다음 프레임을 위해 시간 보정
0.8 -= (1.0 - 0.4) = 0.2초 (다음 프레임에 0.2초만 더 지나면 실행)</div>

                <h3>Case 2: 실행됨 (조건 거짓)</h3>
                <div class="hierarchy-box">누적 + 상대 < DeltaSeconds
→ 충분한 시간이 흘렀음
→ 실행!

처리:
1. 누적 시간 증가
2. Enable 상태로 변경
3. 다음 TickFunction으로 이동</div>

                <h2>예시로 이해하기</h2>
                <div class="hierarchy-box">Context.DeltaSeconds = 1.5초
CoolingDown: Head → 0.5초 → 0.6초 → 0.8초 → NULL

TickFunction 1 (0.5초):
0 + 0.5 >= 1.5? → 거짓 → 실행! (CumulativeCooldown = 0.5)

TickFunction 2 (0.6초):
0.5 + 0.6 >= 1.5? → 1.1 < 1.5 → 실행! (CumulativeCooldown = 1.1)

TickFunction 3 (0.8초):
1.1 + 0.8 >= 1.5? → 1.9 >= 1.5 → 실행 안 됨!
시간 보정: 0.8 - (1.5 - 1.1) = 0.4초 (다음 프레임까지 남은 시간)

결과: TickFunction 1, 2 실행됨, TickFunction 3 대기 중 (0.4초 남음)</div>

                <h2>상태 전환</h2>
                <div class="flow-vertical">
                    <div class="flow-node">AllCoolingDownTickFunctions (CoolingDown)</div>
                    <span class="flow-arrow">↓</span>
                    <div class="flow-node">시간 도달</div>
                    <span class="flow-arrow">↓</span>
                    <div class="flow-node">TickState = Enabled</div>
                    <span class="flow-arrow">↓</span>
                    <div class="flow-node">AllEnabledTickFunctions (Enabled)</div>
                </div>

                <h2>요약</h2>
                <table>
                    <tr><th>단계</th><th>조건</th><th>처리</th></tr>
                    <tr><td>실행 가능</td><td>누적 + 상대 < DeltaTime</td><td>Enable 전환, 누적 증가</td></tr>
                    <tr><td>실행 불가</td><td>누적 + 상대 >= DeltaTime</td><td>시간 보정, break</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec17'] = {
            title: 'TickTask와 TickGroup 배정',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>다섯 번째 - TickTask와 TickGroup 배정 개념</h1>
                </div>
                <h2>Overview</h2>
                <p>QueueTickFunction 함수의 네 가지 역할을 통해 TickTask를 배정하는 과정을 설명합니다.</p>

                <h2>QueueTickFunction의 네 가지 역할</h2>
                <h3>1. 선행 TickFunction 재귀적 배정</h3>
                <pre><code class="language-cpp">for (int32 PrereqIndex = 0; PrereqIndex < Prerequisites.Num(); PrereqIndex++)
{
    Prereq->QueueTickFunction(TTS, TickContext);  // 재귀 호출
}</code></pre>
                <ul>
                    <li>선행 조건을 먼저 처리</li>
                    <li>재귀적으로 선행의 선행까지 모두 처리</li>
                    <li>무한 루프 방지: <code>TickVisitedGFrameCounter</code></li>
                </ul>

                <h3>2. 최대 선행 TickGroup 찾기</h3>
                <pre><code class="language-cpp">ETickingGroup MaxPrerequisiteTickGroup = ETickingGroup(0);

for (Prerequisites)
{
    Prereq->QueueTickFunction(TTS, TickContext);

    // 선행 조건 중 가장 느린 TickGroup 찾기
    MaxPrerequisiteTickGroup = FMath::Max(
        MaxPrerequisiteTickGroup,
        Prereq->InternalData->ActualStartTickGroup
    );
}</code></pre>

                <h3>3. 최종 TickGroup 결정</h3>
                <pre><code class="language-cpp">// 나의 TickGroup과 MaxPrerequisiteTickGroup 중 느린 것 선택
ETickingGroup MyActualTickGroup = FMath::Max(
    MaxPrerequisiteTickGroup,
    FMath::Max(TickGroup, TickContext.TickGroup)
);

// 특수 TickGroup(StartPhysics, EndPhysics)은 강등 불가
while (!CanDemoteIntoTickGroup(MyActualTickGroup))
{
    MyActualTickGroup = ETickingGroup(MyActualTickGroup + 1);
}

// 실제 TickGroup 설정
InternalData->ActualStartTickGroup = MyActualTickGroup;</code></pre>

                <h3>4. TickTask로 Wrapping 및 배정</h3>
                <pre><code class="language-cpp">if (TickState == FTickFunction::ETickState::Enabled)
{
    // TickTask 형태로 변환 및 TickTaskSequencer에 배정
    TTS.QueueOrBatchTickTask(RawPrerequisites, this, TickContext);
}</code></pre>

                <h2>선행 조건에 의한 TickGroup 변경</h2>
                <div class="hierarchy-box">Component A:
    TickGroup = PrePhysics
    Prerequisite = 없음
    → ActualStartTickGroup = PrePhysics

Component B:
    TickGroup = PrePhysics
    Prerequisite = Component C (TickGroup = PostPhysics)
    → ActualStartTickGroup = PostPhysics (선행 조건 때문에 변경!)</div>

                <h2>특수 TickGroup 방어</h2>
                <pre><code class="language-cpp">bool CanDemoteIntoTickGroup(ETickingGroup TickGroup)
{
    // StartPhysics와 EndPhysics는 사용 불가
    return (TickGroup != TG_StartPhysics) &&
           (TickGroup != TG_EndPhysics);
}</code></pre>
                <p><strong>이유</strong>: 물리 시뮬레이션의 정확성과 일관성 보장</p>

                <h2>2차원 배열 배정 원리</h2>
                <pre><code class="language-cpp">TickTasks[시작 Tick Group][종료 Tick Group]

예시:
    StartTickGroup = PrePhysics (0)
    EndTickGroup = PostPhysics (4)
    → TickTasks[0][4]에 배정</code></pre>

                <h2>전체 흐름</h2>
                <div class="hierarchy-box">FTickTaskLevel::QueueAllTicks()
    ↓
for each EnabledTickFunction
    ↓
FTickFunction::QueueTickFunction()
    │
    ├─→ 1. 선행 조건 재귀 처리
    ├─→ 2. MaxPrerequisiteTickGroup 찾기
    ├─→ 3. ActualTickGroup 결정
    └─→ 4. TickTask 생성 및 배정
            │
            ├─→ FTickGraphTask 생성
            └─→ TickTasks[start][end].Add(Task)</div>

                <h2>요약</h2>
                <table>
                    <tr><th>역할</th><th>설명</th><th>핵심 변수</th></tr>
                    <tr><td>1. 선행 처리</td><td>재귀적으로 선행 조건 먼저 배정</td><td>Prerequisites</td></tr>
                    <tr><td>2. Group 찾기</td><td>가장 느린 선행 TickGroup 찾기</td><td>MaxPrerequisiteTickGroup</td></tr>
                    <tr><td>3. Group 결정</td><td>최종 ActualTickGroup 결정</td><td>ActualStartTickGroup</td></tr>
                    <tr><td>4. Task 배정</td><td>TickTask로 변환 및 배정</td><td>TickTasks[start][end]</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec18'] = {
            title: 'TickTask의 틱 실행',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>다섯 번째 - TickTask의 틱 실행</h1>
                </div>
                <h2>Overview</h2>
                <p>배정된 TickTask를 실제로 실행하는 과정을 설명합니다.</p>

                <h2>UWorld::RunTickGroup</h2>
                <pre><code class="language-cpp">// TickTaskManager에 위임
FTickTaskManagerInterface::Get().RunTickGroup(Group, bBlockTillComplete);

// 다음 TickGroup로 이동
TickGroup = ETickingGroup(TickGroup + 1);</code></pre>

                <h2>FTickTaskSequencer::ReleaseTickGroup</h2>
                <h3>DispatchTickGroup</h3>
                <pre><code class="language-cpp">// 높은 우선순위 먼저 처리
for (int32 IndexInner = 0; IndexInner < TG_MAX; IndexInner++)
{
    TArray<FTickGraphTask*>& TickArray = HiPriTickTasks[WorldTickGroup][IndexInner];

    // 역행 순서 체크 (Start > End는 불가능)
    if (IndexInner < WorldTickGroup)
    {
        check(TickArray.Num() == 0);  // 있으면 Crash
    }
    else
    {
        // Unlock: GameThread의 TaskQueue에 전달
        for (int32 Index = 0; Index < TickArray.Num(); Index++)
        {
            TickArray[Index]->Unlock(CurrentThread);
        }
    }

    TickArray.Reset();  // 배열 초기화
}

// 동일한 로직으로 TickTasks 처리
// ...</code></pre>

                <h2>실제 Tick 실행: FTickFunctionTask::DoTask</h2>
                <pre><code class="language-cpp">if (Target->IsTickFunctionEnabled())
{
    Target->ExecuteTick(
        Target->CalculateDeltaTime(Context.DeltaSeconds, Context.World),
        Context.TickType,
        CurrentThread,
        MyCompletionGraphEvent
    );
}</code></pre>

                <h2>FActorTickFunction::ExecuteTick</h2>
                <pre><code class="language-cpp">if (IsValid(Target))
{
    if (TickType != LEVELTICK_ViewportsOnly || Target->ShouldTickIfViewportsOnly())
    {
        FScopeCycleCounterUObject ActorScope(Target);

        // 최종적으로 Actor의 TickActor 호출!
        Target->TickActor(
            DeltaTime * Target->CustomTimeDilation,
            TickType,
            *this
        );
    }
}</code></pre>

                <h2>50개 기준의 이유</h2>
                <div class="hierarchy-box">50개 미만: 즉시 정리 (빠름)
50개 이상: 다음 프레임에 정리 (프레임 드랍 방지)

이유: 한 프레임에 너무 많은 Task를 정리하면 프레임 드랍 발생 가능</div>

                <h2>실행 흐름 요약</h2>
                <div class="hierarchy-box">UWorld::RunTickGroup(TG_PrePhysics)
    ↓
FTickTaskManager::RunTickGroup()
    ↓
FTickTaskSequencer::ReleaseTickGroup()
    │
    ├─→ DispatchTickGroup()
    │   │
    │   ├─→ HiPriTickTasks[PrePhysics][X] 순회
    │   │   └─→ Unlock() → GameThread Queue
    │   │
    │   └─→ TickTasks[PrePhysics][X] 순회
    │       └─→ Unlock() → GameThread Queue
    │
    └─→ WaitUntilTasksComplete()
            │
            └─→ FTickFunctionTask::DoTask()
                    │
                    └─→ ExecuteTick()
                            │
                            └─→ TickActor() / TickComponent()</div>

                <h2>우선순위 실행 순서</h2>
                <div class="hierarchy-box">1. HiPriTickTasks[PrePhysics][PrePhysics]
2. HiPriTickTasks[PrePhysics][StartPhysics]
3. HiPriTickTasks[PrePhysics][PostPhysics]
4. ...
5. TickTasks[PrePhysics][PrePhysics]
6. TickTasks[PrePhysics][StartPhysics]
7. ...</div>

                <h2>요약</h2>
                <table>
                    <tr><th>단계</th><th>함수</th><th>설명</th></tr>
                    <tr><td>1. 요청</td><td>UWorld::RunTickGroup</td><td>TickGroup 실행 요청</td></tr>
                    <tr><td>2. 위임</td><td>FTickTaskManager::RunTickGroup</td><td>Manager에 위임</td></tr>
                    <tr><td>3. 배포</td><td>DispatchTickGroup</td><td>GameThread Queue에 Task 추가</td></tr>
                    <tr><td>4. 실행</td><td>DoTask</td><td>실제 Tick 함수 호출</td></tr>
                    <tr><td>5. 대기</td><td>WaitUntilTasksComplete</td><td>완료 대기</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec19'] = {
            title: 'Tick 마무리',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>여섯 번째 - Tick 마무리</h1>
                </div>
                <h2>Overview</h2>
                <p>Tick 처리가 끝난 후 다음 프레임을 준비하기 위한 마무리 과정을 설명합니다.</p>

                <h2>FTickTaskManager::EndFrame</h2>
                <pre><code class="language-cpp">// TickTaskSequencer 정리
TickTaskSequencer.EndFrame();

// NewlySpawned flag 초기화
bTickNewlySpawned = false;

// 모든 Level 정리
for( int32 LevelIndex = 0; LevelIndex < LevelList.Num(); LevelIndex++ )
{
    LevelList[LevelIndex]->EndFrame();
}

// World Context 정리
Context.World = nullptr;
LevelList.Reset();</code></pre>

                <h2>왜 TickTasks는 초기화하지 않는가?</h2>
                <div class="hierarchy-box">TickTasks는 Start 시점에 초기화됩니다.

이전 프레임 End
    ↓ (TickTasks는 여기서 초기화 안 함)
현재 프레임 Start  ← TickTasks 초기화!
    ↓
Tick 실행
    ↓
현재 프레임 End  ← 다른 것들 정리</div>

                <h2>FTickTaskLevel::EndFrame</h2>
                <pre><code class="language-cpp">// CoolingDown에서 시간 보상해준 부분이 있어서 다시 계산
ScheduleTickFunctionCooldowns();</code></pre>
                <p><strong>왜 다시 스케줄링하는가?</strong> CoolingDown 활성화 단계에서 시간 보정이 발생했기 때문</p>

                <h2>Tick 한 사이클 완료</h2>
                <div class="hierarchy-box">┌──────────────────────────────────────┐
│ 1. 물리 Tick 설정                      │
├──────────────────────────────────────┤
│ 2. TickTasks 초기화                   │
├──────────────────────────────────────┤
│ 3. 쿨타임 스케줄링                     │
├──────────────────────────────────────┤
│ 4. 쿨타임 활성화                       │
├──────────────────────────────────────┤
│ 5. TickTask 배정 및 실행              │
├──────────────────────────────────────┤
│ 6. Tick 마무리  ← 지금 여기!          │
│    - 재스케줄링                       │
│    - Context 정리                     │
│    - LevelList 정리                   │
└──────────────────────────────────────┘
         ↓
┌──────────────────────────────────────┐
│ 다음 프레임 1. 물리 Tick 설정         │
└──────────────────────────────────────┘</div>

                <h2>초기화 vs 정리 비교</h2>
                <table>
                    <tr><th>항목</th><th>Start (초기화)</th><th>End (정리)</th></tr>
                    <tr><td>TickTasks</td><td>초기화</td><td>정리 안 함</td></tr>
                    <tr><td>TickCompletionEvents</td><td>초기화</td><td>정리 안 함</td></tr>
                    <tr><td>CoolingDown</td><td>스케줄링</td><td>재스케줄링</td></tr>
                    <tr><td>Context</td><td>설정</td><td>정리</td></tr>
                    <tr><td>LevelList</td><td>채움</td><td>정리</td></tr>
                    <tr><td>bTickNewlySpawned</td><td>true</td><td>false</td></tr>
                </table>

                <h2>요약</h2>
                <table>
                    <tr><th>작업</th><th>클래스</th><th>함수</th><th>목적</th></tr>
                    <tr><td>재스케줄링</td><td>FTickTaskLevel</td><td>ScheduleTickFunctionCooldowns</td><td>시간 보정 반영</td></tr>
                    <tr><td>Context 정리</td><td>FTickTaskManager</td><td>EndFrame</td><td>다음 프레임 준비</td></tr>
                    <tr><td>LevelList 정리</td><td>FTickTaskManager</td><td>EndFrame</td><td>메모리 정리</td></tr>
                    <tr><td>Flag 초기화</td><td>FTickTaskManager</td><td>EndFrame</td><td>bTickNewlySpawned = false</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['tick-sec20'] = {
            title: 'Tick 제거',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Tick</div>
                    <h1>Tick 제거</h1>
                </div>
                <h2>Overview</h2>
                <p>등록된 Tick을 제거하는 방식과 등록 과정과의 차이점을 설명합니다.</p>

                <h2>Tick 제거 시작점</h2>
                <pre><code class="language-cpp">// AActor::RegisterActorTickFunctions
// bRegister = false로 호출
if(bRegister)
{
    // 등록 로직
}
else
{
    // 제거 로직
    if(PrimaryActorTick.IsTickFunctionRegistered())
    {
        PrimaryActorTick.UnRegisterTickFunction();
    }
}</code></pre>

                <h2>FTickFunction::UnRegisterTickFunction</h2>
                <pre><code class="language-cpp">if (IsTickFunctionRegistered())
{
    // 1. TickTaskManager에 제거 요청
    FTickTaskManager::Get().RemoveTickFunction(this);

    // 2. InternalData 등록 flag = false
    InternalData->bRegistered = false;
}</code></pre>

                <h2>FTickTaskLevel::RemoveTickFunction</h2>
                <h3>상태별 처리</h3>
                <pre><code class="language-cpp">switch(TickFunction->TickState)
{
    case FTickFunction::ETickState::Enabled:
        // 가장 복잡한 경우
        break;

    case FTickFunction::ETickState::Disabled:
        // 간단한 경우
        break;

    case FTickFunction::ETickState::CoolingDown:
        // Enabled와 유사
        break;
}</code></pre>

                <h2>Enabled 상태 제거 (복잡)</h2>
                <div class="callout warning">
                    <div class="callout-title">왜 복잡한가?</div>
                    <p>Enabled TickFunction은 여러 곳에 있을 수 있음:</p>
                    <ul>
                        <li>AllEnabledTickFunctions</li>
                        <li>TickFunctionsToReschedule</li>
                        <li>AllCoolingDownTickFunctions</li>
                    </ul>
                </div>

                <pre><code class="language-cpp">case FTickFunction::ETickState::Enabled:
{
    if (TickFunction->InternalData->bWasInterval)
    {
        // 1. AllEnabledTickFunctions 시도
        if (AllEnabledTickFunctions.Remove(TickFunction) == 0)
        {
            // 2. TickFunctionsToReschedule 검색
            int32 Index = TickFunctionsToReschedule.IndexOfByPredicate(...);
            if (Index != INDEX_NONE)
            {
                TickFunctionsToReschedule.RemoveAtSwap(Index);
            }

            // 3. AllCoolingDownTickFunctions 검색 (LinkedList)
            while (ComparisonFunction && !bFound)
            {
                if (ComparisonFunction == TickFunction)
                {
                    // LinkedList에서 제거
                    // ...
                }
            }
        }
    }
    else
    {
        // bWasInterval이 false면 AllEnabledTickFunctions에만 있음
        verify(AllEnabledTickFunctions.Remove(TickFunction) == 1);
    }
    break;
}</code></pre>

                <h2>Disabled 상태 제거 (간단)</h2>
                <pre><code class="language-cpp">case FTickFunction::ETickState::Disabled:
{
    // AllDisabledTickFunctions에만 있음
    verify(AllDisabledTickFunctions.Remove(TickFunction) == 1);
    break;
}</code></pre>
                <p><strong>간단한 이유</strong>: 한 곳에만 있기 때문</p>

                <h2>제거 흐름 다이어그램</h2>
                <div class="hierarchy-box">Actor/Component Destroy
    ↓
RegisterActorTickFunctions(false)
    ↓
UnRegisterTickFunction()
    │
    ├─→ RemoveTickFunction(Manager)
    │   │
    │   └─→ RemoveTickFunction(Level)
    │       │
    │       ├─→ Enabled?
    │       │   ├─→ bWasInterval?
    │       │   │   ├─→ AllEnabledTickFunctions
    │       │   │   ├─→ TickFunctionsToReschedule
    │       │   │   └─→ AllCoolingDownTickFunctions
    │       │   └─→ AllEnabledTickFunctions만
    │       │
    │       ├─→ Disabled?
    │       │   └─→ AllDisabledTickFunctions
    │       │
    │       └─→ CoolingDown?
    │           └─→ (Enabled와 동일)
    │
    └─→ InternalData->bRegistered = false</div>

                <h2>등록 vs 제거 비교</h2>
                <table>
                    <tr><th>단계</th><th>등록</th><th>제거</th></tr>
                    <tr><td>시작</td><td>RegisterTickFunction</td><td>UnRegisterTickFunction</td></tr>
                    <tr><td>Manager</td><td>AddTickFunction</td><td>RemoveTickFunction</td></tr>
                    <tr><td>Level</td><td>AddTickFunction</td><td>RemoveTickFunction</td></tr>
                    <tr><td>상태별</td><td>Enable/Disable 구분</td><td>Enable/Disable/CoolingDown 구분</td></tr>
                    <tr><td>복잡도</td><td>간단</td><td>복잡 (위치 찾기 필요)</td></tr>
                    <tr><td>Flag</td><td>bRegistered = true</td><td>bRegistered = false</td></tr>
                </table>

                <h2>요약</h2>
                <table>
                    <tr><th>항목</th><th>설명</th></tr>
                    <tr><td>시작점</td><td>UnRegisterTickFunction</td></tr>
                    <tr><td>Manager</td><td>TickTaskLevel에 위임</td></tr>
                    <tr><td>Enabled</td><td>복잡 (3곳 확인)</td></tr>
                    <tr><td>Disabled</td><td>간단 (1곳)</td></tr>
                    <tr><td>CoolingDown</td><td>복잡 (Enabled와 동일)</td></tr>
                    <tr><td>최종</td><td>bRegistered = false</td></tr>
                </table>
                <p><strong>핵심</strong>: 제거는 등록보다 복잡 (위치 찾기 필요)</p>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        // ========================================
        // Component: 컴포넌트 시스템 (4.66~4.72)
        // ========================================

        sectionData['comp-sec1'] = {
            title: 'ActorComponent 개념',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Component</div>
                    <h1>ActorComponent 개념</h1>
                </div>
                <h2>Overview</h2>
                <p>ActorComponent는 Actor의 기능을 <strong>모듈화</strong>하여 구현하는 언리얼 엔진의 핵심 아키텍처입니다. Actor 자체는 기능이 없고, Component가 모든 기능을 담당합니다.</p>

                <h2>Actor와 Component의 관계</h2>
                <h3>Actor vs UObject</h3>
                <table>
                    <tr><th>구분</th><th>UObject</th><th>AActor</th></tr>
                    <tr><td>World 배치</td><td>불가능</td><td>가능</td></tr>
                    <tr><td>핵심 차이</td><td>기본 객체</td><td>Component 보유</td></tr>
                    <tr><td>RootComponent</td><td>없음</td><td>USceneComponent 보유</td></tr>
                </table>

                <pre><code class="language-cpp">// AActor의 핵심 구조
class AActor
{
    // World에 배치하기 위한 필수 컴포넌트
    UPROPERTY()
    USceneComponent* RootComponent;
};</code></pre>

                <h3>RootComponent의 중요성</h3>
                <ul>
                    <li><strong>AActor</strong>에는 <strong>RootComponent</strong>(USceneComponent)가 존재</li>
                    <li>RootComponent가 없으면 <strong>World에 배치 불가능</strong></li>
                    <li>Actor 자체의 기능은 없고, <strong>Component가 모든 기능을 담당</strong></li>
                </ul>

                <pre><code class="language-cpp">// Character 예시
ACharacter::ACharacter(const FObjectInitializer& ObjectInitializer)
{
    // CapsuleComponent가 RootComponent
    RootComponent = CapsuleComponent;

    // Mesh는 CapsuleComponent에 부착
    Mesh = CreateOptionalDefaultSubobject&lt;USkeletalMeshComponent&gt;(...);
    Mesh->SetupAttachment(CapsuleComponent);
}</code></pre>

                <h2>전통적인 상속 방식의 문제점</h2>
                <h3>시나리오: RPG 게임 캐릭터 설계</h3>
                <p><strong>초기 설계:</strong> 전사(공격, 방어), 도적(은신, 함정), 마법사(마법, 비행)</p>

                <pre><code class="language-cpp">// 상속 기반 설계
class Warrior : public Character
{
    void Attack();
    void Defend();
};

class Rogue : public Character
{
    void Stealth();
    void SetTrap();
};

class Mage : public Character
{
    void CastMagic();
    void Fly();
};</code></pre>

                <h4>요구사항 변경: 마검사 추가</h4>
                <pre><code class="language-cpp">// 다중 상속 문제 발생
class MagicWarrior : public Warrior, public Mage
{
    // 다중 상속의 복잡성 증가
};</code></pre>

                <div class="callout warning">
                    <div class="callout-title">상속 방식의 문제점</div>
                    <ul>
                        <li>수많은 예외 처리로 코드 복잡도 증가</li>
                        <li>유지보수 어려움</li>
                        <li>확장성 부족</li>
                    </ul>
                </div>

                <h2>Component 방식의 우수성</h2>
                <pre><code class="language-cpp">// Component 조립 방식
class RPGCharacter : public ACharacter
{
    UPROPERTY()
    UAttackComponent* AttackComp;

    UPROPERTY()
    UDefendComponent* DefendComp;

    UPROPERTY()
    UStealthComponent* StealthComp;

    UPROPERTY()
    UMagicComponent* MagicComp;

    UPROPERTY()
    UFlyComponent* FlyComp;
};</code></pre>

                <h3>Component 조립으로 캐릭터 생성</h3>
                <table>
                    <tr><th>캐릭터</th><th>Component 구성</th></tr>
                    <tr><td>전사</td><td>AttackComp + DefendComp</td></tr>
                    <tr><td>도적</td><td>StealthComp + TrapComp</td></tr>
                    <tr><td>마법사</td><td>MagicComp + FlyComp</td></tr>
                    <tr><td>마검사</td><td>AttackComp + DefendComp + MagicComp + FlyComp</td></tr>
                </table>

                <div class="callout tip">
                    <div class="callout-title">Component 방식의 장점</div>
                    <ul>
                        <li>Component를 붙였다 떼는 것만으로 기능 조합 가능</li>
                        <li>Actor Class는 하나만 필요</li>
                        <li>예외 처리 불필요</li>
                        <li>높은 재사용성과 확장성</li>
                    </ul>
                </div>

                <h2>런타임 Component 추가/제거</h2>
                <pre><code class="language-cpp">// 런타임에 Component 추가
void ACharacter::LearnFlyAbility()
{
    UFlyComponent* NewFlyComp = NewObject&lt;UFlyComponent&gt;(this);
    NewFlyComp->RegisterComponent();
}

// 런타임에 Component 제거
void ACharacter::LoseFlyAbility()
{
    if (FlyComp)
    {
        FlyComp->DestroyComponent();
        FlyComp = nullptr;
    }
}</code></pre>

                <h2>핵심 정리</h2>
                <div class="callout important">
                    <div class="callout-title">Component 방식의 핵심</div>
                    <ol>
                        <li><strong>Actor 자체는 빈 껍데기</strong>, Component가 실제 기능 담당</li>
                        <li><strong>RootComponent</strong>가 있어야 World 배치 가능</li>
                        <li><strong>모듈화</strong>를 통한 높은 재사용성과 유연성</li>
                        <li><strong>상속의 복잡성</strong>을 피하고 <strong>조립(Composition)</strong> 방식 사용</li>
                    </ol>
                </div>

                <h3>Component 설계 원칙</h3>
                <ul>
                    <li>하나의 Component는 하나의 책임만 담당 (Single Responsibility)</li>
                    <li>Component 간 결합도는 낮게, 응집도는 높게</li>
                    <li>재사용 가능한 단위로 설계</li>
                </ul>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['comp-sec2'] = {
            title: 'SceneComponent 개념',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Component</div>
                    <h1>SceneComponent 개념</h1>
                </div>
                <h2>Overview</h2>
                <p>SceneComponent는 <strong>Transform 정보</strong>를 가지고 있어 World에서 위치, 회전, 크기를 표현하며, <strong>계층 구조(Hierarchy)</strong>를 구성하여 부모-자식 관계를 형성합니다.</p>

                <h2>Component 계층 구조</h2>
                <div class="flow-vertical">
                    <div class="flow-node">UObject</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">UActorComponent (Transform 없음)</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--accent); color: #fff;">USceneComponent (Transform + 계층)</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">UPrimitiveComponent (렌더링 + 충돌)</div>
                </div>

                <h2>Transform 정보 관리</h2>
                <pre><code class="language-cpp">// USceneComponent 내부 구조
class USceneComponent : public UActorComponent
{
    /** World 공간에서의 현재 Transform */
    FTransform ComponentToWorld;

    /** 부모 기준 상대 위치 */
    FVector RelativeLocation;

    /** 부모 기준 상대 회전 */
    FRotator RelativeRotation;

    /** 부모 기준 상대 스케일 */
    FVector RelativeScale3D;
};</code></pre>

                <h3>Transform의 두 가지 좌표계</h3>
                <table>
                    <tr><th>좌표계</th><th>설명</th><th>용도</th></tr>
                    <tr><td><strong>World Transform</strong></td><td>World 원점 기준 절대 좌표</td><td>실제 렌더링 위치</td></tr>
                    <tr><td><strong>Relative Transform</strong></td><td>부모 Component 기준 상대 좌표</td><td>계층 구조 유지</td></tr>
                </table>

                <pre><code class="language-cpp">// World 좌표 계산
// World 좌표 = 상대 좌표 × 부모 World 좌표
// ComponentToWorld = RelativeTransform * ParentToWorld</code></pre>

                <h2>계층 구조 (Hierarchy)</h2>
                <h3>계층 구조 멤버 변수</h3>
                <pre><code class="language-cpp">class USceneComponent : public UActorComponent
{
    /** 현재 부착된 부모 Component */
    UPROPERTY(ReplicatedUsing = OnRep_AttachParent)
    TObjectPtr&lt;USceneComponent&gt; AttachParent;

    /** 이 Component에 부착된 자식 Component 목록 */
    UPROPERTY(ReplicatedUsing = OnRep_AttachChildren, Transient)
    TArray&lt;TObjectPtr&lt;USceneComponent&gt;&gt; AttachChildren;

    /** 부모의 어느 소켓에 부착되었는지 */
    FName AttachSocketName;
};</code></pre>

                <h3>계층 구조 예시</h3>
                <div class="hierarchy-box">[Character Actor]
│
└─ RootComponent (CapsuleComponent)
    ├─ Mesh (SkeletalMeshComponent)
    │   ├─ Weapon (StaticMeshComponent) [Socket: "hand_r"]
    │   └─ Shield (StaticMeshComponent) [Socket: "hand_l"]
    │
    └─ Camera (UCameraComponent)
        └─ SpringArm (USpringArmComponent)</div>

                <pre><code class="language-cpp">ACharacter::ACharacter()
{
    // RootComponent 설정
    RootComponent = CreateDefaultSubobject&lt;UCapsuleComponent&gt;(TEXT("Capsule"));

    // Mesh를 RootComponent에 부착
    Mesh = CreateDefaultSubobject&lt;USkeletalMeshComponent&gt;(TEXT("Mesh"));
    Mesh->SetupAttachment(RootComponent);

    // Camera를 RootComponent에 부착
    Camera = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT("Camera"));
    Camera->SetupAttachment(RootComponent);
}</code></pre>

                <h2>부모가 이동하면 자식도 따라 이동</h2>
                <div class="hierarchy-box">[초기 상태]
Parent: World (100, 0, 0)
Child: Relative (10, 0, 0) → World (110, 0, 0)

[부모 이동 후]
Parent: World (200, 0, 0)
Child: Relative (10, 0, 0) → World (210, 0, 0)  // 자동 갱신!</div>

                <pre><code class="language-cpp">// ❌ 나쁜 방식: 절대 좌표만 사용
void AttachWeapon()
{
    // 캐릭터가 움직일 때마다 무기 위치를 수동으로 갱신해야 함
    WeaponLocation = CharacterLocation + Offset;
}

// ✅ 좋은 방식: 상대 좌표 사용
void AttachWeapon()
{
    // 한 번만 설정하면 자동으로 따라다님
    Weapon->SetupAttachment(Mesh, TEXT("hand_r"));
    Weapon->SetRelativeLocation(FVector(10, 0, 0));
}</code></pre>

                <h2>Mobility (이동성)</h2>
                <table>
                    <tr><th>Mobility</th><th>설명</th><th>용도</th></tr>
                    <tr><td><strong>Static</strong></td><td>게임 중 이동 불가</td><td>건물, 지형</td></tr>
                    <tr><td><strong>Stationary</strong></td><td>회전/스케일만 가능</td><td>라이트</td></tr>
                    <tr><td><strong>Movable</strong></td><td>모든 Transform 변경 가능</td><td>캐릭터, 동적 객체</td></tr>
                </table>

                <h2>절대 좌표 사용 옵션</h2>
                <pre><code class="language-cpp">class USceneComponent
{
    /** World 좌표를 직접 사용 (부모 무시) */
    uint8 bAbsoluteLocation : 1;
    uint8 bAbsoluteRotation : 1;
    uint8 bAbsoluteScale : 1;
};

// UI Component는 부모의 회전에 영향받지 않도록 설정
UIComponent->SetUsingAbsoluteRotation(true);</code></pre>

                <h2>핵심 정리</h2>
                <div class="callout important">
                    <div class="callout-title">SceneComponent의 핵심 역할</div>
                    <ol>
                        <li><strong>Transform 정보</strong> 보유 (위치, 회전, 크기)</li>
                        <li><strong>계층 구조</strong> 구성 (부모-자식 관계)</li>
                        <li><strong>World 좌표</strong>와 <strong>상대 좌표</strong> 자동 계산</li>
                        <li><strong>Mobility</strong> 설정으로 최적화 가능</li>
                    </ol>
                </div>

                <table>
                    <tr><th>특징</th><th>설명</th></tr>
                    <tr><td>ComponentToWorld</td><td>World 기준 절대 Transform</td></tr>
                    <tr><td>AttachParent</td><td>부모 Component 참조</td></tr>
                    <tr><td>AttachChildren</td><td>자식 Component 배열</td></tr>
                    <tr><td>Relative Transform</td><td>부모 기준 상대 Transform</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['comp-sec3'] = {
            title: '컴포넌트 연결 초기 설정',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Component</div>
                    <h1>컴포넌트 연결 초기 설정 (SetupAttachment)</h1>
                </div>
                <h2>Overview</h2>
                <p>SetupAttachment는 <strong>생성자에서만 사용</strong>하는 Component 계층 관계 설정 함수입니다. 등록(Register) 전에만 동작하며, 이후에는 AttachToComponent를 사용해야 합니다.</p>

                <h2>SetupAttachment vs AttachToComponent</h2>
                <table>
                    <tr><th>구분</th><th>SetupAttachment</th><th>AttachToComponent</th></tr>
                    <tr><td><strong>사용 시점</strong></td><td>생성자 (Constructor)</td><td>런타임 (Runtime)</td></tr>
                    <tr><td><strong>등록 여부</strong></td><td>등록 전 (Before Register)</td><td>등록 후 (After Register)</td></tr>
                    <tr><td><strong>동작</strong></td><td>관계만 설정</td><td>실제 연결 + Transform 계산</td></tr>
                    <tr><td><strong>Transform 갱신</strong></td><td>❌ 없음</td><td>✅ 즉시 갱신</td></tr>
                    <tr><td><strong>Overlap 체크</strong></td><td>❌ 없음</td><td>✅ 수행</td></tr>
                </table>

                <h3>사용 예시</h3>
                <pre><code class="language-cpp">// ✅ 올바른 사용 - 생성자에서
ACharacter::ACharacter(const FObjectInitializer& ObjectInitializer)
{
    RootComponent = CapsuleComponent;

    Mesh = CreateOptionalDefaultSubobject&lt;USkeletalMeshComponent&gt;(TEXT("Mesh"));

    // SetupAttachment: 생성자에서 부모-자식 관계만 설정
    Mesh->SetupAttachment(CapsuleComponent);
}

// ❌ 잘못된 사용 - 런타임에서
void ACharacter::BeginPlay()
{
    Super::BeginPlay();

    // 이미 등록된 상태에서는 동작하지 않음!
    Mesh->SetupAttachment(NewParent);  // ❌ 동작 안 함

    // 런타임에서는 AttachToComponent 사용
    Mesh->AttachToComponent(NewParent, ...);  // ✅ 올바름
}</code></pre>

                <h2>SetupAttachment 로직 흐름</h2>
                <div class="flow-vertical">
                    <div class="flow-node">SetupAttachment 호출</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">검사 1: 부모가 동일한가?</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">검사 2: 등록되었는가? ⭐</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">검사 3: 자기 자신인가?</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">검사 4: 순환 참조?</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">검사 5: 이미 연결됨?</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--success); color: #fff;">부모-자식 관계 설정</div>
                </div>

                <h2>소스 코드 분석</h2>
                <pre><code class="language-cpp">void USceneComponent::SetupAttachment(
    USceneComponent* InParent,
    FName InSocketName)
{
    // 1️⃣ 부모가 동일하면 연결 안 함
    if (InParent != AttachParent || InSocketName != AttachSocketName)
    {
        // 2️⃣ SetupAttachment는 등록 전에만 사용 가능!
        if (!bRegistered)
        {
            // 3️⃣ 재귀적으로 부착 방지 (자기 자신에게 부착 불가)
            if (InParent != this)
            {
                // 4️⃣ 순환 참조 방지
                if (InParent == nullptr || !InParent->IsAttachedTo(this))
                {
                    // 5️⃣ 이전 연결 상태 확인
                    if (AttachParent == nullptr ||
                        !AttachParent->AttachChildren.Contains(this))
                    {
                        // ✅ 모든 조건 통과: 단순 설정만 진행
                        SetAttachParent(InParent);
                        SetAttachSocketName(InSocketName);
                        SetShouldBeAttached(AttachParent != nullptr);
                    }
                }
            }
        }
    }
}</code></pre>

                <h2>검사 단계 상세 설명</h2>

                <h3>검사 2: 등록(Register) 여부 확인 ⭐ 가장 중요!</h3>
                <div class="callout warning">
                    <div class="callout-title">왜 등록 전에만 사용해야 하는가?</div>
                    <ul>
                        <li>Component가 등록되면 World, PhysicsScene, RenderThread 등과 <strong>이미 연결</strong>됨</li>
                        <li>이 상태에서 단순히 관계만 설정하면 <strong>데이터 불일치</strong> 발생</li>
                        <li>Transform, Overlap, Physics 등 <strong>모든 시스템을 갱신</strong>해야 하는데, SetupAttachment는 그런 기능이 없음</li>
                    </ul>
                </div>

                <h3>검사 4: 순환 참조 방지</h3>
                <pre><code class="language-cpp">bool USceneComponent::IsAttachedTo(const USceneComponent* TestComp) const
{
    if (TestComp != nullptr)
    {
        // 부모를 쭉 타고 올라가면서 TestComp가 있는지 확인
        for (const USceneComponent* Comp = this->GetAttachParent();
             Comp != nullptr;
             Comp = Comp->GetAttachParent())
        {
            if (TestComp == Comp)
            {
                return true;  // 찾음!
            }
        }
    }
    return false;
}</code></pre>

                <div class="hierarchy-box">현재 계층:
RootComponent
└─ MeshComponent
    └─ WeaponComponent

// ❌ 불가능한 시도
RootComponent->SetupAttachment(WeaponComponent);

// 검사 과정:
// WeaponComponent.IsAttachedTo(RootComponent) 호출
// WeaponComponent → MeshComponent → RootComponent (발견!)
// 결과: 순환 참조 방지를 위해 실패</div>

                <h2>실제 연결은 OnRegister에서</h2>
                <pre><code class="language-cpp">void USceneComponent::OnRegister()
{
    Super::OnRegister();

    // SetupAttachment로 설정한 부모 정보가 있다면
    if (GetAttachParent())
    {
        // 실제 연결 진행 (AttachToComponent 호출)
        if (AttachToComponent(
            GetAttachParent(),
            FAttachmentTransformRules::KeepRelativeTransform,
            GetAttachSocketName()) == false)
        {
            // 실패 시 연결 정보 초기화
            SetAttachParent(nullptr);
            SetAttachSocketName(NAME_None);
        }
    }
}</code></pre>

                <div class="flow">
                    <div class="flow-node">생성자: SetupAttachment()</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">OnRegister() 호출</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">AttachToComponent()</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">실제 연결 완료</div>
                </div>

                <h2>핵심 정리</h2>
                <div class="callout important">
                    <div class="callout-title">SetupAttachment 핵심 요약</div>
                    <ol>
                        <li><strong>생성자에서만 사용</strong> (bRegistered == false)</li>
                        <li><strong>단순히 부모-자식 관계만 설정</strong> (실제 연결 X)</li>
                        <li><strong>OnRegister에서 AttachToComponent 호출</strong>로 실제 연결</li>
                        <li><strong>5가지 검사</strong>로 안전성 보장</li>
                    </ol>
                </div>

                <table>
                    <tr><th>상황</th><th>사용 함수</th></tr>
                    <tr><td>생성자에서 초기 설정</td><td>SetupAttachment</td></tr>
                    <tr><td>BeginPlay/Tick에서 동적 연결</td><td>AttachToComponent</td></tr>
                    <tr><td>Editor에서 Blueprint로 설정</td><td>SetupAttachment (자동)</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['comp-sec4'] = {
            title: '컴포넌트 연결',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Component</div>
                    <h1>컴포넌트 연결 (AttachToComponent)</h1>
                </div>
                <h2>Overview</h2>
                <p>AttachToComponent는 <strong>런타임에서 Component를 실제로 연결</strong>하는 함수입니다. Transform 갱신, Overlap 체크, Tick 선행 조건 설정 등 모든 작업을 수행합니다.</p>

                <h2>호출 시점</h2>
                <pre><code class="language-cpp">void USceneComponent::OnRegister()
{
    Super::OnRegister();

    // SetupAttachment로 설정한 부모 정보가 있다면
    if (GetAttachParent())
    {
        // 실제 연결 진행!
        if (AttachToComponent(
            GetAttachParent(),
            FAttachmentTransformRules::KeepRelativeTransform,
            GetAttachSocketName()) == false)
        {
            // 실패 시 초기화
            SetAttachParent(nullptr);
            SetAttachSocketName(NAME_None);
        }
    }
}</code></pre>

                <h2>AttachToComponent 전체 로직 흐름</h2>
                <div class="flow-vertical">
                    <div class="flow-node">AttachToComponent 호출</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">생성자 내부? → SetupAttachment만 호출</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">7가지 검증 단계</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">이전 부모에서 분리</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--success); color: #fff;">연결 시작!</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Tick 선행 조건 설정</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Transform Rule 적용</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">UpdateComponentToWorld</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Weld/Overlap 처리</div>
                </div>

                <h2>생성자 내부 체크</h2>
                <pre><code class="language-cpp">bool USceneComponent::AttachToComponent(
    USceneComponent* Parent,
    const FAttachmentTransformRules& AttachmentRules,
    FName SocketName)
{
    // 생성자 내부에서 호출되는 경우 SetupAttachment만 호출
    FUObjectThreadContext& ThreadContext = FUObjectThreadContext::Get();
    if (ThreadContext.IsInConstructor > 0)
    {
        SetupAttachment(Parent, SocketName);
        return true;
    }
    // ... 실제 연결 로직
}</code></pre>

                <div class="callout tip">
                    <div class="callout-title">똑똑한 설계!</div>
                    <p>생성자에서 실수로 AttachToComponent를 호출해도 자동으로 SetupAttachment로 변환됩니다.</p>
                </div>

                <h2>7가지 검증 단계</h2>
                <pre><code class="language-cpp">// 1. 부모가 있는지 확인
if (Parent == nullptr) return false;

// 2. 이미 같은 부모에 붙어 있는 경우
if (bSameAttachParentAndSocket && LastAttachIndex != INDEX_NONE)
    return true;

// 3. 자기 자신에게 부착 방지
if (Parent == this) return false;

// 4. RootComponent 체크
if (MyActor == TheirActor && MyActor->GetRootComponent() == this)
    return false;

// 5. 순환 참조 방지
if (Parent->IsAttachedTo(this)) return false;

// 6. 부착 가능 여부 확인
if (!Parent->CanAttachAsChild(this, SocketName)) return false;

// 7. CDO 체크
if (Parent->IsTemplate() != IsTemplate()) return false;</code></pre>

                <div class="callout warning">
                    <div class="callout-title">RootComponent는 같은 Actor의 다른 Component에 부착 불가!</div>
                    <p>RootComponent는 Actor의 기준점이므로, 다른 Component에 부착되면 Actor의 Transform 계산이 꼬입니다.</p>
                </div>

                <h2>연결 시작!</h2>
                <h3>Step 1: Tick 선행 조건 설정</h3>
                <pre><code class="language-cpp">// 부모의 Tick이 먼저 실행되도록 설정
PrimaryComponentTick.AddPrerequisite(Parent, Parent->PrimaryComponentTick);</code></pre>

                <h3>Step 2: 부모-자식 정보 저장</h3>
                <pre><code class="language-cpp">SetAttachParent(Parent);
SetAttachSocketName(SocketName);
SetShouldBeAttached(AttachParent != nullptr);

OnAttachmentChanged();

// 자식 목록에 추가
Parent->AttachChildren.Add(this);</code></pre>

                <h3>Step 3: EAttachmentRule에 따라 Transform 세팅</h3>
                <table>
                    <tr><th>Rule</th><th>설명</th><th>사용 예시</th></tr>
                    <tr><td><strong>KeepRelative</strong></td><td>현재 상대 Transform 유지</td><td>기본값</td></tr>
                    <tr><td><strong>KeepWorld</strong></td><td>World Transform 유지</td><td>부모가 바뀌어도 위치 고정</td></tr>
                    <tr><td><strong>SnapToTarget</strong></td><td>부모에 딱 붙음 (Relative = 0)</td><td>소켓에 정확히 부착</td></tr>
                </table>

                <pre><code class="language-cpp">switch (AttachmentRules.LocationRule)
{
case EAttachmentRule::KeepRelative:
    // 현재 상대 위치 유지
    break;

case EAttachmentRule::KeepWorld:
    // World 위치 유지
    SetRelativeLocation_Direct(RelativeTM.GetTranslation());
    break;

case EAttachmentRule::SnapToTarget:
    // 부모 위치로 이동
    SetRelativeLocation_Direct(FVector::ZeroVector);
    break;
}</code></pre>

                <h2>연결 완료 후 처리</h2>
                <pre><code class="language-cpp">// Transform 업데이트
UpdateComponentToWorld(EUpdateTransformFlags::None, ETeleportType::TeleportPhysics);

// Weld 처리 (물리 시뮬레이션 용접)
if (AttachmentRules.bWeldSimulatedBodies)
{
    PrimitiveComponent->WeldToImplementation(...);
}

// Overlap 체크
if (IsRegistered())
{
    UpdateOverlaps();
}</code></pre>

                <h2>실전 예시: 무기 장착</h2>
                <pre><code class="language-cpp">void ACharacter::EquipWeapon(UStaticMeshComponent* Weapon)
{
    if (!Weapon) return;

    // 손에 무기 부착
    Weapon->AttachToComponent(
        GetMesh(),
        FAttachmentTransformRules::SnapToTargetIncludingScale,
        TEXT("hand_r")  // 소켓 이름
    );
}

void ACharacter::UnequipWeapon(UStaticMeshComponent* Weapon)
{
    if (!Weapon) return;

    // 등 뒤로 무기 이동
    Weapon->AttachToComponent(
        GetMesh(),
        FAttachmentTransformRules::SnapToTargetIncludingScale,
        TEXT("back_weapon")
    );
}</code></pre>

                <h2>핵심 정리</h2>
                <div class="callout important">
                    <div class="callout-title">AttachToComponent 핵심</div>
                    <ol>
                        <li><strong>생성자에서는 자동으로 SetupAttachment로 변환</strong></li>
                        <li><strong>7가지 검증</strong>으로 안전성 보장</li>
                        <li><strong>Tick 선행 조건</strong> 자동 설정 (부모 → 자식)</li>
                        <li><strong>Transform Rule</strong>에 따라 위치 계산</li>
                        <li><strong>Weld, Overlap</strong> 처리까지 완료</li>
                    </ol>
                </div>

                <table>
                    <tr><th>항목</th><th>SetupAttachment</th><th>AttachToComponent</th></tr>
                    <tr><td>사용 시점</td><td>생성자</td><td>런타임</td></tr>
                    <tr><td>Transform 갱신</td><td>❌</td><td>✅</td></tr>
                    <tr><td>Overlap 체크</td><td>❌</td><td>✅</td></tr>
                    <tr><td>Tick 설정</td><td>❌</td><td>✅</td></tr>
                    <tr><td>Weld 처리</td><td>❌</td><td>✅</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['comp-sec5'] = {
            title: '컴포넌트 분리',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Component</div>
                    <h1>컴포넌트 분리 (DetachFromComponent)</h1>
                </div>
                <h2>Overview</h2>
                <p>DetachFromComponent는 Component를 <strong>부모로부터 분리</strong>하는 함수입니다. 부모-자식 관계 해제, Tick 선행 조건 제거, Transform 갱신을 수행합니다.</p>

                <h2>전체 로직 흐름</h2>
                <div class="flow-vertical">
                    <div class="flow-node">DetachFromComponent 호출</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">부모가 있는가?</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--warning); color: #000;">UnWeld 처리</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Tick 선행 조건 제거</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">부모의 자식 목록에서 제거</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">부모 정보 초기화</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--success); color: #fff;">DetachmentRule 적용</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">UpdateComponentToWorld</div>
                </div>

                <h2>소스 코드 단계별 분석</h2>

                <h3>1. UnWeld 처리 (물리 용접 해제)</h3>
                <pre><code class="language-cpp">if (UPrimitiveComponent* PrimComp = Cast&lt;UPrimitiveComponent&gt;(this))
{
    PrimComp->UnWeldFromParent();
}</code></pre>

                <h3>2. Tick 선행 조건 제거</h3>
                <pre><code class="language-cpp">// Tick에 대한 부모 선행 조건 제거!
PrimaryComponentTick.RemovePrerequisite(
    GetAttachParent(),
    GetAttachParent()->PrimaryComponentTick
);</code></pre>

                <div class="callout">
                    <div class="callout-title">Tick 순서 변화</div>
                    <div class="hierarchy-box">[연결 상태]
Parent::Tick() → Child::Tick()

[분리 후]
Parent::Tick()
Child::Tick()  // 독립적으로 실행 (순서 보장 X)</div>
                </div>

                <h3>3. 부모-자식 관계 해제</h3>
                <pre><code class="language-cpp">// 1. 부모의 자식 목록에서 제거
GetAttachParent()->AttachChildren.Remove(this);

// 2. 부모에게 분리 알림
GetAttachParent()->OnChildDetached(this);

// 3. 자식(this)의 부모 정보 제거
SetAttachParent(nullptr);
SetAttachSocketName(NAME_None);
SetShouldBeAttached(false);

// 4. 부착 정보 변경 이벤트
OnAttachmentChanged();</code></pre>

                <div class="hierarchy-box">// 분리 전
Parent->AttachChildren = [ChildA, this, ChildC]
this->AttachParent = Parent

// 분리 후
Parent->AttachChildren = [ChildA, ChildC]  // this 제거됨
this->AttachParent = nullptr  // 부모 없음</div>

                <h3>4. DetachmentRule에 따른 Transform 설정</h3>
                <table>
                    <tr><th>Rule</th><th>설명</th><th>사용 예시</th></tr>
                    <tr><td><strong>KeepRelative</strong></td><td>현재 상대 Transform 유지</td><td>부모 기준 위치 유지</td></tr>
                    <tr><td><strong>KeepWorld</strong></td><td>World Transform 유지</td><td>분리해도 위치 고정</td></tr>
                </table>

                <pre><code class="language-cpp">switch (DetachmentRules.LocationRule)
{
case EDetachmentRule::KeepRelative:
    // 상대 좌표 유지 (아무것도 안 함)
    break;

case EDetachmentRule::KeepWorld:
    // World 좌표를 Relative로 변환
    SetRelativeLocation_Direct(GetComponentTransform().GetTranslation());
    break;
}</code></pre>

                <h4>KeepWorld 동작 원리</h4>
                <div class="hierarchy-box">[분리 전]
Parent World Location: (100, 0, 0)
Child Relative Location: (50, 0, 0)
Child World Location: (150, 0, 0)

[분리 후 - KeepWorld]
Child Relative Location: (150, 0, 0)  // World 좌표가 Relative로!
Child World Location: (150, 0, 0)  // 같은 위치 유지</div>

                <h2>실전 예시</h2>
                <h3>무기 떨어뜨리기</h3>
                <pre><code class="language-cpp">void ACharacter::DropWeapon()
{
    if (!Weapon) return;

    // 1. 부모에서 분리 (World 위치 유지)
    Weapon->DetachFromComponent(
        FDetachmentTransformRules::KeepWorldTransform
    );

    // 2. 물리 시뮬레이션 활성화
    Weapon->SetSimulatePhysics(true);

    // 3. 충돌 설정 변경
    Weapon->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
}</code></pre>

                <h3>차량에서 내리기</h3>
                <pre><code class="language-cpp">void ACharacter::ExitVehicle(AVehicle* Vehicle)
{
    if (!Vehicle) return;

    // 1. 차량에서 분리
    RootComponent->DetachFromComponent(
        FDetachmentTransformRules::KeepWorldTransform
    );

    // 2. 캐릭터를 차량 옆으로 이동
    FVector ExitLocation = Vehicle->GetActorLocation() +
        Vehicle->GetActorRightVector() * 200.0f;
    SetActorLocation(ExitLocation);
}</code></pre>

                <h2>Attach/Detach 비교표</h2>
                <table>
                    <tr><th>동작</th><th>AttachToComponent</th><th>DetachFromComponent</th></tr>
                    <tr><td>Tick 선행 조건</td><td>AddPrerequisite</td><td>RemovePrerequisite</td></tr>
                    <tr><td>부모 정보</td><td>설정</td><td>제거</td></tr>
                    <tr><td>자식 목록</td><td>추가</td><td>제거</td></tr>
                    <tr><td>Transform</td><td>Rule에 따라 계산</td><td>Rule에 따라 계산</td></tr>
                    <tr><td>Weld</td><td>WeldToImplementation</td><td>UnWeldFromParent</td></tr>
                    <tr><td>Overlap</td><td>항상 수행</td><td>조건부 수행</td></tr>
                </table>

                <h2>핵심 정리</h2>
                <div class="callout important">
                    <div class="callout-title">DetachFromComponent 핵심</div>
                    <ol>
                        <li><strong>부모-자식 관계 완전 해제</strong></li>
                        <li><strong>Tick 선행 조건 제거</strong> (독립적 실행)</li>
                        <li><strong>DetachmentRule에 따라 Transform 설정</strong></li>
                        <li><strong>Overlap 최적화</strong>: Attach와 연속 시 Skip</li>
                    </ol>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['comp-sec6'] = {
            title: 'SetPawn',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Component</div>
                    <h1>SetPawn - Controller와 Pawn의 연결</h1>
                </div>
                <h2>Overview</h2>
                <p>SetPawn은 Controller의 <strong>RootComponent를 Pawn의 RootComponent에 부착</strong>하고, <strong>Input 처리를 위해 Tick 순서를 조정</strong>하는 Component Attachment의 실전 응용 사례입니다.</p>

                <h2>SetPawn 호출 순서</h2>
                <div class="flow">
                    <div class="flow-node">SetPawn 호출</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">RemovePawnTickDependency</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Pawn 저장</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--success); color: #fff;">AttachToPawn</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--warning); color: #000;">AddPawnTickDependency</div>
                </div>

                <h2>전체 소스 코드</h2>
                <pre><code class="language-cpp">void AController::SetPawn(APawn* InPawn)
{
    // 1. 이전 Pawn의 Tick 선행조건 제거
    RemovePawnTickDependency(Pawn);

    // 2. Controller에 Pawn 저장
    Pawn = InPawn;
    Character = (Pawn ? Cast&lt;ACharacter&gt;(Pawn) : NULL);

    // 3. Controller를 Pawn에 Attach
    AttachToPawn(Pawn);

    // 4. Pawn Tick 조건 설정 (Controller → Pawn 순서)
    AddPawnTickDependency(Pawn);
}</code></pre>

                <h2>AttachToPawn - Controller를 Pawn에 부착</h2>
                <pre><code class="language-cpp">void AController::AttachToPawn(APawn* InPawn)
{
    if (InPawn)
    {
        if (InPawn->GetRootComponent() &&
            RootComponent->GetAttachParent() != InPawn->GetRootComponent())
        {
            // 1. 기존 부모에서 분리
            RootComponent->DetachFromComponent(
                FDetachmentTransformRules::KeepRelativeTransform
            );

            // 2. 위치/회전 초기화
            RootComponent->SetRelativeLocationAndRotation(
                FVector::ZeroVector,
                FRotator::ZeroRotator
            );

            // 3. Pawn의 RootComponent에 부착
            RootComponent->AttachToComponent(
                InPawn->GetRootComponent(),
                FAttachmentTransformRules::KeepRelativeTransform
            );
        }
    }
}</code></pre>

                <div class="hierarchy-box">[Before]
Controller (독립)
Pawn (독립)

[After]
Pawn
└─ Controller  // Pawn의 RootComponent에 부착됨</div>

                <div class="callout">
                    <div class="callout-title">왜 Controller를 Pawn에 부착하는가?</div>
                    <ul>
                        <li>Controller도 <strong>AActor를 상속</strong>받아 RootComponent 보유</li>
                        <li>Pawn에 부착하면 <strong>Pawn이 이동할 때 Controller도 자동으로 따라감</strong></li>
                        <li>Transform 동기화를 위한 설계</li>
                    </ul>
                </div>

                <h2>Tick 순서 문제와 해결</h2>
                <h3>문제 상황</h3>
                <pre><code class="language-cpp">// AttachToComponent에서 자동으로 설정되는 Tick 순서
RootComponent->AttachToComponent(...);
// → 내부적으로: PawnTick → ControllerTick 순서 설정</code></pre>

                <div class="callout warning">
                    <div class="callout-title">문제: Input이 1프레임 늦게 반영됨!</div>
                    <div class="hierarchy-box">프레임 1:
    - Pawn::Tick(): 이전 프레임 Input으로 이동
    - Controller::Tick(): 현재 프레임 Input 수집

프레임 2:
    - Pawn::Tick(): 프레임 1의 Input으로 이동 (1프레임 지연!)
    - Controller::Tick(): 새 Input 수집</div>
                </div>

                <h3>해결책: Tick 순서 역전</h3>
                <pre><code class="language-cpp">void AController::AddPawnTickDependency(APawn* NewPawn)
{
    if (NewPawn != NULL)
    {
        bool bNeedsPawnPrereq = true;

        if (bNeedsPawnPrereq)
        {
            // Controller → Pawn 순서 보장!
            NewPawn->PrimaryActorTick.AddPrerequisite(
                this,
                this->PrimaryActorTick
            );
        }
    }
}</code></pre>

                <div class="hierarchy-box">[최종 Tick 순서]
Controller::Tick()  // 1. Input 처리
└─ Input 수집

Pawn::Tick()  // 2. Movement 처리
└─ 수집된 Input으로 즉시 이동!</div>

                <h2>전체 프로세스 정리</h2>
                <div class="flow-vertical">
                    <div class="flow-node">SetPawn 호출</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">RemovePawnTickDependency (이전 Pawn)</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Pawn 저장</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--success); color: #fff;">AttachToPawn</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Controller RootComponent → Pawn RootComponent</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--warning); color: #000;">AddPawnTickDependency</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--accent); color: #fff;">Controller → Pawn 순서 완성</div>
                </div>

                <h3>단계별 상태 변화</h3>
                <table>
                    <tr><th>단계</th><th>Tick 순서</th><th>Attachment</th></tr>
                    <tr><td><strong>초기</strong></td><td>-</td><td>둘 다 독립적</td></tr>
                    <tr><td><strong>AttachToPawn</strong></td><td>Pawn → Controller</td><td>Pawn └─ Controller</td></tr>
                    <tr><td><strong>AddPawnTickDependency</strong></td><td><strong>Controller → Pawn</strong></td><td>Pawn └─ Controller</td></tr>
                </table>

                <h2>실전 예시: Possess/Unpossess</h2>
                <pre><code class="language-cpp">void APlayerController::Possess(APawn* InPawn)
{
    if (InPawn)
    {
        // Pawn 설정 (SetPawn 호출)
        SetPawn(InPawn);

        // Input 컴포넌트 설정
        InPawn->SetupPlayerInputComponent(InputComponent);

        // Camera 설정
        if (ACharacter* Character = Cast&lt;ACharacter&gt;(InPawn))
        {
            Character->GetMesh()->SetOwnerNoSee(true);
        }
    }
}

void APlayerController::UnPossess()
{
    if (GetPawn())
    {
        // Pawn에서 분리
        SetPawn(nullptr);
    }
}</code></pre>

                <h2>핵심 정리</h2>
                <div class="callout important">
                    <div class="callout-title">SetPawn의 핵심 포인트</div>
                    <ol>
                        <li><strong>Controller RootComponent를 Pawn RootComponent에 부착</strong> (Transform 동기화)</li>
                        <li><strong>Tick 순서 문제 해결</strong>: AttachToComponent 순서 → SetPawn이 재설정</li>
                        <li><strong>Input 지연 방지</strong>: Controller::Tick() → Pawn::Tick()</li>
                    </ol>
                </div>

                <table>
                    <tr><th>개념</th><th>SetPawn에서의 활용</th></tr>
                    <tr><td>AttachToComponent</td><td>Controller를 Pawn에 부착</td></tr>
                    <tr><td>DetachFromComponent</td><td>UnPossess 시 분리</td></tr>
                    <tr><td>Tick Prerequisites</td><td>Input 지연 방지를 위한 순서 조정</td></tr>
                    <tr><td>Transform Sync</td><td>Pawn 이동 시 Controller 자동 추적</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['comp-sec7'] = {
            title: '월드 트랜스폼 업데이트',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Component</div>
                    <h1>월드 트랜스폼 업데이트</h1>
                </div>
                <h2>Overview</h2>
                <p>UpdateComponentToWorld는 Component와 <strong>모든 자식의 World Transform을 재계산</strong>합니다. <strong>부모 → 자식 순서</strong>로 계층적 업데이트를 수행합니다.</p>

                <h2>호출 시점</h2>
                <pre><code class="language-cpp">// AttachToComponent에서
UpdateComponentToWorld(EUpdateTransformFlags::None, ETeleportType::TeleportPhysics);

// DetachFromComponent에서
UpdateComponentToWorld();

// MoveComponent에서
UpdateComponentToWorld(...);</code></pre>

                <h2>전체 프로세스</h2>
                <div class="flow-vertical">
                    <div class="flow-node">UpdateComponentToWorld</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">UpdateComponentToWorldWithParent</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">부모가 업데이트 안됨? → 부모 먼저 업데이트</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--success); color: #fff;">CalcNewComponentToWorld</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Transform 변경됨?</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--warning); color: #000;">PropagateTransformUpdate</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">UpdateChildTransforms</div>
                </div>

                <h2>UpdateComponentToWorld</h2>
                <pre><code class="language-cpp">void USceneComponent::UpdateComponentToWorld(
    EUpdateTransformFlags UpdateTransformFlags,
    ETeleportType Teleport)
{
    // Rotator → Quat 변환은 무거운 연산이라 미리 캐싱
    UpdateComponentToWorldWithParent(
        GetAttachParent(),
        GetAttachSocketName(),
        UpdateTransformFlags,
        RelativeRotationCache.RotatorToQuat(GetRelativeRotation()),  // 캐싱!
        Teleport
    );
}</code></pre>

                <div class="callout tip">
                    <div class="callout-title">최적화 포인트</div>
                    <p><strong>Rotator → Quat 변환</strong>은 삼각함수 사용으로 비용이 큽니다. 미리 변환하여 캐싱하면 성능이 향상됩니다.</p>
                </div>

                <h2>부모 먼저 업데이트</h2>
                <pre><code class="language-cpp">// 부모가 업데이트되지 않았다면 부모 먼저 업데이트
if (Parent && !Parent->bComponentToWorldUpdated)
{
    Parent->UpdateComponentToWorld();

    // 부모가 업데이트되면서 자식(this)도 같이 업데이트된 경우
    if (bComponentToWorldUpdated)
    {
        return;  // 이미 업데이트됨
    }
}</code></pre>

                <div class="hierarchy-box">Parent::UpdateComponentToWorld()
└─ UpdateChildTransforms()
    └─ Child::UpdateComponentToWorld()  // 자식도 함께 업데이트</div>

                <h2>CalcNewComponentToWorld - 핵심 계산</h2>
                <h3>일반적인 경우 (절대 좌표 미사용)</h3>
                <pre><code class="language-cpp">FTransform USceneComponent::CalcNewComponentToWorld(
    const FTransform& NewRelativeTransform,
    const USceneComponent* Parent,
    FName SocketName) const
{
    if (Parent)
    {
        if (!bGeneral)
        {
            // 자식의 상대 좌표 × 부모의 월드 좌표
            // = 자식의 월드 좌표
            return NewRelativeTransform * Parent->GetSocketTransform(SocketName);
        }
    }
    else
    {
        // 부모가 없으면 상대 좌표 = 월드 좌표
        return NewRelativeTransform;
    }
}</code></pre>

                <div class="hierarchy-box">[계층 구조]
Parent
    World: (100, 0, 0)
    └─ Child1
        Relative: (50, 0, 0)
        World: (150, 0, 0)  // 100 + 50
        └─ Child2
            Relative: (20, 0, 0)
            World: (170, 0, 0)  // 150 + 20</div>

                <h3>절대 좌표 사용 시</h3>
                <pre><code class="language-cpp">// 절대 위치 사용 시
if (IsUsingAbsoluteLocation())
{
    NewCompToWorld.CopyTranslation(NewRelativeTransform);
}

// 절대 회전 사용 시
if (IsUsingAbsoluteRotation())
{
    NewCompToWorld.CopyRotation(NewRelativeTransform);
}

// 절대 스케일 사용 시
if (IsUsingAbsoluteScale())
{
    NewCompToWorld.CopyScale3D(NewRelativeTransform);
}</code></pre>

                <div class="hierarchy-box">Parent: World (100, 0, 0)

Child (Absolute Location):
    Relative: (50, 0, 0)
    World: (50, 0, 0)  // 부모 무시!

Child (Relative Location):
    Relative: (50, 0, 0)
    World: (150, 0, 0)  // 100 + 50</div>

                <h2>PropagateTransformUpdate - 변경 전파</h2>
                <h3>Transform이 변경된 경우</h3>
                <pre><code class="language-cpp">if (bTransformChanged)
{
    // 1. Bounds 업데이트
    UpdateBounds();

    if (bRegistered)
    {
        // 2. Transform 변경 이벤트
        if (bWantsOnUpdateTransform)
        {
            OnUpdateTransform(UpdateTransformFlags, Teleport);
        }
        TransformUpdated.Broadcast(this, UpdateTransformFlags, Teleport);

        // 3. Render Thread에 알림
        MarkRenderTransformDirty();
    }

    // 4. 모든 자식 업데이트
    if (AttachedChildren.Num() > 0)
    {
        UpdateChildTransforms(ChildrenFlagNoPhysics, Teleport);
    }

    // 5. Navigation 데이터 업데이트
    if (bNavigationRelevant && bRegistered)
    {
        UpdateNavigationData();
    }
}</code></pre>

                <h2>UpdateChildTransforms - 자식 업데이트</h2>
                <pre><code class="language-cpp">void USceneComponent::UpdateChildTransforms(...)
{
    // 모든 자식 업데이트
    for (USceneComponent* ChildComp : GetAttachChildren())
    {
        if (ChildComp != nullptr)
        {
            // 아직 업데이트 안 됐으면 무조건 업데이트
            if (!ChildComp->bComponentToWorldUpdated)
            {
                ChildComp->UpdateComponentToWorld(...);
            }
            else
            {
                // 절대 좌표를 모두 사용하면 부모 영향 없음
                if (ChildComp->IsUsingAbsoluteLocation() &&
                    ChildComp->IsUsingAbsoluteRotation() &&
                    ChildComp->IsUsingAbsoluteScale())
                {
                    continue;
                }
                // 자식 업데이트
                ChildComp->UpdateComponentToWorld(...);
            }
        }
    }
}</code></pre>

                <h2>핵심 정리</h2>
                <div class="callout important">
                    <div class="callout-title">UpdateComponentToWorld 핵심</div>
                    <ol>
                        <li><strong>계층적 업데이트</strong>: 부모 → 자식 순서 보장</li>
                        <li><strong>World Transform 계산</strong>: Relative × ParentWorld = ComponentWorld</li>
                        <li><strong>캐싱 최적화</strong>: Rotator → Quat 변환 캐싱</li>
                        <li><strong>시스템 알림</strong>: Rendering, Navigation, Events</li>
                        <li><strong>자식 전파</strong>: UpdateChildTransforms</li>
                    </ol>
                </div>

                <table>
                    <tr><th>항목</th><th>설명</th></tr>
                    <tr><td>계층적 업데이트</td><td>부모 → 자식 순서 보장</td></tr>
                    <tr><td>World 좌표 계산</td><td>Relative × ParentWorld</td></tr>
                    <tr><td>절대 좌표</td><td>부모 무시</td></tr>
                    <tr><td>Render 알림</td><td>MarkRenderTransformDirty</td></tr>
                    <tr><td>Navigation</td><td>UpdateNavigationData</td></tr>
                </table>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['comp-sec8'] = {
            title: '위치 및 회전 설정',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Component</div>
                    <h1>위치 및 회전 설정</h1>
                </div>
                <h2>Overview</h2>
                <p>SetActorLocationAndRotation은 Actor의 <strong>RootComponent를 통해</strong> 위치/회전을 변경합니다. MoveComponent → InternalSetWorldLocationAndRotation 순서로 처리됩니다.</p>

                <h2>전체 프로세스</h2>
                <div class="flow-vertical">
                    <div class="flow-node">SetActorLocationAndRotation</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Delta 계산</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">RootComponent->MoveComponent</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--success); color: #fff;">InternalSetWorldLocationAndRotation</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--warning); color: #000;">UpdateComponentToWorldWithParent</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--info); color: #fff;">UpdateOverlaps</div>
                </div>

                <h2>SetActorLocationAndRotation</h2>
                <pre><code class="language-cpp">bool AActor::SetActorLocationAndRotation(
    FVector NewLocation,
    FRotator NewRotation,
    bool bSweep,
    FHitResult* OutSweepHitResult,
    ETeleportType Teleport)
{
    if (RootComponent)
    {
        // 현재 위치와 들어온 위치의 차이 계산
        const FVector Delta = NewLocation - GetActorLocation();

        // Transform 관련은 RootComponent(SceneComponent)를 통해 처리
        return RootComponent->MoveComponent(
            Delta,
            NewRotation,
            bSweep,
            OutSweepHitResult,
            MOVECOMP_NoFlags,
            Teleport
        );
    }
    return false;
}</code></pre>

                <div class="callout important">
                    <div class="callout-title">Actor는 껍데기!</div>
                    <p>Actor 자체는 Transform 기능 없음. <strong>RootComponent가 실제 처리</strong>합니다. Component 기반 아키텍처의 핵심입니다.</p>
                </div>

                <h2>MoveComponent</h2>
                <pre><code class="language-cpp">bool USceneComponent::MoveComponent(
    const FVector& Delta,
    const FRotator& NewRotation,
    bool bSweep,
    FHitResult* Hit,
    EMoveComponentFlags MoveFlags,
    ETeleportType Teleport)
{
    // 부모가 없는 경우
    if (GetAttachParent() == nullptr)
    {
        // 이동/회전이 없으면 종료
        if (Delta.IsZero() && NewRotation.Equals(GetRelativeRotation(), SCENECOMPONENT_ROTATOR_TOLERANCE))
        {
            if (Hit) { Hit->Init(); }
            return true;
        }

        // Rotator → Quat 캐싱 후 MoveComponentImpl 호출
        return MoveComponentImpl(
            Delta,
            RelativeRotationCache.RotatorToQuat_ReadOnly(NewRotation),
            bSweep, Hit, MoveFlags, Teleport
        );
    }

    // 부모가 있는 경우
    return MoveComponentImpl(Delta, NewRotation.Quaternion(), bSweep, Hit, MoveFlags, Teleport);
}</code></pre>

                <h2>MoveComponentImpl</h2>
                <pre><code class="language-cpp">bool USceneComponent::MoveComponentImpl(...)
{
    // World 좌표가 업데이트되었는지 체크
    ConditionalUpdateComponentToWorld();

    // Vector, Rotation 모두 변화 없으면 스킵 (최적화)
    if (Delta.IsZero())
    {
        if (NewRotation.Equals(GetComponentTransform().GetRotation(), SCENECOMPONENT_QUAT_TOLERANCE))
        {
            return true;
        }
    }

    // Transform 업데이트
    const bool bMoved = InternalSetWorldLocationAndRotation(
        GetComponentLocation() + Delta, NewRotation, false, Teleport
    );

    // 움직임이 있었으면 Overlap 업데이트
    if (bMoved) { UpdateOverlaps(); }
}</code></pre>

                <div class="callout tip">
                    <div class="callout-title">왜 먼저 업데이트?</div>
                    <p>GetComponentLocation()이 <strong>최신 World 좌표 반환</strong> 보장. Transform 계산 전 <strong>일관성 확보</strong>.</p>
                </div>

                <h2>InternalSetWorldLocationAndRotation</h2>
                <h3>부모가 있는 경우: World → Relative 변환</h3>
                <pre><code class="language-cpp">bool USceneComponent::InternalSetWorldLocationAndRotation(
    FVector NewLocation,
    const FQuat& RotationQuat,
    bool bNoPhysics,
    ETeleportType Teleport)
{
    // 부모가 있으면 World → Relative 변환 필요
    if (GetAttachParent() != nullptr)
    {
        const FTransform ParentToWorld = GetAttachParent()->GetSocketTransform(GetAttachSocketName());

        // World 좌표 → Relative 좌표 (역행렬)
        if (!IsUsingAbsoluteLocation())
        {
            NewLocation = ParentToWorld.InverseTransformPosition(NewLocation);
        }
        if (!IsUsingAbsoluteRotation())
        {
            NewRotationQuat = ParentToWorld.GetRotation().Inverse() * NewRotationQuat;
        }
    }
}</code></pre>

                <div class="hierarchy-box">Parent World: (100, 0, 0)
Desired World: (150, 0, 0)

InverseTransform:
NewRelative = ParentWorld⁻¹ × DesiredWorld
NewRelative = (150, 0, 0) - (100, 0, 0)
NewRelative = (50, 0, 0)</div>

                <h3>변화 여부 확인 및 적용</h3>
                <pre><code class="language-cpp">bool bDiffLocation = !NewLocation.Equals(GetRelativeLocation());
bool bDiffRotation = !NewRelativeRotation.Equals(GetRelativeRotation());

// Location, Rotation 둘 중 하나라도 다르면 업데이트
if (bDiffLocation || bDiffRotation)
{
    // Location 설정
    SetRelativeLocation_Direct(NewLocation);

    // Rotation 설정 (Rotator, Quat 둘 다!)
    if (bDiffRotation)
    {
        SetRelativeRotation_Direct(NewRelativeRotation);
        RelativeRotationCache.RotatorToQuat(NewRelativeRotation);
    }

    // World 좌표 및 자식 업데이트
    UpdateComponentToWorldWithParent(...);

    return true;
}
return false;</code></pre>

                <div class="callout warning">
                    <div class="callout-title">Rotator와 Quat 동시 저장 필수!</div>
                    <ul>
                        <li><strong>FRotator</strong>: 사람이 읽기 쉬운 Pitch/Yaw/Roll</li>
                        <li><strong>FQuat</strong>: 실제 계산에 사용 (Gimbal Lock 없음)</li>
                        <li><strong>둘 다 저장</strong>하지 않으면 데이터 불일치 발생</li>
                    </ul>
                </div>

                <h2>실전 예시</h2>
                <h3>Teleport vs Sweep</h3>
                <pre><code class="language-cpp">// Teleport: 충돌 무시하고 즉시 이동
SetActorLocation(NewLocation, false, nullptr, ETeleportType::TeleportPhysics);

// Sweep: 충돌 체크하며 이동
FHitResult HitResult;
SetActorLocation(NewLocation, true, &HitResult, ETeleportType::None);

if (HitResult.bBlockingHit)
{
    UE_LOG(LogTemp, Warning, TEXT("Hit: %s"), *HitResult.GetActor()->GetName());
}</code></pre>

                <h2>Transform 설정 함수 비교</h2>
                <table>
                    <tr><th>함수</th><th>좌표계</th><th>대상</th></tr>
                    <tr><td>SetActorLocation</td><td>World</td><td>Actor</td></tr>
                    <tr><td>SetActorRelativeLocation</td><td>Relative</td><td>Actor</td></tr>
                    <tr><td>SetWorldLocation</td><td>World</td><td>Component</td></tr>
                    <tr><td>SetRelativeLocation</td><td>Relative</td><td>Component</td></tr>
                    <tr><td>MoveComponent</td><td>World (Delta)</td><td>Component</td></tr>
                </table>

                <div class="callout important">
                    <div class="callout-title">Transform 설정 핵심</div>
                    <ol>
                        <li><strong>Actor는 RootComponent를 통해 Transform 변경</strong></li>
                        <li><strong>MoveComponent</strong>가 실제 처리</li>
                        <li><strong>최적화</strong>: 변화 없으면 즉시 종료</li>
                        <li><strong>부모가 있으면 World → Relative 역변환 필수</strong></li>
                    </ol>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['comp-sec9'] = {
            title: 'PrimitiveComponent 개념',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Component</div>
                    <h1>PrimitiveComponent 개념</h1>
                </div>
                <h2>Overview</h2>
                <p>PrimitiveComponent는 <strong>렌더링(Rendering)</strong>과 <strong>충돌(Collision)</strong>을 담당합니다. SceneComponent를 상속받아 Transform + 시각화 + 물리를 통합합니다.</p>

                <h2>Component 계층 구조</h2>
                <div class="hierarchy-box">UObject
└─ UActorComponent
    └─ USceneComponent (Transform + Hierarchy)
        └─ UPrimitiveComponent (Rendering + Collision) ◀
            ├─ UMeshComponent (Mesh 기반)
            │   ├─ UStaticMeshComponent (정적 메시)
            │   └─ USkinnedMeshComponent (Bone + Skinning)
            │       └─ USkeletalMeshComponent (Animation)
            │
            └─ UShapeComponent (Shape 기반)
                ├─ UBoxComponent
                ├─ USphereComponent
                └─ UCapsuleComponent</div>

                <h2>PrimitiveComponent의 두 가지 역할</h2>
                <h3>1. 시각적 표현 (Rendering)</h3>
                <pre><code class="language-cpp">class UPrimitiveComponent : public USceneComponent
{
    /** 렌더링 관련 */
    UPROPERTY()
    uint8 bVisible : 1;

    UPROPERTY()
    uint8 bCastShadow : 1;

    UPROPERTY()
    TArray<UMaterialInterface*> OverrideMaterials;

    // Bounds (렌더링 최적화)
    FBoxSphereBounds Bounds;
};</code></pre>

                <h3>2. 물리적 상호작용 (Physics & Collision)</h3>
                <pre><code class="language-cpp">class UPrimitiveComponent : public USceneComponent
{
    /** 충돌 관련 */
    UPROPERTY()
    FBodyInstance BodyInstance;

    UPROPERTY()
    TEnumAsByte<ECollisionEnabled::Type> CollisionEnabled;

    UPROPERTY()
    uint8 bGenerateOverlapEvents : 1;

    /** 물리 시뮬레이션 */
    UPROPERTY()
    uint8 bSimulatePhysics : 1;
};</code></pre>

                <h2>Render 계열 상속 구조</h2>
                <div class="hierarchy-box">UPrimitiveComponent
└─ UMeshComponent (Mesh 정보 추가)
    ├─ UStaticMeshComponent (삼각형만, 고정 형태)
    │   - 건물, 소품, 지형 등
    │   - 변형 불가능한 정적 메시
    │
    └─ USkinnedMeshComponent (Bone + Skinning)
        - Bone 정보 추가
        - Skinning 작업 (Vertex가 Bone을 따라감)
        - 애니메이션 실행 X
        │
        └─ USkeletalMeshComponent (Animation 추가)
            - 애니메이션 재생 가능
            - 캐릭터, 동물 등</div>

                <h2>Collision 계열 상속 구조</h2>
                <div class="hierarchy-box">UPrimitiveComponent
└─ UShapeComponent (기본 도형)
    ├─ UBoxComponent (박스 충돌)
    ├─ USphereComponent (구 충돌)
    └─ UCapsuleComponent (캡슐 충돌)</div>

                <div class="callout">
                    <div class="callout-title">왜 충돌 Component가 UPrimitiveComponent 상속?</div>
                    <ul>
                        <li>물리 작용할 때 <strong>간단한 렌더링 필요</strong></li>
                        <li>에디터에서 <strong>시각적으로 확인</strong> 가능해야 함</li>
                        <li>블루프린트에서 캡슐 형태를 <strong>미리 보려면</strong> 렌더링 기능 필요</li>
                    </ul>
                </div>

                <h2>주요 기능 상세</h2>
                <h3>렌더링 제어</h3>
                <pre><code class="language-cpp">// 가시성
PrimitiveComp->SetVisibility(true);
PrimitiveComp->SetHiddenInGame(false);

// 그림자
PrimitiveComp->SetCastShadow(true);

// 머티리얼
PrimitiveComp->SetMaterial(0, NewMaterial);</code></pre>

                <h3>충돌 설정</h3>
                <pre><code class="language-cpp">// 충돌 활성화
PrimitiveComp->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);

// Overlap 이벤트 생성
PrimitiveComp->SetGenerateOverlapEvents(true);

// Collision Profile
PrimitiveComp->SetCollisionProfileName(TEXT("BlockAll"));

// 델리게이트 바인딩
PrimitiveComp->OnComponentBeginOverlap.AddDynamic(this, &AMyActor::OnOverlapBegin);</code></pre>

                <h3>물리 시뮬레이션</h3>
                <pre><code class="language-cpp">// 물리 시뮬레이션 활성화
PrimitiveComp->SetSimulatePhysics(true);

// 질량 설정
PrimitiveComp->SetMassOverrideInKg(NAME_None, 100.0f);

// 힘 적용
PrimitiveComp->AddForce(FVector(0, 0, 1000));

// 임펄스 적용
PrimitiveComp->AddImpulse(FVector(0, 0, 500), NAME_None, true);</code></pre>

                <h2>실전 예시: 캐릭터 구조</h2>
                <pre><code class="language-cpp">ACharacter::ACharacter()
{
    // RootComponent: CapsuleComponent (충돌 + 간단한 렌더링)
    CapsuleComponent = CreateDefaultSubobject<UCapsuleComponent>(TEXT("Capsule"));
    RootComponent = CapsuleComponent;
    CapsuleComponent->SetCollisionProfileName(TEXT("Pawn"));

    // Mesh: SkeletalMeshComponent (렌더링 + 애니메이션)
    Mesh = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT("Mesh"));
    Mesh->SetupAttachment(CapsuleComponent);
    Mesh->SetCollisionEnabled(ECollisionEnabled::NoCollision);  // 충돌 꺼짐
}</code></pre>

                <div class="hierarchy-box">[역할 분담]
CapsuleComponent: 충돌 처리
SkeletalMeshComponent: 시각적 표현</div>

                <h2>Component 선택 가이드</h2>
                <table>
                    <tr><th>용도</th><th>Component</th><th>예시</th></tr>
                    <tr><td>정적 오브젝트</td><td>UStaticMeshComponent</td><td>건물, 나무, 바위</td></tr>
                    <tr><td>캐릭터</td><td>USkeletalMeshComponent</td><td>플레이어, NPC</td></tr>
                    <tr><td>충돌 박스</td><td>UBoxComponent</td><td>Trigger Volume</td></tr>
                    <tr><td>충돌 구</td><td>USphereComponent</td><td>총알, 폭발 범위</td></tr>
                    <tr><td>캐릭터 충돌</td><td>UCapsuleComponent</td><td>캐릭터 RootComponent</td></tr>
                </table>

                <div class="callout important">
                    <div class="callout-title">PrimitiveComponent의 핵심</div>
                    <ol>
                        <li><strong>USceneComponent 상속</strong> → Transform + Hierarchy</li>
                        <li><strong>렌더링 추가</strong> → 시각적 표현</li>
                        <li><strong>충돌 추가</strong> → 물리적 상호작용</li>
                        <li><strong>추상 클래스</strong> → 직접 사용 X, 파생 클래스 사용</li>
                        <li><strong>Render와 Collision 분리 설계 가능</strong></li>
                    </ol>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['comp-sec10'] = {
            title: '충돌 체크 개념',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Component</div>
                    <h1>충돌 체크 개념</h1>
                </div>
                <h2>Overview</h2>
                <p>PrimitiveComponent의 충돌 체크는 <strong>7단계 프로세스</strong>로 진행됩니다. Old vs New 비교를 통해 BeginOverlap과 EndOverlap 이벤트를 발생시킵니다.</p>

                <h2>충돌 체크 7단계</h2>
                <div class="callout">
                    <div class="callout-title">충돌 체크 7단계 요약</div>
                    <ol>
                        <li><strong>특수 로직</strong>: 미리 전달된 Overlap 목록 처리</li>
                        <li><strong>특수 로직</strong>: 좌표 변화 없이 Overlap 결과 재사용</li>
                        <li><strong>일반 로직</strong>: 현재 좌표 기준 충돌 체크</li>
                        <li><strong>비교</strong>: 이전 Overlap과 현재 Overlap 비교 후 중복 제거</li>
                        <li><strong>EndOverlap</strong>: 이전 Overlap에만 있는 Component 처리</li>
                        <li><strong>BeginOverlap</strong>: 현재 Overlap에만 있는 Component 처리</li>
                        <li><strong>재귀</strong>: 자식 Component도 1~6 반복</li>
                    </ol>
                </div>

                <h2>전체 프로세스</h2>
                <div class="flow-vertical">
                    <div class="flow-node">UpdateOverlapsImpl 호출</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">1. NewPendingOverlaps 있음?</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">2. OverlapsAtEndLocation 있음?</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--success); color: #fff;">3. 충돌 체크 수행</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--info); color: #fff;">4. Old vs New 비교</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">5. EndOverlap 호출</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">6. BeginOverlap 호출</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">7. 자식 Component 재귀</div>
                </div>

                <h2>단계 1: NewPendingOverlaps 처리 (특수 로직)</h2>
                <div class="callout">
                    <div class="callout-title">NewPendingOverlaps란?</div>
                    <p><strong>움직이는 경로 상에서 잠시 겹쳤던 모든 대상</strong>의 목록입니다. 이동이 끝난 현재 시점에는 더 이상 겹치지 않을 수 있습니다.</p>
                </div>

                <div class="hierarchy-box">[이동 경로]
StartPos ─────→ Overlap ─────→ EndPos
                ↑
            여기서 잠깐 충돌

- NewPendingOverlaps: [Overlap]
- 현재 위치(EndPos)에서는 충돌 안 함
- BeginOverlap만 호출하고 즉시 EndOverlap은 호출 안 함</div>

                <h2>단계 2: OverlapsAtEndLocation 재사용 (특수 로직)</h2>
                <pre><code class="language-cpp">// 1. OverlapsAtEndLocation이 제공됨
// 2. Transform이 변하지 않음
if (OverlapsAtEndLocation != nullptr &&
    PrevTransform.Equals(GetComponentTransform()))
{
    // 충돌 체크 스킵, 결과 재사용!
}</code></pre>

                <h2>단계 3: 현재 좌표 기준 충돌 체크 (일반 로직)</h2>
                <div class="hierarchy-box">1. ComponentOverlapMulti() 호출
    ↓
2. 충돌된 모든 Component 반환
    ↓
3. 각 Component 검증
    - WorldSettings 같은 특수 Actor 제외
    - 초기화되지 않은 Component 제외
    - ShouldIgnoreOverlapResult() 통과한 것만
    ↓
4. OverlapMultiResult에 추가
    ↓
5. NewOverlappingComponentPtrs로 변환</div>

                <h2>단계 4: Old vs New 비교 (일반 로직)</h2>
                <pre><code class="language-cpp">OldOverlappingComponentPtrs:  이전 프레임 충돌 대상
NewOverlappingComponentPtrs:  현재 프레임 충돌 대상

// 두 배열을 비교하여 중복 제거
for (Old in OldOverlappingComponentPtrs)
{
    if (New contains Old)
    {
        // 계속 충돌 중 → 이벤트 없음
        OldOverlappingComponentPtrs.Remove(Old);
        NewOverlappingComponentPtrs.Remove(Old);
    }
}

// 결과:
// OldOverlappingComponentPtrs: EndOverlap 호출할 대상
// NewOverlappingComponentPtrs: BeginOverlap 호출할 대상</code></pre>

                <div class="hierarchy-box">[이전 프레임]          [현재 프레임]
Old = [A, B, C]   →   New = [B, C, D]

[비교 후]
Old = [A]         (EndOverlap)
New = [D]         (BeginOverlap)
중복 제거 = [B, C]  (이벤트 없음)</div>

                <h2>프레임별 Overlap 상태 변화</h2>
                <table>
                    <tr><th>Frame</th><th>Old</th><th>New</th><th>BeginOverlap</th><th>EndOverlap</th><th>유지</th></tr>
                    <tr><td>1</td><td>[]</td><td>[A]</td><td>A</td><td>-</td><td>-</td></tr>
                    <tr><td>2</td><td>[A]</td><td>[A, B]</td><td>B</td><td>-</td><td>A</td></tr>
                    <tr><td>3</td><td>[A, B]</td><td>[B, C]</td><td>C</td><td>A</td><td>B</td></tr>
                    <tr><td>4</td><td>[B, C]</td><td>[]</td><td>-</td><td>B, C</td><td>-</td></tr>
                </table>

                <h2>충돌 체크 조건</h2>
                <pre><code class="language-cpp">// 1. Actor가 World에 등록됨
const AActor* const MyActor = GetOwner();
if (MyActor && !MyActor->HasActorBegunPlay())
{
    return false;  // BeginPlay 전에는 충돌 체크 X
}

// 2. Overlap 이벤트 생성 활성화
if (GetGenerateOverlapEvents() && IsQueryCollisionEnabled())
{
    // 충돌 체크 진행
}</code></pre>

                <div class="callout warning">
                    <div class="callout-title">이전 프레임 vs 이전 충돌 대상</div>
                    <p>정확하게는 "이전 충돌 대상, 현재 충돌 대상"입니다. <strong>한 프레임에 여러 번 충돌 검사</strong>가 가능합니다.</p>
                </div>

                <pre><code class="language-cpp">void AMyActor::BeginPlay()
{
    // 한 프레임에 3번 이동 = 3번 충돌 체크
    SetActorLocation(FVector(0, 0, 0));    // 충돌 체크 1
    SetActorLocation(FVector(100, 0, 0));  // 충돌 체크 2
    SetActorLocation(FVector(200, 0, 0));  // 충돌 체크 3
}</code></pre>

                <div class="callout important">
                    <div class="callout-title">충돌 체크 7단계 핵심</div>
                    <p><strong>특수 로직 (엔진 최적화)</strong></p>
                    <ol>
                        <li>NewPendingOverlaps: 이동 경로상 충돌 → BeginOverlap만</li>
                        <li>OverlapsAtEndLocation: Transform 변화 없으면 재사용</li>
                    </ol>
                    <p><strong>일반 로직 (대부분의 경우)</strong></p>
                    <ol start="3">
                        <li>ComponentOverlapMulti: 현재 위치 충돌 체크</li>
                        <li>Old vs New 비교: 중복 제거</li>
                        <li>EndOverlap: Old에만 있는 것</li>
                        <li>BeginOverlap: New에만 있는 것</li>
                        <li>자식 재귀: 모든 자식 Component도 동일 과정</li>
                    </ol>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['comp-sec11'] = {
            title: '충돌 체크 구현',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Component</div>
                    <h1>충돌 체크 구현 (UpdateOverlapsImpl)</h1>
                </div>
                <h2>Overview</h2>
                <p>PrimitiveComponent의 <strong>실제 충돌 체크 로직</strong>입니다. SceneComponent는 거의 빈 함수이고, PrimitiveComponent에서 구현됩니다.</p>

                <h2>호출 경로</h2>
                <div class="hierarchy-box">SetActorLocation
└─ RootComponent->MoveComponent
    └─ MoveComponentImpl
        └─ UpdateOverlaps
            └─ UpdateOverlapsImpl  ← 여기!</div>

                <h2>SceneComponent vs PrimitiveComponent</h2>
                <pre><code class="language-cpp">bool USceneComponent::UpdateOverlapsImpl(...)
{
    // 자식만 업데이트 (자기 자신은 충돌 체크 안 함)
    for (USceneComponent* ChildComponent : AttachedChildren)
    {
        if (ChildComponent)
        {
            bCanSkipUpdateOverlaps &= ChildComponent->UpdateOverlaps(...);
        }
    }

    // Physics Volume 업데이트
    if (bShouldUpdatePhysicsVolume)
    {
        UpdatePhysicsVolume(bDoNotifies);
    }
}</code></pre>

                <div class="callout">
                    <div class="callout-title">SceneComponent는 충돌 기능 없음</div>
                    <p>Transform과 계층 구조만 담당합니다. 실제 충돌은 <strong>PrimitiveComponent</strong>가 처리합니다.</p>
                </div>

                <h2>PrimitiveComponent::UpdateOverlapsImpl</h2>
                <h3>사전 검증</h3>
                <pre><code class="language-cpp">// Owner가 존재하지 않거나 BeginPlay 전이면 충돌 체크 X
const AActor* const MyActor = GetOwner();
if (MyActor && !MyActor->HasActorBegunPlay() && !MyActor->IsActorBeginningPlay())
{
    return false;
}

// bGenerateOverlapEvents가 꺼져있으면 충돌 체크 X
if (GetGenerateOverlapEvents() && IsQueryCollisionEnabled())
{
    // 충돌 체크 진행...
}</code></pre>

                <h3>단계 1: NewPendingOverlaps 처리</h3>
                <pre><code class="language-cpp">// 움직이는 경로 상에서 잠시 겹쳤던 모든 대상들의 목록
if (NewPendingOverlaps)
{
    const int32 NumNewPendingOverlaps = NewPendingOverlaps->Num();
    for (int32 Idx = 0; Idx < NumNewPendingOverlaps; ++Idx)
    {
        // BeginOverlap만 호출
        BeginComponentOverlap((*NewPendingOverlaps)[Idx], bDoNotifies);
    }
}</code></pre>

                <h3>단계 3: 충돌 검사 (일반 로직)</h3>
                <pre><code class="language-cpp">TInlineComponentArray<FOverlapResult> Overlaps;

// 현재 위치와 채널을 기반으로 Overlap 결과 저장
ComponentOverlapMulti(
    Overlaps, MyWorld, GetComponentLocation(), GetComponentQuat(),
    GetCollisionObjectType(), Params
);

// 모든 충돌 대상 순회
for (int32 ResultIdx = 0; ResultIdx < Overlaps.Num(); ResultIdx++)
{
    const FOverlapResult& Result = Overlaps[ResultIdx];
    UPrimitiveComponent* const HitComp = Result.Component.Get();

    if (HitComp && (HitComp != this) && HitComp->GetGenerateOverlapEvents())
    {
        // WorldSettings 같은 특수 Actor인지 판별
        if (!ShouldIgnoreOverlapResult(MyWorld, MyActor, *this, ...))
        {
            // Overlap 대상에 추가
            OverlapMultiResult.Emplace(HitComp, Result.ItemIndex);
        }
    }
}

// NewOverlappingComponentPtrs에 추가
GetPointersToArrayData(NewOverlappingComponentPtrs, OverlapMultiResult);</code></pre>

                <h3>단계 4: Old vs New 비교</h3>
                <pre><code class="language-cpp">// 현재 겹쳐있는 Component가 있는 경우
if (OverlappingComponents.Num() > 0)
{
    TInlineOverlapPointerArray OldOverlappingComponentPtrs;

    // 기존 충돌 Component와 새로운 충돌 Component 비교
    // 동일한 대상이 있으면 양쪽에서 제거
    for (int32 CompIdx = 0; CompIdx < OldOverlappingComponentPtrs.Num(); ++CompIdx)
    {
        const FOverlapInfo* SearchItem = OldOverlappingComponentPtrs[CompIdx];
        const int32 NewElementIdx = IndexOfOverlapFast(NewOverlappingComponentPtrs, SearchItem);

        if (NewElementIdx != INDEX_NONE)
        {
            // 양쪽에 있음 → 제거 (충돌 변화 없음)
            NewOverlappingComponentPtrs.RemoveAtSwap(NewElementIdx);
            OldOverlappingComponentPtrs.RemoveAtSwap(CompIdx);
            --CompIdx;
        }
    }
}</code></pre>

                <h3>단계 5: EndOverlap 호출</h3>
                <pre><code class="language-cpp">// Old에 남아있는 Component = 이전에는 충돌했지만 현재는 충돌 안 함
for (const FOverlapInfo& OtherOverlap : OldOverlappingComponents)
{
    if (OtherOverlap.OverlapInfo.Component.IsValid())
    {
        EndComponentOverlap(OtherOverlap, bDoNotifies, false);
    }
    else
    {
        // Valid하지 않으면 제거만
        OverlappingComponents.RemoveAtSwap(StaleElementIndex);
    }
}</code></pre>

                <h3>단계 6: BeginOverlap 호출</h3>
                <pre><code class="language-cpp">// New에 남아있는 Component = 현재 새롭게 충돌됨
for (const FOverlapInfo* NewOverlap : NewOverlappingComponentPtrs)
{
    BeginComponentOverlap(*NewOverlap, bDoNotifies);
}</code></pre>

                <h3>단계 7: 자식 Component 재귀</h3>
                <pre><code class="language-cpp">// 자식 Component도 동일하게 UpdateOverlaps 호출
for (USceneComponent* const ChildComp : AttachedChildren)
{
    if (ChildComp)
    {
        bCanSkipUpdateOverlaps &= ChildComp->UpdateOverlaps(nullptr, bDoNotifies, nullptr);
    }
}</code></pre>

                <h2>최적화 팁</h2>
                <pre><code class="language-cpp">// ❌ 나쁜 예: BeginPlay에서 여러 번 이동
void AMyActor::BeginPlay()
{
    Super::BeginPlay();
    SetActorLocation(FVector(0, 0, 0));    // 충돌 체크 1
    SetActorLocation(FVector(100, 0, 0));  // 충돌 체크 2
    SetActorLocation(FVector(200, 0, 0));  // 충돌 체크 3
    // 총 3번 충돌 체크!
}

// ✅ 좋은 예: 최종 위치로 한 번만
void AMyActor::BeginPlay()
{
    Super::BeginPlay();
    SetActorLocation(FVector(200, 0, 0));  // 충돌 체크 1번만!
}</code></pre>

                <div class="callout warning">
                    <div class="callout-title">충돌 체크는 매우 무거운 연산!</div>
                    <ul>
                        <li>공간 쿼리 (Spatial Query)</li>
                        <li>모든 충돌 대상 순회</li>
                        <li>Old vs New 비교</li>
                        <li>이벤트 호출</li>
                    </ul>
                    <p><strong>최적화가 필수!</strong></p>
                </div>

                <div class="callout important">
                    <div class="callout-title">UpdateOverlapsImpl 핵심</div>
                    <ol>
                        <li><strong>BeginPlay 전에는 충돌 체크 안 함</strong></li>
                        <li><strong>ComponentOverlapMulti</strong>로 실제 충돌 검사</li>
                        <li><strong>Old vs New 비교</strong>로 중복 제거</li>
                        <li><strong>EndOverlap → BeginOverlap</strong> 순서로 호출</li>
                        <li><strong>자식 Component도 재귀</strong>로 체크</li>
                    </ol>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['comp-sec12'] = {
            title: 'BeginOverlap, EndOverlap',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Component</div>
                    <h1>BeginOverlap, EndOverlap</h1>
                </div>
                <h2>Overview</h2>
                <p>Overlap 이벤트 호출 규칙: <strong>Component 레벨</strong>은 항상 호출되지만, <strong>Actor 레벨</strong>은 해당 Actor끼리 처음 Overlap일 때만 호출됩니다.</p>

                <h2>BeginComponentOverlap 프로세스</h2>
                <div class="flow-vertical">
                    <div class="flow-node">BeginComponentOverlap 호출</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">이미 Overlap 중?</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--success); color: #fff;">OverlappingComponents에 추가</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">상대 Component에도 추가</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--warning); color: #000;">Component Overlap 이벤트</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--info); color: #fff;">Actor 처음 Overlap? → Actor 이벤트</div>
                </div>

                <h2>OverlappingComponents에 추가</h2>
                <pre><code class="language-cpp">AActor* const MyActor = GetOwner();
AActor* const OtherActor = OtherComp ? OtherComp->GetOwner() : nullptr;
const bool bSameActor = (MyActor == OtherActor);

// 나의 Overlap에 상대 추가
OverlappingComponents.Add(OtherOverlap);

// 상대의 Overlap에 나 추가
AddUniqueOverlapFast(OtherComp->OverlappingComponents, FOverlapInfo(this, INDEX_NONE));</code></pre>

                <div class="hierarchy-box">[BeginOverlap 전]
A->OverlappingComponents = []
B->OverlappingComponents = []

[BeginOverlap 후]
A->OverlappingComponents = [B]
B->OverlappingComponents = [A]</div>

                <h2>Actor 처음 Overlap인지 확인 ⭐</h2>
                <pre><code class="language-cpp">// 새로 겹쳐지는 Actor인지 체크
// Component끼리는 처음 Overlap일 수도 있는데
// Actor는 이미 겹쳐진 상태일 수 있음
// → Actor BeginOverlap 중복 호출 방지!
const bool bNotifyActorTouch = bDoNotifies &&
    !bSameActor &&
    !AreActorsOverlapping(*MyActor, *OtherActor);</code></pre>

                <h3>AreActorsOverlapping 동작 원리</h3>
                <pre><code class="language-cpp">bool UPrimitiveComponent::AreActorsOverlapping(const AActor& Actor1, const AActor& Actor2)
{
    // Actor1의 모든 Component 순회
    for (UPrimitiveComponent* Comp1 : Actor1.GetComponents<UPrimitiveComponent>())
    {
        // Comp1이 Actor2의 어떤 Component와 Overlap 중인지 확인
        for (const FOverlapInfo& Overlap : Comp1->OverlappingComponents)
        {
            if (Overlap.OverlapInfo.Component->GetOwner() == &Actor2)
            {
                return true;  // 이미 Overlap 중!
            }
        }
    }
    return false;  // 처음 Overlap
}</code></pre>

                <div class="hierarchy-box">Actor A:
    └─ Comp1 (충돌 없음)
    └─ Comp2 (충돌 없음)

Actor B:
    └─ Comp3 (충돌 없음)

[Comp1 ↔ Comp3 충돌]
bNotifyActorTouch = true  → Actor BeginOverlap 호출!

[Comp2 ↔ Comp3 충돌]
bNotifyActorTouch = false → Actor BeginOverlap 호출 안 함 (이미 Overlap 중)</div>

                <h2>Overlap 이벤트 호출</h2>
                <pre><code class="language-cpp">// World BeginPlay 전에는 호출 안 함!
if (bDoNotifies && ((World && World->HasBegunPlay()))
{
    // 1. Component BeginOverlap (나 + 상대 모두)
    if (IsValid(this))
    {
        OnComponentBeginOverlap.Broadcast(this, OtherActor, OtherComp, ...);
    }
    if (IsValid(OtherComp))
    {
        OtherComp->OnComponentBeginOverlap.Broadcast(OtherComp, MyActor, this, ...);
    }

    // 2. Actor BeginOverlap (처음 Overlap인 경우만!)
    if (bNotifyActorTouch)
    {
        MyActor->NotifyActorBeginOverlap(OtherActor);
        OtherActor->NotifyActorBeginOverlap(MyActor);
    }
}</code></pre>

                <h2>Component vs Actor Overlap 비교</h2>
                <table>
                    <tr><th>이벤트</th><th>호출 조건</th><th>횟수</th></tr>
                    <tr><td>Component BeginOverlap</td><td>두 Component가 충돌 시작</td><td>Component마다</td></tr>
                    <tr><td>Actor BeginOverlap</td><td>두 Actor가 <strong>처음으로</strong> 충돌 시작</td><td>Actor당 1번만</td></tr>
                    <tr><td>Component EndOverlap</td><td>두 Component가 충돌 종료</td><td>Component마다</td></tr>
                    <tr><td>Actor EndOverlap</td><td>두 Actor가 <strong>완전히</strong> 충돌 종료</td><td>Actor당 1번만</td></tr>
                </table>

                <h2>예시 시나리오</h2>
                <div class="hierarchy-box">Actor A (3개 Component):
    └─ CompA1
    └─ CompA2
    └─ CompA3

Actor B (2개 Component):
    └─ CompB1
    └─ CompB2</div>

                <table>
                    <tr><th>시나리오</th><th>Component 이벤트</th><th>Actor 이벤트</th></tr>
                    <tr><td>CompA1 ↔ CompB1 충돌</td><td>2번 (CompA1, CompB1)</td><td>2번 (처음!)</td></tr>
                    <tr><td>CompA2 ↔ CompB1 충돌</td><td>2번 (CompA2, CompB1)</td><td>0번 (이미 Overlap 중)</td></tr>
                    <tr><td>CompA1 ↔ CompB1 종료</td><td>2번 (CompA1, CompB1)</td><td>0번 (CompA2-CompB1 충돌 중)</td></tr>
                    <tr><td>CompA2 ↔ CompB1 종료</td><td>2번 (CompA2, CompB1)</td><td>2번 (모든 충돌 종료!)</td></tr>
                </table>

                <h2>Overlap 이벤트 사용법</h2>
                <h3>Component 레벨 처리</h3>
                <pre><code class="language-cpp">UCLASS()
class AMyActor : public AActor
{
    UPROPERTY()
    UBoxComponent* TriggerBox;

    UFUNCTION()
    void OnTriggerBeginOverlap(
        UPrimitiveComponent* OverlappedComp,
        AActor* OtherActor,
        UPrimitiveComponent* OtherComp,
        int32 OtherBodyIndex,
        bool bFromSweep,
        const FHitResult& SweepResult);
};

AMyActor::AMyActor()
{
    TriggerBox = CreateDefaultSubobject<UBoxComponent>(TEXT("Trigger"));
    TriggerBox->OnComponentBeginOverlap.AddDynamic(this, &AMyActor::OnTriggerBeginOverlap);
}</code></pre>

                <h3>Actor 레벨 처리</h3>
                <pre><code class="language-cpp">void AMyActor::NotifyActorBeginOverlap(AActor* OtherActor)
{
    Super::NotifyActorBeginOverlap(OtherActor);
    UE_LOG(LogTemp, Warning, TEXT("Actor Overlap: %s"), *OtherActor->GetName());
}</code></pre>

                <div class="callout warning">
                    <div class="callout-title">흔한 실수</div>
                    <ol>
                        <li><strong>BeginPlay 전에 이동</strong>: Overlap 이벤트 안 불림</li>
                        <li><strong>Component vs Actor 혼동</strong>: 호출 조건 다름</li>
                        <li><strong>bGenerateOverlapEvents = false</strong>: 이벤트 안 불림</li>
                        <li><strong>Collision Enabled = NoCollision</strong>: 충돌 자체가 안 일어남</li>
                    </ol>
                </div>

                <div class="callout important">
                    <div class="callout-title">Overlap 이벤트 핵심</div>
                    <ol>
                        <li><strong>Component 레벨</strong>: Component끼리 충돌할 때마다 호출</li>
                        <li><strong>Actor 레벨</strong>: Actor끼리 처음/마지막 충돌일 때만 호출</li>
                        <li><strong>중복 방지</strong>: AreActorsOverlapping으로 Actor 중복 체크</li>
                        <li><strong>BeginPlay 전</strong>: Overlap 이벤트 호출 안 함</li>
                        <li><strong>양방향</strong>: 나와 상대 모두에게 이벤트 호출</li>
                    </ol>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['comp-sec13'] = {
            title: 'Weld 개념',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Component</div>
                    <h1>Weld 개념</h1>
                </div>
                <h2>Overview</h2>
                <p>Weld는 2개 이상의 물리 시뮬레이션 Component를 <strong>하나처럼 용접</strong>하는 기능입니다. 물리 시뮬레이션을 통합하여 성능을 향상시킵니다.</p>

                <h2>Weld의 필요성</h2>
                <h3>문제 상황</h3>
                <div class="hierarchy-box">[Weld 없이]
차량 (물리 시뮬레이션)
캐릭터 (물리 시뮬레이션)

→ 각자 독립적으로 물리 계산
→ 서로 미세하게 다른 움직임
→ 캐릭터가 차량 위에서 덜덜 떨림
→ 성능 낭비 (2개의 물리 시뮬레이션)</div>

                <div class="hierarchy-box">[프레임 1]
차량: (100, 0, 0)
캐릭터: (100, 0, 100)  ← 차량 위

[프레임 2 - 차량 이동]
차량: (110, 0, 0)
캐릭터: (109.99, 0, 100.01)  ← 미세하게 어긋남!

[프레임 3]
차량: (120, 0, 0)
캐릭터: (120.02, 0, 99.98)  ← 계속 떨림</div>

                <h3>Weld 적용 시</h3>
                <div class="hierarchy-box">[Weld 적용]
차량 + 캐릭터 → 하나의 물리 Body

→ 단일 물리 시뮬레이션
→ 완벽하게 동기화된 움직임
→ 성능 향상 (1개의 물리 시뮬레이션)</div>

                <h2>Attach vs Weld</h2>
                <table>
                    <tr><th>항목</th><th>Attach</th><th>Weld</th></tr>
                    <tr><td>Transform 동기화</td><td>✅</td><td>✅</td></tr>
                    <tr><td>물리 통합</td><td>❌</td><td>✅</td></tr>
                    <tr><td>각자 물리 시뮬레이션</td><td>✅ (독립적)</td><td>❌ (통합)</td></tr>
                    <tr><td>떨림 현상</td><td>발생 가능</td><td>없음</td></tr>
                    <tr><td>성능</td><td>낮음 (2개)</td><td>높음 (1개)</td></tr>
                </table>

                <h2>동작 차이</h2>
                <pre><code class="language-cpp">// ❌ Attach만 사용
Weapon->AttachToComponent(
    Character->GetMesh(),
    FAttachmentTransformRules::SnapToTargetIncludingScale,
    TEXT("hand_r")
);
// → Transform은 따라가지만 물리는 독립적
// → 캐릭터가 움직이면 무기가 흔들림

// ✅ Attach + Weld
Weapon->AttachToComponent(
    Character->GetMesh(),
    FAttachmentTransformRules::SnapToTargetIncludingScale,
    TEXT("hand_r")
);
Weapon->WeldTo(Character->GetMesh(), TEXT("hand_r"));
// → Transform + 물리 모두 통합
// → 완벽한 동기화</code></pre>

                <h2>AttachToComponent에서의 Weld</h2>
                <pre><code class="language-cpp">bool USceneComponent::AttachToComponent(
    USceneComponent* Parent,
    const FAttachmentTransformRules& AttachmentRules,
    FName SocketName)
{
    // ... Attach 로직 ...

    // Weld 처리
    if (AttachmentRules.bWeldSimulatedBodies)
    {
        if (UPrimitiveComponent* PrimitiveComponent = Cast<UPrimitiveComponent>(this))
        {
            if (FBodyInstance* BI = PrimitiveComponent->GetBodyInstance())
            {
                PrimitiveComponent->WeldToImplementation(
                    GetAttachParent(),
                    GetAttachSocketName(),
                    AttachmentRules.bWeldSimulatedBodies
                );
            }
        }
    }

    return true;
}</code></pre>

                <h2>실전 예시</h2>
                <h3>차량 탑승</h3>
                <pre><code class="language-cpp">void ACharacter::EnterVehicle(AVehicle* Vehicle)
{
    if (!Vehicle) return;

    // 1. 차량에 부착
    RootComponent->AttachToComponent(
        Vehicle->GetRootComponent(),
        FAttachmentTransformRules::KeepWorldTransform
    );

    // 2. 물리 통합 (Weld)
    if (UPrimitiveComponent* PrimComp = Cast<UPrimitiveComponent>(RootComponent))
    {
        PrimComp->WeldTo(Vehicle->GetRootComponent());
    }

    // 3. 충돌 끄기 (옵션)
    GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::NoCollision);
}

void ACharacter::ExitVehicle()
{
    // 1. UnWeld
    if (UPrimitiveComponent* PrimComp = Cast<UPrimitiveComponent>(RootComponent))
    {
        PrimComp->UnWeldFromParent();
    }

    // 2. 분리
    RootComponent->DetachFromComponent(FDetachmentTransformRules::KeepWorldTransform);

    // 3. 충돌 다시 활성화
    GetCapsuleComponent()->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);
}</code></pre>

                <h3>무기 장착</h3>
                <pre><code class="language-cpp">void ACharacter::EquipWeapon(AWeapon* Weapon)
{
    if (!Weapon) return;

    // AttachmentRules에서 bWeldSimulatedBodies = true
    FAttachmentTransformRules Rules(EAttachmentRule::SnapToTarget, true);

    // Attach + Weld 자동 처리
    Weapon->GetRootComponent()->AttachToComponent(
        GetMesh(), Rules, TEXT("hand_r")
    );
}</code></pre>

                <h2>FAttachmentTransformRules</h2>
                <pre><code class="language-cpp">struct FAttachmentTransformRules
{
    EAttachmentRule LocationRule;
    EAttachmentRule RotationRule;
    EAttachmentRule ScaleRule;
    bool bWeldSimulatedBodies;  // ← Weld 여부

    // 미리 정의된 Rules
    static const FAttachmentTransformRules KeepRelativeTransform;
    static const FAttachmentTransformRules KeepWorldTransform;
    static const FAttachmentTransformRules SnapToTargetNotIncludingScale;
    static const FAttachmentTransformRules SnapToTargetIncludingScale;  // bWeld = true
};</code></pre>

                <h2>Weld의 장단점</h2>
                <table>
                    <tr><th>장점</th><th>단점</th></tr>
                    <tr><td>떨림 현상 제거</td><td>복잡성 증가 (Weld/UnWeld 관리)</td></tr>
                    <tr><td>성능 향상</td><td>특수 케이스 처리 필요</td></tr>
                    <tr><td>안정성 증가</td><td></td></tr>
                </table>

                <div class="callout important">
                    <div class="callout-title">Weld 핵심</div>
                    <ol>
                        <li><strong>물리 시뮬레이션을 통합</strong>하여 하나처럼 동작</li>
                        <li><strong>AttachToComponent</strong>와 함께 사용
                            <ul>
                                <li>AttachmentRules.bWeldSimulatedBodies = true</li>
                                <li>또는 명시적으로 WeldTo() 호출</li>
                            </ul>
                        </li>
                        <li><strong>DetachFromComponent</strong>에서 자동 UnWeld</li>
                        <li><strong>주요 사용처</strong>: 차량 탑승, 무기 장착, 물리 객체 들기</li>
                    </ol>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['comp-sec14'] = {
            title: 'SkeletalMesh 개념',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Component</div>
                    <h1>SkeletalMesh 개념</h1>
                </div>
                <h2>Overview</h2>
                <p>SkeletalMesh 계층 구조: <strong>Skeleton</strong>(뼈대) → <strong>SkeletalMesh</strong>(Asset) → <strong>SkeletalMeshComponent</strong>(Instance)</p>

                <h2>Component 계층 구조</h2>
                <div class="hierarchy-box">UPrimitiveComponent
└─ UMeshComponent
    └─ USkinnedMeshComponent (Bone + Skinning) ◀
        └─ USkeletalMeshComponent (Animation) ◀</div>

                <h2>상속 관계와 역할</h2>
                <h3>USkinnedMeshComponent</h3>
                <pre><code class="language-cpp">class USkinnedMeshComponent : public UMeshComponent
{
    // Bone 정보
    TArray<FTransform> ComponentSpaceTransforms;

    // Skinning (Vertex가 Bone을 따라감)
    void UpdateSkinWeights();

    // 소켓 정보
    FTransform GetSocketTransform(FName SocketName);
};</code></pre>

                <div class="callout">
                    <div class="callout-title">특징</div>
                    <ul>
                        <li><strong>Bone 정보</strong> 추가</li>
                        <li><strong>Skinning 작업</strong> (Mesh가 뼈를 따라 변형)</li>
                        <li><strong>애니메이션 실행 X</strong></li>
                    </ul>
                </div>

                <h3>USkeletalMeshComponent</h3>
                <pre><code class="language-cpp">class USkeletalMeshComponent : public USkinnedMeshComponent
{
    // SkeletalMesh Asset
    UPROPERTY()
    TObjectPtr<USkeletalMesh> SkeletalMeshAsset;

    // Animation Instance
    UPROPERTY()
    TSubclassOf<UAnimInstance> AnimClass;

    // Animation 재생
    void PlayAnimation(UAnimSequence* Animation);
};</code></pre>

                <h2>SkeletalMesh Asset 구조</h2>
                <pre><code class="language-cpp">class USkeletalMesh : public USkinnedAsset
{
    // 1. 뼈대 정보
    UPROPERTY()
    TObjectPtr<USkeleton> Skeleton;

    // 2. Mesh 정보 (외형)
    UPROPERTY()
    TArray<FSkeletalMeshSourceModel> SourceModels;

    // 3. 색깔 정보
    UPROPERTY()
    TArray<FSkeletalMaterial> Materials;

    // 4. 소켓 정보
    UPROPERTY()
    TArray<TObjectPtr<USkeletalMeshSocket>> Sockets;
};</code></pre>

                <h2>구성 요소 상세</h2>
                <h3>1. Skeleton (뼈대)</h3>
                <pre><code class="language-cpp">class USkeleton : public UObject
{
    // Bone 계층 구조
    FReferenceSkeleton ReferenceSkeleton;

    // Skeleton 소켓 (모든 Mesh 공유)
    TArray<TObjectPtr<USkeletalMeshSocket>> Sockets;

    // Animation Curve
    FSmartNameMapping CurveNameMapping;
};</code></pre>

                <div class="hierarchy-box">Skeleton: "HumanoidSkeleton"
├─ SkeletalMesh: "Warrior" (전사 외형)
├─ SkeletalMesh: "Mage" (마법사 외형)
└─ SkeletalMesh: "Rogue" (도적 외형)

→ 같은 Skeleton이므로 Animation 공유 가능!</div>

                <h3>4. Sockets (소켓)</h3>
                <pre><code class="language-cpp">class USkeletalMeshSocket : public UObject
{
    // Socket 이름
    FName SocketName;

    // 어느 Bone에 부착되는지
    FName BoneName;

    // Bone 기준 상대 Transform
    FVector RelativeLocation;
    FRotator RelativeRotation;
    FVector RelativeScale;
};</code></pre>

                <h2>Skeleton vs SkeletalMesh vs SkeletalMeshComponent</h2>
                <table>
                    <tr><th>항목</th><th>Skeleton</th><th>SkeletalMesh</th><th>SkeletalMeshComponent</th></tr>
                    <tr><td>역할</td><td>뼈대 정보</td><td>Asset (설계도)</td><td>Instance (실체)</td></tr>
                    <tr><td>Bone</td><td>✅</td><td>✅ (참조)</td><td>✅ (참조)</td></tr>
                    <tr><td>Mesh</td><td>❌</td><td>✅</td><td>✅ (참조)</td></tr>
                    <tr><td>Material</td><td>❌</td><td>✅</td><td>✅ (참조)</td></tr>
                    <tr><td>Socket</td><td>✅ (공유)</td><td>✅ (개별)</td><td>✅ (참조)</td></tr>
                    <tr><td>Animation</td><td>❌</td><td>❌</td><td>✅</td></tr>
                    <tr><td>World 배치</td><td>❌</td><td>❌</td><td>✅</td></tr>
                </table>

                <div class="hierarchy-box">USkeleton (뼈대)
└─ USkeletalMesh (뼈대 + 옷 + 피부)
    └─ USkeletalMeshComponent (World Instance + Animation)

[비유]
Skeleton       = 인체 뼈대
SkeletalMesh   = 뼈대에 옷과 피부를 입힌 캐릭터 모습
SkeletalMeshComponent = 실제 게임 월드에 생성된 인스턴스</div>

                <h2>실전 예시</h2>
                <h3>캐릭터 설정</h3>
                <pre><code class="language-cpp">ACharacter::ACharacter()
{
    // SkeletalMeshComponent 생성
    GetMesh()->SetSkeletalMesh(
        LoadObject<USkeletalMesh>(nullptr, TEXT("/Game/Characters/Warrior_Mesh"))
    );

    // Animation Blueprint 설정
    GetMesh()->SetAnimInstanceClass(
        LoadClass<UAnimInstance>(nullptr, TEXT("/Game/Characters/WarriorAnimBP"))
    );
}</code></pre>

                <h3>Mesh 교체 (같은 Skeleton)</h3>
                <pre><code class="language-cpp">void ACharacter::ChangeCostume(USkeletalMesh* NewMesh)
{
    // Skeleton이 같으면 Mesh만 교체 가능
    // Animation은 계속 재생됨!
    GetMesh()->SetSkeletalMesh(NewMesh);
}

// 사용 예시
ChangeCostume(WarriorMesh);  // 전사 외형
ChangeCostume(MageMesh);     // 마법사 외형 (Animation 유지!)</code></pre>

                <h2>Skeleton vs SkeletalMesh Socket</h2>
                <table>
                    <tr><th>타입</th><th>범위</th><th>사용 예시</th></tr>
                    <tr><td>Skeleton Socket</td><td>모든 Mesh 공유</td><td>"spine_01" (등 뒤 무기)</td></tr>
                    <tr><td>SkeletalMesh Socket</td><td>해당 Mesh만</td><td>"MageStaff" (마법사만)</td></tr>
                </table>

                <div class="callout important">
                    <div class="callout-title">SkeletalMesh 핵심</div>
                    <ol>
                        <li><strong>계층 구조</strong>: Skeleton → SkeletalMesh → SkeletalMeshComponent</li>
                        <li><strong>Skeleton 공유로 Animation 재사용</strong></li>
                        <li><strong>Socket 2종류</strong>: Skeleton Socket (공유), SkeletalMesh Socket (개별)</li>
                        <li><strong>SkinnedMeshComponent vs SkeletalMeshComponent</strong>: Bone+Skinning vs +Animation</li>
                    </ol>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['comp-sec15'] = {
            title: '소켓 트랜스폼',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Component</div>
                    <h1>소켓 트랜스폼</h1>
                </div>
                <h2>Overview</h2>
                <p>Socket Transform 계산 순서: SkeletalMesh → Skeleton → Bone. <strong>Socket World = Socket Local × Bone World</strong></p>

                <h2>Socket 탐색 순서</h2>
                <div class="flow-vertical">
                    <div class="flow-node">GetSocketTransform</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">SocketOverride?</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--success); color: #fff;">1. SkeletalMesh에서 탐색</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--warning); color: #000;">2. Skeleton에서 탐색</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--info); color: #fff;">3. Bone으로 탐색</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Socket Transform 반환</div>
                </div>

                <h2>GetSocketTransform</h2>
                <pre><code class="language-cpp">FTransform USkinnedMeshComponent::GetSocketTransform(
    FName InSocketName,
    ERelativeTransformSpace TransformSpace) const
{
    if (InSocketName != NAME_None)
    {
        FTransform SocketLocalTransform;
        int32 SocketBoneIndex;

        // Socket 정보 가져오기
        USkeletalMeshSocket const* const Socket = GetSocketInfoByName(
            InSocketName, SocketLocalTransform, SocketBoneIndex
        );

        if (Socket)
        {
            // Socket을 찾은 경우 처리...
        }
        else
        {
            // Socket을 못 찾은 경우 Bone으로 시도...
        }
    }

    // TransformSpace에 맞게 변환
    return OutSocketTransform;
}</code></pre>

                <h2>GetSocketInfoByName - Socket 탐색</h2>
                <pre><code class="language-cpp">const USkeletalMeshSocket* USkinnedMeshComponent::GetSocketInfoByName(
    FName InSocketName,
    FTransform& OutTransform,
    int32& OutBoneIndex) const
{
    // Socket Override 여부 확인
    const FName* OverrideSocket = SocketOverrideLookup.Find(InSocketName);
    const FName OverrideSocketName = OverrideSocket ? *OverrideSocket : InSocketName;

    // SkinnedAsset(SkeletalMesh)에서 Socket 탐색
    USkeletalMeshSocket const* Socket = nullptr;
    if (GetSkinnedAsset())
    {
        int32 SocketIndex;
        Socket = GetSkinnedAsset()->FindSocketInfo(
            OverrideSocketName, OutTransform, OutBoneIndex, SocketIndex
        );
    }
    return Socket;
}</code></pre>

                <div class="callout">
                    <div class="callout-title">Socket Override란?</div>
                    <p>Socket 이름을 다른 이름으로 <strong>매핑</strong>. 런타임에 Socket 동적 변경 가능.</p>
                </div>

                <h2>FindSocketInfo - SkeletalMesh vs Skeleton</h2>
                <pre><code class="language-cpp">USkeletalMeshSocket* USkeletalMesh::FindSocketInfo(
    FName InSocketName,
    FTransform& OutTransform,
    int32& OutBoneIndex,
    int32& OutIndex) const
{
    // 1️⃣ SkeletalMesh에서 Socket 먼저 탐색
    for (int32 i = 0; i < Sockets.Num(); i++)
    {
        USkeletalMeshSocket* Socket = Sockets[i];
        if (Socket && Socket->SocketName == InSocketName)
        {
            OutIndex = i;
            OutTransform = Socket->GetSocketLocalTransform();
            OutBoneIndex = GetRefSkeleton().FindBoneIndex(Socket->BoneName);
            return Socket;
        }
    }

    // 2️⃣ SkeletalMesh에 없다면 Skeleton에서 Socket 탐색
    if (GetSkeleton())
    {
        USkeletalMeshSocket* SkeletonSocket = GetSkeleton()->FindSocketAndIndex(
            InSocketName, OutIndex
        );

        if (SkeletonSocket != nullptr)
        {
            // Socket Index 오프셋 부여
            OutIndex += Sockets.Num();
            OutTransform = SkeletonSocket->GetSocketLocalTransform();
            OutBoneIndex = GetRefSkeleton().FindBoneIndex(SkeletonSocket->BoneName);
        }
        return SkeletonSocket;
    }
    return nullptr;
}</code></pre>

                <div class="hierarchy-box">SkeletalMesh "WarriorMesh":
    Sockets: ["SpecialWeapon"]  // 전사만 사용

Skeleton "HumanoidSkeleton":
    Sockets: ["hand_r", "hand_l", "back_weapon"]  // 모든 캐릭터 사용

탐색 "hand_r":
1. WarriorMesh에서 탐색 → 없음
2. Skeleton에서 탐색 → 찾음! ✅

탐색 "SpecialWeapon":
1. WarriorMesh에서 탐색 → 찾음! ✅
2. Skeleton 탐색 안 함</div>

                <h2>Socket Transform 계산</h2>
                <h3>Socket을 찾은 경우</h3>
                <pre><code class="language-cpp">if (Socket)
{
    // Socket은 Bone에 상대적으로 붙어있음
    // Bone World Transform × Socket Local Transform = Socket World Transform
    if (SocketBoneIndex != INDEX_NONE)
    {
        FTransform BoneTransform = GetBoneTransform(SocketBoneIndex);
        OutSocketTransform = SocketLocalTransform * BoneTransform;
    }
}</code></pre>

                <div class="hierarchy-box">손뼈 World Transform: (100, 200, 300)
Socket Local Transform: (10, 0, 0)

Socket World Transform = (10, 0, 0) × (100, 200, 300)
                       = (110, 200, 300)</div>

                <h3>Socket을 못 찾은 경우: Bone으로 탐색</h3>
                <pre><code class="language-cpp">else
{
    // Socket 이름과 일치하는 Bone 탐색
    int32 BoneIndex = GetBoneIndex(InSocketName);

    if (BoneIndex != INDEX_NONE)
    {
        OutSocketTransform = GetBoneTransform(BoneIndex);
    }
}</code></pre>

                <div class="callout tip">
                    <div class="callout-title">Bone Fallback</div>
                    <p>"hand_r" Socket이 없어도 "hand_r" Bone이 있으면 동작!</p>
                </div>

                <pre><code class="language-cpp">// Socket 없어도 Bone 이름으로 부착 가능
Weapon->AttachToComponent(
    GetMesh(),
    FAttachmentTransformRules::SnapToTargetIncludingScale,
    TEXT("hand_r")  // Socket 없어도 Bone 이름으로 부착 가능
);</code></pre>

                <h2>실전 예시</h2>
                <h3>이펙트 생성 (Socket Transform 가져오기)</h3>
                <pre><code class="language-cpp">void ACharacter::SpawnMuzzleFlash()
{
    // "muzzle" Socket의 World Transform 가져오기
    FTransform MuzzleTransform = GetMesh()->GetSocketTransform(TEXT("muzzle"), RTS_World);

    // 이펙트 생성
    UGameplayStatics::SpawnEmitterAtLocation(GetWorld(), MuzzleFlashEffect, MuzzleTransform);
}</code></pre>

                <h3>Socket Override 사용</h3>
                <pre><code class="language-cpp">// 런타임에 Socket 변경
void ACharacter::SwitchWeaponSocket()
{
    // "hand_r"을 "hand_l"로 Override
    GetMesh()->AddSocketOverride(TEXT("hand_r"), TEXT("hand_l"));

    // 이제 "hand_r"로 부착해도 실제로는 "hand_l"에 부착됨!
    Weapon->AttachToComponent(
        GetMesh(),
        FAttachmentTransformRules::SnapToTargetIncludingScale,
        TEXT("hand_r")
    );
}</code></pre>

                <h2>Socket 탐색 순서 요약</h2>
                <div class="hierarchy-box">1. SkeletalMesh Socket 탐색
    ↓ (없으면)
2. Skeleton Socket 탐색
    ↓ (없으면)
3. Bone 탐색
    ↓ (없으면)
4. Component Transform 반환</div>

                <div class="callout important">
                    <div class="callout-title">Socket Transform 핵심</div>
                    <ol>
                        <li><strong>탐색 순서</strong>: SkeletalMesh Socket (우선) → Skeleton Socket (공유) → Bone (Fallback)</li>
                        <li><strong>Transform 계산</strong>: Socket World = Socket Local × Bone World</li>
                        <li><strong>Socket Override</strong>: 런타임에 Socket 동적 변경 가능</li>
                        <li><strong>TransformSpace</strong>: World, Actor, Component, ParentBoneSpace 지원</li>
                    </ol>
                </div>

                <div class="callout tip">
                    <div class="callout-title">Component 시스템 학습 완료!</div>
                    <p>이것으로 Component 시스템의 핵심 개념을 모두 다루었습니다.</p>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        // ========================================
        // Object Constructor: UObject 생성 및 관리 (5.81~5.84)
        // ========================================

        sectionData['obj-sec1'] = {
            title: 'CDO 개념',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Object Constructor</div>
                    <h1>CDO 개념</h1>
                </div>
                <h2>Overview</h2>
                <p><strong>CDO (Class Default Object)</strong>: UObject를 상속받은 클래스의 기본 설계도 역할을 하는 오브젝트. 클래스당 1개만 존재하며 모든 인스턴스의 기본값을 제공합니다.</p>

                <h2>핵심 질문</h2>
                <div class="callout">
                    <div class="callout-title">왜 헤더 파일에 기본값을 설정하지 않고 CDO를 사용하는가?</div>
                    <p>런타임 유연성과 에디터 통합을 위한 핵심 메커니즘입니다.</p>
                </div>

                <h2>CDO 구조</h2>
                <div class="hierarchy-box">UClass (메타데이터)
├─ 클래스 정보
├─ 프로퍼티 목록
├─ 함수 목록
└─ CDO 포인터 ────┐
                  │
                  ↓
      ┌────────────────────┐
      │  CDO (기본값 보관소) │
      ├────────────────────┤
      │  HP = 100          │
      │  Speed = 300       │
      │  AttackPower = 50  │
      └────────┬───────────┘
               │ 기본값 복사
      ┌────────┴────────┐
      ↓                 ↓
  Instance #1       Instance #2
  HP = 100          HP = 100</div>

                <h2>헤더 기본값 vs CDO</h2>
                <h3>헤더 기본값의 한계</h3>
                <pre><code class="language-cpp">// ❌ 헤더 파일 기본값 방식
class AWarriorCharacter : public ACharacter
{
public:
    int32 HP = 100;  // 컴파일 타임에 고정
};

// 문제점:
// 1. ❌ 런타임에 변경 불가
// 2. ❌ 에디터에서 보이지 않음
// 3. ❌ 블루프린트 접근 불가
// 4. ❌ 값 변경 시 재컴파일 필수</code></pre>

                <h3>CDO 방식의 장점</h3>
                <pre><code class="language-cpp">// ✅ CDO 방식
UCLASS()
class AWarriorCharacter : public ACharacter
{
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    int32 HP = 100;
};

// 장점:
// 1. ✅ 런타임에 변경 가능
// 2. ✅ 에디터에서 시각적으로 편집 가능
// 3. ✅ 블루프린트에서 접근 가능
// 4. ✅ 재컴파일 없이 값 수정 가능</code></pre>

                <h2>비교표</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>항목</th>
                                <th>헤더 기본값</th>
                                <th>CDO</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td>설정 시점</td><td>컴파일 타임</td><td>런타임</td></tr>
                            <tr><td>변경 방법</td><td>소스 수정 + 재컴파일</td><td>에디터에서 즉시 수정</td></tr>
                            <tr><td>에디터 노출</td><td>❌ 불가능</td><td>✅ 가능</td></tr>
                            <tr><td>BP 접근</td><td>❌ 불가능</td><td>✅ 가능</td></tr>
                            <tr><td>리플렉션</td><td>❌ 없음</td><td>✅ 있음</td></tr>
                        </tbody>
                    </table>
                </div>

                <h2>리플렉션 시스템</h2>
                <div class="callout">
                    <div class="callout-title">Reflection이란?</div>
                    <p>런타임에 자신의 구조를 동적으로 검사하고 수정할 수 있는 메타 프로그래밍 기법</p>
                </div>

                <div class="hierarchy-box">C++ 네이티브 언어
├─ ❌ 리플렉션 기능 없음
├─ ❌ 런타임에 타입 정보 접근 불가
└─ ❌ 프로퍼티 동적 검사 불가

            ↓ 언리얼의 해결책

언리얼 엔진 확장 C++
├─ ✅ UPROPERTY / UFUNCTION 매크로
├─ ✅ UHT (Unreal Header Tool)
├─ ✅ 메타데이터 자동 생성
└─ ✅ 런타임 리플렉션 지원</div>

                <div class="callout warning">
                    <div class="callout-title">중요: UPROPERTY 매크로 필수!</div>
                    <p><strong>UPROPERTY()</strong>가 없으면 CDO에서 관리되지 않습니다. 리플렉션 시스템에 등록하기 위해 반드시 필요합니다.</p>
                </div>

                <h2>CDO에 접근하는 방법</h2>
                <h3>방법 1: StaticClass()를 통한 접근</h3>
                <pre><code class="language-cpp">// 클래스로부터 직접 접근
AFrameWorkCharacter* CDO = AFrameWorkCharacter::StaticClass()
    ->GetDefaultObject&lt;AFrameWorkCharacter&gt;();

// 흐름:
// 1. StaticClass() → UClass 포인터 반환
// 2. GetDefaultObject&lt;T&gt;() → CDO 반환</code></pre>

                <h3>방법 2: GetClass()를 통한 접근</h3>
                <pre><code class="language-cpp">// 인스턴스로부터 접근
void AFrameWorkCharacter::SomeFunction()
{
    // this의 UClass를 가져와서 CDO 접근
    AFrameWorkCharacter* CDO = GetClass()
        ->GetDefaultObject&lt;AFrameWorkCharacter&gt;();
}</code></pre>

                <h2>올바른 사용 패턴</h2>
                <pre><code class="language-cpp">// ✅ CDO 읽기 (권장)
void AGameMode::SetupPlayerStats()
{
    AWarriorCharacter* CDO = AWarriorCharacter::StaticClass()
        ->GetDefaultObject&lt;AWarriorCharacter&gt;();

    // 기본값 확인
    int32 DefaultHP = CDO->HP;
    UE_LOG(LogTemp, Log, TEXT("Warrior 기본 HP: %d"), DefaultHP);
}

// ❌ CDO 수정 (절대 금지!)
void ADangerousCode::ModifyCDO()
{
    AWarriorCharacter* CDO = ...->GetDefaultObject&lt;AWarriorCharacter&gt;();

    // ❌ 절대 하지 말 것!
    CDO->HP = 999;
    // 결과: 이후 생성되는 모든 Warrior의 HP가 999가 됨!
}</code></pre>

                <div class="callout important">
                    <div class="callout-title">CDO 핵심 요약</div>
                    <ol>
                        <li>✅ CDO는 모든 인스턴스의 기본값 제공자 (클래스당 1개)</li>
                        <li>✅ UPROPERTY 매크로 필수 (리플렉션 시스템 등록)</li>
                        <li>✅ 런타임 변경 가능 (에디터 통합의 핵심)</li>
                        <li>⚠️ CDO 직접 수정 금지 (모든 인스턴스에 영향)</li>
                    </ol>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['obj-sec2'] = {
            title: '오브젝트 생성 (NewObject)',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Object Constructor</div>
                    <h1>오브젝트 생성 (NewObject)</h1>
                </div>
                <h2>Overview</h2>
                <p>단순히 메모리 할당만 하는 C++ new와 달리, <strong>NewObject</strong>는 언리얼의 가비지 컬렉션, 리플렉션 시스템과 통합되어 있습니다.</p>

                <h2>NewObject vs C++ new</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>항목</th>
                                <th>C++ new</th>
                                <th>NewObject</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td>사용 대상</td><td>모든 C++ 클래스</td><td>UObject 상속 클래스만</td></tr>
                            <tr><td>메모리 관리</td><td>수동 (delete 필요)</td><td>자동 (GC)</td></tr>
                            <tr><td>리플렉션</td><td>❌ 없음</td><td>✅ 있음</td></tr>
                            <tr><td>Outer 설정</td><td>❌ 불가능</td><td>✅ 가능</td></tr>
                            <tr><td>생성자 제약</td><td>없음</td><td>✅ 있음 (생성자 내 금지)</td></tr>
                            <tr><td>네트워크 복제</td><td>❌ 없음</td><td>✅ 지원</td></tr>
                        </tbody>
                    </table>
                </div>

                <h2>코드 비교</h2>
                <pre><code class="language-cpp">// ❌ C++ new (언리얼에서 사용 금지!)
UMyObject* Obj = new UMyObject();  // 컴파일은 되지만 사용하면 안 됨!
// 문제점:
// 1. 가비지 컬렉션 대상 아님
// 2. 리플렉션 시스템에 등록 안 됨
// 3. Outer 관계 설정 불가
// 4. 네트워크 복제 불가

// ✅ NewObject (언리얼 권장 방식)
UMyObject* Obj = NewObject&lt;UMyObject&gt;(this);
// 장점:
// 1. ✅ 자동 가비지 컬렉션
// 2. ✅ 리플렉션 시스템 통합
// 3. ✅ Outer 관계 설정
// 4. ✅ 네트워크 복제 가능</code></pre>

                <h2>NewObject 사용법</h2>
                <pre><code class="language-cpp">// 1️⃣ 가장 간단한 사용
UMyObject* Obj = NewObject&lt;UMyObject&gt;();
// Outer = GetTransientPackage() (임시 패키지)

// 2️⃣ Outer 지정 (권장)
UMyObject* Obj = NewObject&lt;UMyObject&gt;(this);
// Outer = this (현재 객체)

// 3️⃣ 전체 파라미터 지정
UMyObject* Obj = NewObject&lt;UMyObject&gt;(
    Outer,           // 부모 오브젝트
    Class,           // 생성할 클래스
    Name,            // 오브젝트 이름
    Flags,           // 오브젝트 플래그
    Template         // 템플릿 (기본값: CDO)
);</code></pre>

                <h2>Outer가 무엇인가?</h2>
                <div class="callout">
                    <div class="callout-title">Outer의 정의</div>
                    <p><strong>Outer</strong>: 해당 오브젝트를 소유하는 부모 오브젝트</p>
                </div>

                <div class="hierarchy-box">월드 계층 구조:
UWorld
├─ ULevel
│  ├─ AActor (Outer = ULevel)
│  │  ├─ UActorComponent (Outer = AActor)
│  │  └─ UActorComponent (Outer = AActor)
│  └─ AActor
└─ USubsystem (Outer = UWorld)</div>

                <h2>컴포넌트 생성 특수 케이스</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>항목</th>
                                <th>일반 액터</th>
                                <th>컴포넌트</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td>Outer 필수 여부</td><td>❌ 선택</td><td>✅ 필수</td></tr>
                            <tr><td>RegisterComponent</td><td>❌ 불필요</td><td>✅ 필수</td></tr>
                            <tr><td>Owner 설정</td><td>SpawnActor 시 자동</td><td>Outer 설정 시 자동</td></tr>
                        </tbody>
                    </table>
                </div>

                <h3>컴포넌트 생성 주의사항</h3>
                <pre><code class="language-cpp">// ❌ 잘못된 컴포넌트 생성
void AFrameWorkCharacter::BeginPlay()
{
    Super::BeginPlay();

    // Outer 없이 생성
    UStaticMeshComponent* Mesh = NewObject&lt;UStaticMeshComponent&gt;();
    // ❌ OwnedComponents에 추가 안 됨
    // ❌ RegisterComponent 호출해도 작동 안 함
}

// ✅ 올바른 컴포넌트 생성
void AFrameWorkCharacter::BeginPlay()
{
    Super::BeginPlay();

    // 1단계: Outer 설정하여 생성
    UStaticMeshComponent* Mesh = NewObject&lt;UStaticMeshComponent&gt;(this);
    // ✅ PostInitProperties에서 OwnedComponents에 자동 추가됨

    // 2단계: 컴포넌트 등록 (필수!)
    Mesh->RegisterComponent();
    // ✅ 렌더링 시스템에 등록
    // ✅ 물리 시뮬레이션 활성화
    // ✅ 틱 활성화
}</code></pre>

                <h2>전체 호출 흐름</h2>
                <div class="flow-vertical">
                    <div class="flow-node">NewObject&lt;T&gt;</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">AssertIfInConstructor()</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">FStaticConstructObjectParameters 생성</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">StaticConstructObject_Internal</div>
                </div>

                <div class="hierarchy-box">StaticConstructObject_Internal 내부:
┌───────────────────────────────────────────────┐
│ StaticAllocateObject                          │  메모리 할당
├───────────────────────────────────────────────┤
│ ClassConstructor(FObjectInitializer)          │  생성자 호출
│   ├─ FObjectInitializer 생성자                │
│   ├─ 실제 클래스 생성자 호출                  │
│   └─ FObjectInitializer 소멸자                │
│       └─ PostConstructInit()                  │
│           └─ PostInitProperties()             │  최종 초기화
└───────────────────────────────────────────────┘</div>

                <div class="callout warning">
                    <div class="callout-title">생성자에서 NewObject 금지 이유</div>
                    <p>생성자는 CDO 생성 시에도 호출됨. NewObject는 런타임 전용. CDO에는 CreateDefaultSubobject 사용.</p>
                </div>

                <pre><code class="language-cpp">UCLASS()
class AMyActor : public AActor
{
    GENERATED_BODY()

public:
    AMyActor()
    {
        // ❌ 컴파일 에러!
        UMyComponent* Comp = NewObject&lt;UMyComponent&gt;(this);

        // ✅ 생성자에서는 이것 사용
        UMyComponent* Comp = CreateDefaultSubobject&lt;UMyComponent&gt;(TEXT("MyComp"));
    }
};</code></pre>

                <div class="callout important">
                    <div class="callout-title">NewObject 핵심 요약</div>
                    <ol>
                        <li>✅ NewObject는 UObject 전용 (C++ new 사용 금지)</li>
                        <li>✅ 생성자에서 NewObject 사용 금지 (CreateDefaultSubobject 사용)</li>
                        <li>✅ 컴포넌트는 특별 취급 (Outer 필수, RegisterComponent 필수)</li>
                        <li>✅ 초기화는 2단계 (생성자 + PostInitProperties)</li>
                    </ol>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['obj-sec3'] = {
            title: '서브오브젝트 생성',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Object Constructor</div>
                    <h1>서브오브젝트 생성 (CreateDefaultSubobject)</h1>
                </div>
                <h2>Overview</h2>
                <p>두 함수 모두 UObject를 생성하지만, <strong>언제</strong>, <strong>어디서</strong>, <strong>왜</strong> 사용하는지가 완전히 다릅니다.</p>

                <h2>NewObject vs CreateDefaultSubobject</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>항목</th>
                                <th>NewObject</th>
                                <th>CreateDefaultSubobject</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td>사용 위치</td><td>런타임 (생성자 외)</td><td>생성자 전용</td></tr>
                            <tr><td>목적</td><td>인스턴스 생성</td><td>CDO 서브오브젝트 생성</td></tr>
                            <tr><td>Override 지원</td><td>❌ 없음</td><td>✅ 있음</td></tr>
                            <tr><td>BP 통합</td><td>❌ 에디터에 안 보임</td><td>✅ 에디터에 표시됨</td></tr>
                            <tr><td>RegisterComponent</td><td>✅ 필수</td><td>❌ 자동 처리</td></tr>
                            <tr><td>생성 시점 체크</td><td>생성자 금지</td><td>생성자 필수</td></tr>
                        </tbody>
                    </table>
                </div>

                <h2>코드 비교</h2>
                <pre><code class="language-cpp">// ❌ NewObject - 생성자에서 사용 불가
UCLASS()
class AMyCharacter : public ACharacter
{
    GENERATED_BODY()

public:
    AMyCharacter()
    {
        // ❌ 컴파일 에러!
        UStaticMeshComponent* Mesh = NewObject&lt;UStaticMeshComponent&gt;(this);
    }

    void BeginPlay() override
    {
        Super::BeginPlay();
        // ✅ 런타임에는 가능
        UStaticMeshComponent* Mesh = NewObject&lt;UStaticMeshComponent&gt;(this);
        Mesh->RegisterComponent();  // 수동 등록 필요
    }
};

// ✅ CreateDefaultSubobject - 생성자 전용
UCLASS()
class AMyCharacter : public ACharacter
{
    GENERATED_BODY()

public:
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
    UStaticMeshComponent* MeshComponent;

    AMyCharacter(const FObjectInitializer& ObjectInitializer)
        : Super(ObjectInitializer)
    {
        // ✅ 생성자에서만 가능
        MeshComponent = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT("MeshComp"));
        // RegisterComponent 자동 처리
        // BP 에디터에서 보임
        // Override 가능
    }
};</code></pre>

                <h2>Component Override 시스템</h2>
                <div class="callout">
                    <div class="callout-title">Override의 필요성</div>
                    <p>NewObject를 사용하면 부모와 자식 모두에서 컴포넌트가 생성되어 메모리 낭비가 발생합니다.</p>
                </div>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>방식</th>
                                <th>생성 횟수</th>
                                <th>메모리</th>
                                <th>Override</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td>NewObject</td><td>2회 (부모 + 자식)</td><td>❌ 낭비</td><td>❌ 불가능</td></tr>
                            <tr><td>CreateDefaultSubobject</td><td>1회 (Override된 것만)</td><td>✅ 효율적</td><td>✅ 가능</td></tr>
                        </tbody>
                    </table>
                </div>

                <h3>Override 흐름</h3>
                <div class="flow-vertical">
                    <div class="flow-node">자식 생성자 진입</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">SetDefaultSubobjectClass 호출</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">부모 생성자 호출</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Override 테이블 확인</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node" style="background: var(--success); color: #fff;">Override된 클래스 생성</div>
                </div>

                <h3>실전 예시</h3>
                <pre><code class="language-cpp">// 엔진 기본 Character 클래스
UCLASS()
class ENGINE_API ACharacter : public APawn
{
    GENERATED_BODY()

public:
    static FName CharacterMovementComponentName;

    UPROPERTY()
    UCharacterMovementComponent* CharacterMovement;

    ACharacter(const FObjectInitializer& ObjectInitializer)
        : Super(ObjectInitializer)
    {
        CharacterMovement = CreateDefaultSubobject&lt;UCharacterMovementComponent&gt;(
            CharacterMovementComponentName
        );
    }
};

// 커스텀 MovementComponent 정의
UCLASS()
class UMyCustomMovement : public UCharacterMovementComponent
{
    GENERATED_BODY()

public:
    virtual float GetMaxSpeed() const override
    {
        return 1000.f;  // 커스텀 로직
    }
};

// 프로젝트의 Character 클래스
UCLASS()
class MYPROJECT_API AMyCharacter : public ACharacter
{
    GENERATED_BODY()

public:
    AMyCharacter(const FObjectInitializer& ObjectInitializer)
        // ✅ 핵심: SetDefaultSubobjectClass로 Override 지정
        : Super(ObjectInitializer.SetDefaultSubobjectClass&lt;UMyCustomMovement&gt;(
            CharacterMovementComponentName
        ))
    {
        // 부모 생성자 실행 시:
        // ✅ UCharacterMovementComponent 대신
        // ✅ UMyCustomMovement 생성됨
        // ✅ 메모리 낭비 없음 (1개만 생성)
        check(CharacterMovement->IsA&lt;UMyCustomMovement&gt;());
    }
};</code></pre>

                <h2>CDO에 Component를 추가하는 이유</h2>
                <div class="callout">
                    <div class="callout-title">의문점</div>
                    <p>CDO는 런타임에 게임 로직을 실행하지 않는데, 왜 굳이 Component를 추가할까?</p>
                </div>

                <h3>답변: 블루프린트 에디터 통합</h3>
                <pre><code class="language-cpp">// ❌ BeginPlay에서 생성하는 경우
UPROPERTY()
UStaticMeshComponent* WeaponMesh;

void BeginPlay() override
{
    WeaponMesh = NewObject&lt;UStaticMeshComponent&gt;(this);
    WeaponMesh->RegisterComponent();
}
// 문제점:
// ❌ BP 에디터에서 WeaponMesh가 보이지 않음
// ❌ 에디터에서 메시 선택 불가
// ❌ 위치, 회전, 스케일 조정 불가

// ✅ 생성자에서 생성하는 경우
UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
UStaticMeshComponent* WeaponMesh;

AMyCharacter(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer)
{
    WeaponMesh = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT("WeaponMesh"));
}
// 장점:
// ✅ BP 에디터에서 WeaponMesh 컴포넌트 보임
// ✅ 메시, 머티리얼 드래그앤드롭으로 설정
// ✅ 프로그래머가 아닌 기획자/아티스트도 편집 가능</code></pre>

                <div class="callout important">
                    <div class="callout-title">CreateDefaultSubobject 핵심 요약</div>
                    <ol>
                        <li>✅ CreateDefaultSubobject는 생성자 전용</li>
                        <li>✅ Component Override는 효율적 (중복 생성 없음)</li>
                        <li>✅ BP 통합을 위해 CDO에 Component 필요 (에디터 통합)</li>
                        <li>✅ 내부적으로 NewObject와 동일 (마지막 단계는 StaticConstructObject_Internal)</li>
                    </ol>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['obj-sec4'] = {
            title: 'AddComponentByClass',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Object Constructor</div>
                    <h1>AddComponentByClass (블루프린트 전용)</h1>
                </div>
                <h2>Overview</h2>
                <p>C++에서도 호출 가능하지만, 이는 블루프린트 사용자를 위해 NewObject를 래핑한 헬퍼 함수입니다.</p>

                <h2>AddComponentByClass란?</h2>
                <pre><code class="language-cpp">/**
 * 런타임에 컴포넌트를 동적으로 추가하는 블루프린트 노출 함수
 * C++에서는 NewObject + RegisterComponent를 직접 사용하는 것이 권장됨
 */
UFUNCTION(BlueprintCallable, Category="Components")
UActorComponent* AddComponentByClass(
    TSubclassOf&lt;UActorComponent&gt; Class,
    bool bManualAttachment,
    const FTransform& RelativeTransform,
    bool bDeferredFinish
);</code></pre>

                <div class="callout">
                    <div class="callout-title">기본 개념</div>
                    <p><strong>AddComponentByClass = NewObject + Outer 설정 + RegisterComponent</strong></p>
                    <p>블루프린트 사용자가 복잡한 과정을 몰라도 하나의 노드로 컴포넌트를 생성할 수 있도록 래핑한 함수</p>
                </div>

                <h2>왜 블루프린트 전용인가?</h2>
                <h3>블루프린트의 제약</h3>
                <pre><code class="language-cpp">// 블루프린트에서 제공되지 않는 Low-Level 함수들

// ❌ NewObject - 블루프린트에 노출 안 됨
UObject* Obj = NewObject&lt;UMyComponent&gt;(this);

// ❌ RegisterComponent - 별도 호출 필요
Obj->RegisterComponent();

// ❌ Outer 설정 - 개념 자체가 복잡
// ❌ Object Flags - 너무 Low-Level</code></pre>

                <h3>비교 다이어그램</h3>
                <div class="hierarchy-box">C++ 개발자의 방식:
    NewObject&lt;UMyComponent&gt;(this)
        ↓
    SetupAttachment / RegisterComponent
        ↓
    완료


블루프린트 사용자의 방식:
    AddComponentByClass 노드 하나
        ↓
    완료 (내부에서 자동 처리)</div>

                <h2>C++와 블루프린트의 차이점</h2>
                <h3>C++에서의 컴포넌트 추가</h3>
                <pre><code class="language-cpp">// ✅ C++ 권장 방식
void AMyActor::AddDynamicComponent()
{
    // 1단계: NewObject로 생성
    UStaticMeshComponent* NewMesh = NewObject&lt;UStaticMeshComponent&gt;(
        this,                                  // Outer (필수!)
        UStaticMeshComponent::StaticClass(),   // 클래스
        TEXT("DynamicMesh")                    // 이름
    );

    if (NewMesh)
    {
        // 2단계: 설정
        NewMesh->SetupAttachment(RootComponent);
        NewMesh->SetRelativeLocation(FVector(100, 0, 0));

        // 3단계: 등록
        NewMesh->RegisterComponent();

        // ✅ 완전한 제어
        // ✅ 최적화 가능
        // ✅ 각 단계 커스터마이징 가능
    }
}

// ⚠️ C++에서 AddComponentByClass 사용 (비권장)
void AMyActor::AddDynamicComponentWrong()
{
    UActorComponent* NewComp = AddComponentByClass(
        UStaticMeshComponent::StaticClass(),
        false,
        FTransform::Identity,
        false
    );
    // ⚠️ 작동은 하지만 불필요한 함수 호출 오버헤드
}</code></pre>

                <h2>내부 구현 분석</h2>
                <pre><code class="language-cpp">UActorComponent* AActor::AddComponentByClass(
    TSubclassOf&lt;UActorComponent&gt; Class,
    bool bManualAttachment,
    const FTransform& RelativeTransform,
    bool bDeferredFinish)
{
    // 1. 유효성 검사
    if (!Class) return nullptr;

    // 2. NewObject로 생성 (C++와 동일!)
    UActorComponent* NewComponent = NewObject&lt;UActorComponent&gt;(this, Class);

    // 3. SceneComponent라면 Attachment 처리
    if (USceneComponent* NewSceneComp = Cast&lt;USceneComponent&gt;(NewComponent))
    {
        if (!bManualAttachment)
        {
            NewSceneComp->SetupAttachment(RootComponent);
        }
        NewSceneComp->SetRelativeTransform(RelativeTransform);
    }

    // 4. 컴포넌트 등록
    NewComponent->RegisterComponent();

    // 5. BeginPlay 이미 호출되었다면
    if (!bDeferredFinish && HasActorBegunPlay())
    {
        NewComponent->BeginPlay();
    }

    // 6. 블루프린트 이벤트 발생
    OnComponentAdded.Broadcast(NewComponent);

    return NewComponent;
}</code></pre>

                <div class="callout">
                    <div class="callout-title">핵심 발견</div>
                    <p><strong>AddComponentByClass는 NewObject의 래퍼일 뿐입니다!</strong></p>
                </div>

                <div class="hierarchy-box">AddComponentByClass 내부:
    ├─ NewObject (C++와 동일)
    ├─ SetupAttachment (자동화)
    ├─ RegisterComponent (자동화)
    ├─ BeginPlay (필요시)
    └─ 델리게이트 (BP 통합)

NewObject 방식:
    ├─ NewObject (직접 호출)
    ├─ SetupAttachment (수동)
    └─ RegisterComponent (수동)

결론: 기능은 같지만 자동화 수준이 다름</div>

                <h2>언제 무엇을 사용할까?</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>상황</th>
                                <th>권장 방법</th>
                                <th>이유</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td>C++ 프로그래밍</td><td>NewObject + RegisterComponent</td><td>명확하고 효율적</td></tr>
                            <tr><td>BP 스크립팅</td><td>AddComponentByClass</td><td>간단하고 직관적</td></tr>
                            <tr><td>BP에서 C++ 호출</td><td>C++ 헬퍼 함수 제공</td><td>더 나은 인터페이스</td></tr>
                            <tr><td>성능이 중요</td><td>C++ 직접 구현</td><td>오버헤드 제거</td></tr>
                        </tbody>
                    </table>
                </div>

                <div class="callout important">
                    <div class="callout-title">AddComponentByClass 핵심 요약</div>
                    <ol>
                        <li>✅ AddComponentByClass = 블루프린트 헬퍼 함수</li>
                        <li>✅ 내부는 NewObject와 동일 (래퍼 함수)</li>
                        <li>✅ C++에서는 직접 제어가 더 좋음 (명확성, 최적화)</li>
                        <li>✅ 블루프린트는 추상화가 더 좋음 (간단, 빠른 프로토타이핑)</li>
                    </ol>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['obj-sec5'] = {
            title: 'UObject 생성 종합 정리',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Object Constructor</div>
                    <h1>UObject 생성 종합 정리</h1>
                </div>
                <h2>Overview</h2>
                <p>언리얼 엔진의 UObject 생성 시스템을 완벽하게 이해하고, 상황에 맞는 올바른 생성 방법을 선택합니다.</p>

                <h2>왜 UObject 시스템이 중요한가?</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>이유</th>
                                <th>설명</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td>가비지 컬렉션</td><td>C++ new와 달리 자동 메모리 관리</td></tr>
                            <tr><td>리플렉션 시스템</td><td>런타임 타입 정보, 에디터 통합</td></tr>
                            <tr><td>네트워크 복제</td><td>멀티플레이 동기화</td></tr>
                            <tr><td>블루프린트 통합</td><td>디자이너/아티스트 협업</td></tr>
                        </tbody>
                    </table>
                </div>

                <h2>전체 생성 타임라인</h2>
                <div class="hierarchy-box">┌────────────────────────────────────────────────────────────┐
│              전체 생성 타임라인                             │
├────────────────────────────────────────────────────────────┤
│                                                            │
│  [컴파일 타임]                                             │
│  └─ CDO 생성 (클래스당 1회)                                │
│                                                            │
│  [생성자 실행]                                             │
│  └─ CreateDefaultSubobject                                 │
│     ├─ Override 체크                                       │
│     ├─ RF_DefaultSubObject 플래그 설정                     │
│     └─ Blueprint 에디터 통합                               │
│                                                            │
│  [런타임]                                                  │
│  └─ NewObject                                              │
│     ├─ 생성자 체크 (생성자 내 사용 금지)                   │
│     ├─ Outer 설정                                          │
│     └─ RegisterComponent (컴포넌트인 경우)                 │
│                                                            │
│  [블루프린트]                                              │
│  └─ AddComponentByClass                                    │
│     ├─ NewObject 래퍼                                      │
│     ├─ 자동 SetupAttachment                                │
│     └─ 자동 RegisterComponent                              │
│                                                            │
└────────────────────────────────────────────────────────────┘</div>

                <h2>생성 방법 선택 의사결정 트리</h2>
                <div class="flow-vertical">
                    <div class="flow-node">UObject를 생성해야 한다</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">생성 위치는?</div>
                </div>

                <div class="hierarchy-box">생성 위치?
├─ 생성자 내부?
│   └─ CreateDefaultSubobject (TEXT("Name"))
│       ├─ Override 지원
│       └─ BP 에디터 통합
│
└─ 생성자 외부? (런타임)
    ├─ 컴포넌트?
    │   ├─ C++ → NewObject + RegisterComponent
    │   └─ BP → AddComponentByClass 노드
    │
    └─ 일반 오브젝트?
        └─ NewObject&lt;T&gt;(Outer)</div>

                <h2>상황별 최적 선택</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>상황</th>
                                <th>권장 방법</th>
                                <th>이유</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td>생성자에서 컴포넌트</td><td>CreateDefaultSubobject</td><td>BP 통합, Override 지원</td></tr>
                            <tr><td>생성자에서 일반 오브젝트</td><td>❌ 불가능</td><td>NewObject 생성자 금지</td></tr>
                            <tr><td>런타임에 컴포넌트 (C++)</td><td>NewObject + RegisterComponent</td><td>명확한 제어</td></tr>
                            <tr><td>런타임에 컴포넌트 (BP)</td><td>AddComponentByClass</td><td>간단한 노드</td></tr>
                            <tr><td>런타임에 일반 오브젝트</td><td>NewObject</td><td>유일한 선택</td></tr>
                            <tr><td>부모 컴포넌트 교체</td><td>SetDefaultSubobjectClass</td><td>메모리 효율</td></tr>
                        </tbody>
                    </table>
                </div>

                <h2>생성 방법 비교표</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>항목</th>
                                <th>CDO</th>
                                <th>NewObject</th>
                                <th>CreateDefaultSubobject</th>
                                <th>AddComponentByClass</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td>생성 시점</td><td>컴파일 타임</td><td>런타임</td><td>생성자</td><td>런타임 (BP)</td></tr>
                            <tr><td>목적</td><td>기본값 제공</td><td>인스턴스 생성</td><td>CDO 서브오브젝트</td><td>BP 컴포넌트 추가</td></tr>
                            <tr><td>사용 위치</td><td>자동 생성</td><td>생성자 외</td><td>생성자 전용</td><td>BeginPlay 등</td></tr>
                            <tr><td>Override</td><td>❌</td><td>❌</td><td>✅</td><td>❌</td></tr>
                            <tr><td>BP 통합</td><td>✅ (읽기)</td><td>❌</td><td>✅</td><td>✅</td></tr>
                            <tr><td>Register 필요</td><td>❌</td><td>✅ (컴포넌트)</td><td>❌ (자동)</td><td>❌ (자동)</td></tr>
                        </tbody>
                    </table>
                </div>

                <h2>핵심 차이점 한눈에 보기</h2>
                <div class="hierarchy-box">┌────────────────────────────────────────────────────┐
│               헤더 기본값 vs CDO                   │
├────────────────────────────────────────────────────┤
│ 헤더 기본값:  int32 HP = 100;                      │
│   ├─ 컴파일 타임에 고정                            │
│   ├─ 에디터 노출 불가                              │
│   └─ BP 접근 불가                                  │
│                                                    │
│ CDO: UPROPERTY() int32 HP = 100;                   │
│   ├─ 런타임 변경 가능                              │
│   ├─ 에디터에서 시각적 편집                        │
│   └─ BP 완전 통합                                  │
└────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────┐
│         NewObject vs CreateDefaultSubobject        │
├────────────────────────────────────────────────────┤
│ NewObject:                                         │
│   ├─ 런타임 전용                                   │
│   ├─ 생성자 사용 금지                              │
│   ├─ Override 불가                                 │
│   └─ 수동 RegisterComponent                        │
│                                                    │
│ CreateDefaultSubobject:                            │
│   ├─ 생성자 전용                                   │
│   ├─ Override 지원                                 │
│   ├─ BP 에디터 통합                                │
│   └─ 자동 RegisterComponent                        │
└────────────────────────────────────────────────────┘</div>

                <h2>반드시 기억해야 할 10가지</h2>
                <ol>
                    <li>✅ <strong>CDO는 클래스당 1개</strong> - 모든 인스턴스의 기본값 제공자</li>
                    <li>✅ <strong>UPROPERTY 필수</strong> - 리플렉션 시스템 등록을 위해</li>
                    <li>✅ <strong>NewObject ≠ C++ new</strong> - 가비지 컬렉션, 리플렉션 통합</li>
                    <li>✅ <strong>생성자에서 NewObject 금지</strong> - CreateDefaultSubobject 사용</li>
                    <li>✅ <strong>컴포넌트는 Outer 필수</strong> - 소유 관계 설정</li>
                    <li>✅ <strong>RegisterComponent 필수</strong> - 컴포넌트 활성화 (NewObject 사용 시)</li>
                    <li>✅ <strong>Component Override 효율적</strong> - 중복 생성 없이 교체</li>
                    <li>✅ <strong>BP 통합 = CDO에 Component</strong> - 에디터 시각적 편집</li>
                    <li>✅ <strong>AddComponentByClass = 래퍼</strong> - NewObject + 자동화</li>
                    <li>✅ <strong>C++는 명시적, BP는 추상화</strong> - 각자의 강점 활용</li>
                </ol>

                <h2>디버깅 체크리스트</h2>
                <h3>오브젝트 생성 문제 발생 시</h3>
                <ul>
                    <li>□ UObject를 상속받았는가?</li>
                    <li>□ UCLASS() 매크로를 선언했는가?</li>
                    <li>□ UPROPERTY()를 사용했는가?</li>
                    <li>□ NewObject를 생성자에서 호출하지 않았는가?</li>
                    <li>□ CreateDefaultSubobject를 생성자 외부에서 호출하지 않았는가?</li>
                    <li>□ Outer를 올바르게 설정했는가?</li>
                    <li>□ RegisterComponent를 호출했는가?</li>
                </ul>

                <h3>컴포넌트가 보이지 않을 때</h3>
                <ul>
                    <li>□ 생성자에서 CreateDefaultSubobject를 사용했는가?</li>
                    <li>□ UPROPERTY(VisibleAnywhere)를 선언했는가?</li>
                    <li>□ BeginPlay에서 생성하지 않았는가?</li>
                    <li>□ 블루프린트를 다시 컴파일했는가?</li>
                </ul>

                <div class="callout important">
                    <div class="callout-title">핵심 원칙</div>
                    <p><strong>올바른 시점에 올바른 함수를 사용하라!</strong></p>
                    <ul>
                        <li>생성자 → CreateDefaultSubobject</li>
                        <li>런타임 C++ → NewObject + RegisterComponent</li>
                        <li>런타임 BP → AddComponentByClass</li>
                        <li>Component 교체 → SetDefaultSubobjectClass</li>
                        <li>기본값 확인 → CDO 접근</li>
                    </ul>
                </div>

                <div class="callout tip">
                    <div class="callout-title">Object Constructor 학습 완료!</div>
                    <p>언리얼의 UObject 시스템은 복잡하지만, 각 생성 방법의 목적과 제약사항을 이해하면 강력한 도구가 됩니다!</p>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        // ========================================
        // Spawn Actor: 액터 생성 및 초기화 (6.85~6.87)
        // ========================================

        sectionData['spawn-sec1'] = {
            title: '액터 생성 사전 처리',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Spawn Actor</div>
                    <h1>액터 생성 사전 처리</h1>
                </div>
                <h2>Overview</h2>
                <p>언리얼 엔진에서 액터를 생성할 때 내부적으로 어떤 과정을 거치는지 이해합니다. <code>SpawnActor</code> 함수가 호출된 후 액터가 실제로 생성되기까지의 모든 단계를 분석합니다.</p>

                <h2>SpawnActor의 두 가지 버전</h2>
                <table>
                    <tr>
                        <th>방식</th>
                        <th>설명</th>
                        <th>사용 시점</th>
                    </tr>
                    <tr>
                        <td><strong>SpawnActor</strong></td>
                        <td>즉시 생성 및 초기화</td>
                        <td>일반적인 액터 생성</td>
                    </tr>
                    <tr>
                        <td><strong>SpawnActorDeferred</strong></td>
                        <td>지연 생성 방식</td>
                        <td>속성 설정 후 생성 완료 필요</td>
                    </tr>
                </table>

                <div class="callout tip">
                    <div class="callout-title">핵심 사실</div>
                    <p>두 로직은 <strong>내부적으로 완전히 동일</strong>합니다. 단지 <code>bDeferConstruction</code> 플래그의 차이만 존재하므로 SpawnActor 함수 하나만 이해하면 됩니다.</p>
                </div>

                <h3>일반 SpawnActor - 즉시 생성</h3>
                <pre><code class="language-cpp">// 즉시 생성 및 초기화
AActor* NewActor = GetWorld()->SpawnActor&lt;AActor&gt;();
// ✅ 생성과 동시에 모든 초기화 완료</code></pre>

                <h3>SpawnActorDeferred - 지연 생성</h3>
                <pre><code class="language-cpp">FTransform Transform;
AActor* NewActor = GetWorld()->SpawnActorDeferred&lt;AActor&gt;(
    AActor::StaticClass(),
    Transform
);

// 💡 FinishSpawning 호출 전에 속성 변경 가능
NewActor->SetActorLocation(FVector(100, 100, 0));
NewActor->MyCustomProperty = SomeValue;

// ✅ 수동으로 생성 완료 호출 필요
NewActor->FinishSpawning(Transform);</code></pre>

                <h2>UWorld::SpawnActor 단계별 분석</h2>
                <div class="flow-vertical">
                    <div class="flow-node">1. 레벨 결정</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">2. Template/CDO 선택</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">3. 액터 이름 생성 (고유성 보장)</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">4. Transform & Collision 설정</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">5. bNoFail 플래그 처리</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">6. 생성 전 콜리전 체크</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">7. NewObject로 액터 생성</div>
                </div>

                <h3>단계 1: 생성할 레벨 결정</h3>
                <pre><code class="language-cpp">ULevel* LevelToSpawnIn = SpawnParameters.OverrideLevel;

if (LevelToSpawnIn == NULL)
{
    // Owner의 레벨에 스폰 -> 없으면 CurrentLevel (일반적으로 PersistentLevel)
    LevelToSpawnIn = (SpawnParameters.Owner != NULL)
        ? SpawnParameters.Owner->GetLevel()
        : ToRawPtr(CurrentLevel);
}</code></pre>

                <div class="hierarchy-box">우선순위:
1순위: SpawnParameters.OverrideLevel  (명시적 지정)
   ↓
2순위: SpawnParameters.Owner->GetLevel()  (Owner의 레벨)
   ↓
3순위: CurrentLevel  (보통 PersistentLevel)</div>

                <h3>단계 2: Template과 CDO 선택</h3>
                <pre><code class="language-cpp">AActor* Template = SpawnParameters.Template
    ? SpawnParameters.Template
    : Class->GetDefaultObject&lt;AActor&gt;();</code></pre>

                <table>
                    <tr>
                        <th>구분</th>
                        <th>Template</th>
                        <th>CDO</th>
                    </tr>
                    <tr>
                        <td><strong>용도</strong></td>
                        <td>특정 인스턴스의 현재 상태 복사</td>
                        <td>클래스의 기본 값 사용</td>
                    </tr>
                    <tr>
                        <td><strong>사용 시점</strong></td>
                        <td>기존 액터와 동일한 상태로 생성</td>
                        <td>일반적인 액터 생성</td>
                    </tr>
                    <tr>
                        <td><strong>복사 범위</strong></td>
                        <td>UPROPERTY 속성만</td>
                        <td>모든 기본값</td>
                    </tr>
                </table>

                <h3>단계 3: 액터 이름 설정 및 고유성 보장</h3>
                <div class="callout">
                    <div class="callout-title">핵심 보장 사항</div>
                    <p><strong>액터의 이름은 항상 고유성이 보장됩니다.</strong> 레벨 내에서 동일한 이름을 가진 액터는 절대 존재할 수 없습니다. 중복 시 자동으로 숫자 접미사가 붙습니다.</p>
                </div>
                <div class="hierarchy-box">MyActor      -> 첫 번째 생성
MyActor_1    -> 두 번째 생성
MyActor_2    -> 세 번째 생성</div>

                <h3>단계 5: bNoFail 플래그 처리</h3>
                <table>
                    <tr>
                        <th>bNoFail</th>
                        <th>기존 설정</th>
                        <th>변경 후</th>
                    </tr>
                    <tr>
                        <td>❌ false</td>
                        <td>DontSpawnIfColliding</td>
                        <td>DontSpawnIfColliding (유지)</td>
                    </tr>
                    <tr>
                        <td>✅ true</td>
                        <td>DontSpawnIfColliding</td>
                        <td><strong>AlwaysSpawn</strong> (강제 생성)</td>
                    </tr>
                </table>
                <p><code>bNoFail</code>의 역할: <strong>콜리전과 관계없이 무조건 액터를 생성하도록 보장</strong></p>

                <h3>단계 7: 실제 액터 객체 생성</h3>
                <pre><code class="language-cpp">// 7-1. NewObject로 액터 생성
EObjectFlags ActorFlags = SpawnParameters.ObjectFlags;

AActor* const Actor = NewObject&lt;AActor&gt;(
    LevelToSpawnIn,          // Outer
    Class,                   // 생성할 클래스
    NewActorName,            // 고유한 이름
    ActorFlags,              // Object 플래그
    Template,                // 템플릿 (CDO 또는 인스턴스)
    false,                   // bCopyTransientsFromClassDefaults
    nullptr,                 // InInstanceGraph
    ExternalPackage          // ExternalPackage
);

// 7-2. Level에 액터 추가
LevelToSpawnIn->TryAddActorToList(Actor, /*bAddUnique*/false);

// 7-3. 델리게이트 호출
OnActorPreSpawnInitialization.Broadcast(Actor);

// 7-4. 초기화 진행
Actor->PostSpawnInitialize(
    UserTransform,
    SpawnParameters.Owner,
    SpawnParameters.Instigator,
    SpawnParameters.IsRemoteOwned(),
    SpawnParameters.bNoFail,
    SpawnParameters.bDeferConstruction,
    SpawnParameters.TransformScaleMethod
);

// 7-5. 스폰 완료 델리게이트
OnActorSpawned.Broadcast(Actor);</code></pre>

                <h2>AActor::PostSpawnInitialize 단계별 분석</h2>
                <div class="flow-vertical">
                    <div class="flow-node">1. 기본 정보 설정 (CreationTime, Owner, Instigator)</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">2. RootComponent 처리 (FixupNativeActorComponents)</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">3. Native C++ 컴포넌트 생성 알림</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">4. 컴포넌트 등록 처리 (BP Root 여부 확인)</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">5. Construction 지연 여부 처리</div>
                </div>

                <h3>단계 2: RootComponent 처리</h3>
                <pre><code class="language-cpp">// RootComponent가 없는 경우 Actor의 모든 Native C++ SceneComponent 중
// 첫 번째를 Root로 설정 (사용자 실수 방지)
USceneComponent* const SceneRootComponent = FixupNativeActorComponents(this);

if (SceneRootComponent != nullptr)
{
    // Transform 스케일 방식에 따라 최종 Transform 결정
    switch(TransformScaleMethod)
    {
        case ESpawnActorScaleMethod::OverrideRootScale:
            FinalRootComponentTransform = UserSpawnTransform;
            break;

        case ESpawnActorScaleMethod::MultiplyWithRoot:
            FinalRootComponentTransform = RootTransform * UserSpawnTransform;
            break;
    }

    // 액터의 월드 트랜스폼을 설정
    SceneRootComponent->SetWorldTransform(FinalRootComponentTransform);
}</code></pre>

                <div class="callout warning">
                    <div class="callout-title">중요 사실</div>
                    <p><strong>C++ Component가 먼저 생성</strong>되고 <strong>Blueprint Component가 나중에 생성</strong>됩니다. 현재 로직은 C++ 기준으로 등록된 컴포넌트만 찾습니다.</p>
                </div>

                <h3>단계 4: 컴포넌트 등록 처리</h3>
                <pre><code class="language-cpp">// Root가 Blueprint에서 설정된 경우?
// SCS 처리 로직 후에 등록이 진행되어야 해서 뒤로 미뤄야 함
bHasDeferredComponentRegistration =
    (SceneRootComponent == nullptr && Cast&lt;UBlueprintGeneratedClass&gt;(GetClass()) != nullptr);

// Blueprint에서 Root가 결정되는 경우
// 다른 컴포넌트들이 Root보다 먼저 등록되지 않도록 등록을 뒤로 미룸
if (!bHasDeferredComponentRegistration && GetWorld())
{
    RegisterAllComponents();
}</code></pre>

                <table>
                    <tr>
                        <th>조건</th>
                        <th>RootComponent 상태</th>
                        <th>등록 시점</th>
                    </tr>
                    <tr>
                        <td>Native C++ Root</td>
                        <td>✅ 존재함</td>
                        <td><strong>즉시 등록</strong></td>
                    </tr>
                    <tr>
                        <td>Blueprint Root</td>
                        <td>❌ 아직 없음</td>
                        <td><strong>ExecuteConstruction 이후 등록</strong></td>
                    </tr>
                </table>

                <h2>학습 포인트</h2>
                <ul>
                    <li>✅ <strong>액터 이름은 항상 고유함</strong> - 중복 시 자동으로 숫자 접미사 추가</li>
                    <li>✅ <strong>C++ Component가 먼저 생성, BP Component는 나중</strong> - ExecuteConstruction에서 생성</li>
                    <li>✅ <strong>bDeferConstruction이 유일한 차이</strong> - SpawnActor vs SpawnActorDeferred</li>
                    <li>✅ <strong>BP Root인 경우 등록 지연</strong> - SCS 처리 후 등록</li>
                </ul>

                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['spawn-sec2'] = {
            title: '액터 생성 마무리',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Spawn Actor</div>
                    <h1>액터 생성 마무리</h1>
                </div>
                <h2>Overview</h2>
                <p>SpawnActor의 사전 처리가 끝난 후, 액터가 실제로 게임에서 사용 가능한 상태가 되기까지 어떤 과정을 거치는지 이해합니다. <code>FinishSpawning</code>과 <code>PostActorConstruction</code>의 내부 동작을 분석합니다.</p>

                <h2>AActor::FinishSpawning 상세 분석</h2>
                <div class="flow-vertical">
                    <div class="flow-node">1. 최종 Transform 결정</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">2. Transform 보정 로직 (Deferred Spawn의 핵심)</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">3. ExecuteConstruction 호출 (BP SCS 컴포넌트 생성)</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">4. PostActorConstruction 호출 (최종 초기화 진입)</div>
                </div>

                <h3>단계 1: 최종 Transform 결정</h3>
                <pre><code class="language-cpp">// RootComponent가 있다면 RootComponent의 위치를 사용,
// 없다면 사용자가 넘겨준 위치를 사용
FTransform FinalRootComponentTransform = (RootComponent
    ? RootComponent->GetComponentTransform()
    : UserTransform);</code></pre>

                <table>
                    <tr>
                        <th>조건</th>
                        <th>사용하는 Transform</th>
                    </tr>
                    <tr>
                        <td>RootComponent <strong>존재</strong></td>
                        <td><code>RootComponent->GetComponentTransform()</code></td>
                    </tr>
                    <tr>
                        <td>RootComponent <strong>없음</strong></td>
                        <td><code>UserTransform</code> (사용자 전달값)</td>
                    </tr>
                </table>

                <h3>단계 2: Transform 보정 로직 (Deferred Spawn의 핵심)</h3>
                <div class="callout tip">
                    <div class="callout-title">보정이 필요한 이유</div>
                    <p><strong>Deferred Spawn 사이에 사용자가 Transform을 변경할 수 있습니다.</strong> 원본 Spawn Transform과 현재 Transform의 차이를 계산하여 최종 위치를 정확하게 결정해야 합니다.</p>
                </div>

                <h4>Transform 보정 계산 과정</h4>
                <div class="hierarchy-box">Step 1: 원본 Transform 가져오기
  - GSpawnActorDeferredTransformCache 검색
  - OriginalSpawnTransform = (8, 0, 0)

Step 2: 차이값 계산
  - 현재 Root Transform = (10, 0, 0)
  - Template = Root * Original⁻¹
  - Template = (10, 0, 0) * (8, 0, 0)⁻¹
  - Template = (2, 0, 0)

Step 3: 최종 Transform 적용
  - User Transform = (5, 0, 0)
  - Final = Template * User
  - Final = (2, 0, 0) * (5, 0, 0)
  - Final = (7, 0, 0) ✅</div>

                <pre><code class="language-cpp">// SpawnActorDeferred 사용 예시
FTransform InitialTransform(FVector(8, 0, 0));
AActor* Actor = GetWorld()->SpawnActorDeferred&lt;AActor&gt;(
    AActor::StaticClass(),
    InitialTransform
);

// 사용자가 위치 변경 (Root의 Relative가 2, 0, 0이라고 가정)
// 현재 Root 월드 위치: (10, 0, 0)
Actor->SetActorLocation(FVector(10, 0, 0));

// FinishSpawning 호출 시 새로운 Transform 전달
FTransform FinalTransform(FVector(5, 0, 0));
Actor->FinishSpawning(FinalTransform);

// 결과 계산:
// - 원본 Spawn Transform: (8, 0, 0)
// - 현재 Root Transform: (10, 0, 0)
// - 차이 (Template): (2, 0, 0)
// - 새로운 User Transform: (5, 0, 0)
// - 최종 위치: (2, 0, 0) * (5, 0, 0) = (7, 0, 0) ✅</code></pre>

                <h3>단계 3: ExecuteConstruction 호출</h3>
                <pre><code class="language-cpp">// Native C++ 지연되었던 컴포넌트 등록 + Blueprint SCS 컴포넌트 생성 및 등록
ExecuteConstruction(
    FinalRootComponentTransform,
    nullptr,
    InstanceDataCache,
    bIsDefaultTransform,
    TransformScaleMethod
);</code></pre>

                <table>
                    <tr>
                        <th>단계</th>
                        <th>설명</th>
                    </tr>
                    <tr>
                        <td><strong>1. 지연된 컴포넌트 등록</strong></td>
                        <td>Blueprint Root 때문에 미뤄졌던 컴포넌트 등록 처리</td>
                    </tr>
                    <tr>
                        <td><strong>2. Blueprint SCS 컴포넌트 생성</strong></td>
                        <td>Simple Construction Script 컴포넌트 생성</td>
                    </tr>
                    <tr>
                        <td><strong>3. 모든 컴포넌트 등록</strong></td>
                        <td>RegisterAllComponents 호출</td>
                    </tr>
                </table>

                <h2>AActor::PostActorConstruction 상세 분석</h2>
                <div class="flow-vertical">
                    <div class="flow-node">1. World 초기화 상태 확인</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">2. 컴포넌트 초기화 (PreInitialize + Initialize)</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">3. Collision Handling 처리 (위치 조정 또는 Destroy)</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">4. 최종 초기화 및 BeginPlay</div>
                </div>

                <h3>단계 1: World 초기화 상태 확인</h3>
                <pre><code class="language-cpp">// World가 Actor들의 Initialize가 가능한 시점인지 판단
// (InitializeActorsForPlay 함수 호출 이후에만 True)
bool const bActorsInitialized = World && World->AreActorsInitialized();</code></pre>

                <div class="callout warning">
                    <div class="callout-title">중요 사항</div>
                    <p><strong>프레임워크 초기화 과정</strong>에서 World가 초기화되기 전에는 SpawnActor에서 <code>bActorsInitialized</code> 플래그가 false이므로 초기화 로직이 실행되지 않습니다.</p>
                </div>

                <h3>단계 3: Collision Handling에 따른 최종 처리</h3>
                <table>
                    <tr>
                        <th>옵션</th>
                        <th>충돌 발견 시 동작</th>
                        <th>Destroy 가능성</th>
                    </tr>
                    <tr>
                        <td><code>AdjustIfPossibleButAlwaysSpawn</code></td>
                        <td>근처 생성 가능 지점 찾아서라도 생성</td>
                        <td>❌ 없음</td>
                    </tr>
                    <tr>
                        <td><code>AdjustIfPossibleButDontSpawnIfColliding</code></td>
                        <td>근처에 충돌 없는 곳을 못 찾으면 Destroy</td>
                        <td>✅ 있음</td>
                    </tr>
                    <tr>
                        <td><code>DontSpawnIfColliding</code></td>
                        <td>근처 찾아보지도 않고 충돌되면 바로 Destroy</td>
                        <td>✅ 있음</td>
                    </tr>
                    <tr>
                        <td><code>Undefined</code>, <code>AlwaysSpawn</code></td>
                        <td>충돌 무시하고 무조건 생성</td>
                        <td>❌ 없음</td>
                    </tr>
                </table>

                <div class="callout important">
                    <div class="callout-title">중요 주의사항</div>
                    <p><strong>Collision Handling 정책에 따라 생성 완료 직전에 액터가 Destroy될 수 있습니다!</strong> 따라서 SpawnActor 이후에는 <strong>항상 null 체크가 필수</strong>입니다.</p>
                </div>

                <h3>단계 4: 최종 초기화 및 BeginPlay 호출</h3>
                <pre><code class="language-cpp">// Destroy 가능성 있어서 Valid 체크 필수
if (IsValidChecked(this))
{
    // ReadyForReplication 호출 시점
    PostInitializeComponents();

    if (IsValidChecked(this))
    {
        // BeginPlay 호출 가능한 시점인지 체크
        bool bRunBeginPlay = !bDeferBeginPlayAndUpdateOverlaps && World->HasBegunPlay();

        if (bRunBeginPlay)
        {
            // 부모 액터가 있으면 부모의 BeginPlay 상태 확인
            // (부모보다 먼저 불리면 안됨)
            if (AActor* ParentActor = GetParentActor())
            {
                bRunBeginPlay = (ParentActor->HasActorBegunPlay()
                    || ParentActor->IsActorBeginningPlay());
            }
        }

        if (bRunBeginPlay)
        {
            DispatchBeginPlay();
        }
    }
}</code></pre>

                <h4>BeginPlay 호출 조건</h4>
                <div class="hierarchy-box">1️⃣ 액터가 유효함
   IsValidChecked(this) == true
   ↓
2️⃣ Destroy되지 않음
   Collision Handling 통과
   ↓
3️⃣ BeginPlay 지연이 설정 안됨
   bDeferBeginPlayAndUpdateOverlaps == false
   ↓
4️⃣ World가 게임을 시작함
   World->HasBegunPlay() == true
   ↓
5️⃣ 부모 액터의 BeginPlay 완료
   (부모가 있는 경우)
   Parent->HasActorBegunPlay()</div>

                <h2>올바른 사용법</h2>
                <pre><code class="language-cpp">// ✅ 올바른 SpawnActor 사용법
AActor* NewActor = GetWorld()->SpawnActor&lt;AActor&gt;(
    AActor::StaticClass(),
    SpawnTransform,
    SpawnParams
);

if (NewActor)  // ✅ 항상 null 체크 필수!
{
    // 액터 사용 로직
    NewActor->DoSomething();
}


// ❌ 잘못된 사용법 (null 체크 없음)
AActor* NewActor = GetWorld()->SpawnActor&lt;AActor&gt;(...);
NewActor->DoSomething();  // ❌ Crash 위험!</code></pre>

                <h2>학습 포인트</h2>
                <ul>
                    <li>✅ <strong>Transform 보정 메커니즘</strong> - Deferred Spawn 시 중간 변경사항 반영</li>
                    <li>✅ <strong>ExecuteConstruction의 역할</strong> - Blueprint SCS 컴포넌트 생성 시점</li>
                    <li>✅ <strong>World 초기화 상태 확인</strong> - bActorsInitialized 플래그의 중요성</li>
                    <li>✅ <strong>Collision Handling으로 Destroy 가능</strong> - 항상 null 체크 필수</li>
                    <li>✅ <strong>BeginPlay 호출 조건</strong> - 5가지 조건 모두 충족 필요</li>
                </ul>

                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['spawn-sec3'] = {
            title: '액터 초기화 순서',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Spawn Actor</div>
                    <h1>액터 초기화 순서 - 개념</h1>
                </div>
                <h2>Overview</h2>
                <p>Actor가 생성되어 제대로 작동하기까지 거치는 초기화 과정을 이해합니다. 이 로직을 알아야 <strong>원하는 시점에 override해서 로직을 제어</strong>할 수 있습니다.</p>

                <div class="callout">
                    <div class="callout-title">왜 초기화 순서를 이해해야 하는가?</div>
                    <table>
                        <tr>
                            <th>이유</th>
                            <th>설명</th>
                        </tr>
                        <tr>
                            <td><strong>올바른 시점 선택</strong></td>
                            <td>각 단계의 목적을 알아야 적절한 함수에 로직 배치 가능</td>
                        </tr>
                        <tr>
                            <td><strong>버그 방지</strong></td>
                            <td>초기화 순서를 모르면 null 참조, 잘못된 상태 접근 등 발생</td>
                        </tr>
                        <tr>
                            <td><strong>Override 지점 파악</strong></td>
                            <td>원하는 시점에 커스텀 로직 추가 가능</td>
                        </tr>
                        <tr>
                            <td><strong>디버깅 효율성</strong></td>
                            <td>초기화 문제 발생 시 빠르게 원인 파악</td>
                        </tr>
                    </table>
                </div>

                <h2>주요 초기화 6단계</h2>
                <div class="flow-vertical">
                    <div class="flow-node">1. OnComponentCreated - 컴포넌트 생성 알림</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">2. PreRegisterAllComponents - World 등록 준비</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">3. RegisterAllComponents - World에 컴포넌트 등록</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">4. InitializeComponent - 각 컴포넌트 초기화</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">5. PostInitializeComponents - 액터 레벨 최종 초기화</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">6. BeginPlay - 게임 로직 시작</div>
                </div>

                <h3>단계 1: OnComponentCreated</h3>
                <p><strong>호출 시점</strong>: 액터가 스폰되면서 컴포넌트 생성 직후</p>
                <pre><code class="language-cpp">// PostSpawnInitialize에서 호출
DispatchOnComponentsCreated(this);</code></pre>
                <table>
                    <tr>
                        <th>특징</th>
                        <th>설명</th>
                    </tr>
                    <tr>
                        <td><strong>호출 대상</strong></td>
                        <td>액터의 모든 컴포넌트</td>
                    </tr>
                    <tr>
                        <td><strong>C++ 컴포넌트</strong></td>
                        <td>✅ 이 시점에 생성됨</td>
                    </tr>
                    <tr>
                        <td><strong>Blueprint 컴포넌트</strong></td>
                        <td>❌ 나중에 ExecuteConstruction에서 생성</td>
                    </tr>
                </table>

                <h3>단계 2: PreRegisterAllComponents</h3>
                <p><strong>호출 시점</strong>: 컴포넌트를 World에 등록하기 직전</p>
                <pre><code class="language-cpp">// AActor.h
virtual void PreRegisterAllComponents() {}</code></pre>
                <p><strong>역할</strong>: World에 등록하기 전 마지막 준비 단계. 등록 전 필요한 마지막 설정 가능.</p>

                <h3>단계 3: RegisterAllComponents</h3>
                <p><strong>호출 시점</strong>: PreRegisterAllComponents 이후</p>
                <pre><code class="language-cpp">// PostSpawnInitialize 또는 ExecuteConstruction에서 호출
if (!bHasDeferredComponentRegistration && GetWorld())
{
    RegisterAllComponents();
}</code></pre>
                <div class="hierarchy-box">각 컴포넌트 순회
    ↓
Component->RegisterComponent()
    ↓
World 렌더링 시스템 등록
    ↓
World 물리 시스템 등록
    ↓
World 콜리전 시스템 등록
    ↓
컴포넌트 기능 활성화 ✅</div>

                <h3>단계 4: InitializeComponent</h3>
                <p><strong>호출 시점</strong>: 컴포넌트가 World에 등록된 후</p>
                <pre><code class="language-cpp">// InitializeComponents에서 각 컴포넌트마다 호출
Component->InitializeComponent();</code></pre>
                <table>
                    <tr>
                        <th>작업</th>
                        <th>설명</th>
                    </tr>
                    <tr>
                        <td><strong>초기값 설정</strong></td>
                        <td>컴포넌트 속성 초기화</td>
                    </tr>
                    <tr>
                        <td><strong>리소스 로딩</strong></td>
                        <td>필요한 리소스 로드</td>
                    </tr>
                    <tr>
                        <td><strong>내부 객체 생성</strong></td>
                        <td>컴포넌트 내부에서 사용할 객체 생성</td>
                    </tr>
                    <tr>
                        <td><strong>시스템 연결</strong></td>
                        <td>다른 시스템과의 연결 설정</td>
                    </tr>
                </table>

                <h3>단계 5: PostInitializeComponents</h3>
                <p><strong>호출 시점</strong>: 모든 컴포넌트의 InitializeComponent가 완료된 후</p>
                <pre><code class="language-cpp">// PostActorConstruction에서 호출
if (IsValidChecked(this))
{
    PostInitializeComponents();
}</code></pre>
                <div class="callout tip">
                    <div class="callout-title">PostInitializeComponents의 역할</div>
                    <ul>
                        <li>✅ 모든 컴포넌트가 준비된 후 액터 전체의 로직을 초기화</li>
                        <li>✅ 컴포넌트 간 상호작용 설정</li>
                        <li>✅ <code>ReadyForReplication()</code> 호출 시점 - 네트워크 복제 준비</li>
                    </ul>
                </div>

                <h3>단계 6: BeginPlay</h3>
                <p><strong>호출 시점</strong>: World가 게임을 시작하고, 부모 액터의 BeginPlay가 완료된 후</p>
                <pre><code class="language-cpp">// PostActorConstruction에서 조건부 호출
if (bRunBeginPlay)
{
    DispatchBeginPlay();
}</code></pre>
                <table>
                    <tr>
                        <th>특징</th>
                        <th>설명</th>
                    </tr>
                    <tr>
                        <td><strong>게임 로직 시작</strong></td>
                        <td>실제 게임플레이 로직이 시작되는 시점</td>
                    </tr>
                    <tr>
                        <td><strong>모든 초기화 완료</strong></td>
                        <td>액터와 컴포넌트 모두 준비 완료</td>
                    </tr>
                    <tr>
                        <td><strong>계층 구조 보장</strong></td>
                        <td>부모 액터의 BeginPlay가 먼저 호출됨</td>
                    </tr>
                    <tr>
                        <td><strong>액터 & 컴포넌트</strong></td>
                        <td>액터와 모든 컴포넌트의 BeginPlay 호출</td>
                    </tr>
                </table>

                <h2>각 단계별 접근 가능 범위</h2>
                <table>
                    <tr>
                        <th>단계</th>
                        <th>자신 컴포넌트</th>
                        <th>World</th>
                        <th>다른 액터</th>
                    </tr>
                    <tr>
                        <td><strong>OnComponentCreated</strong></td>
                        <td>✅</td>
                        <td>❌ (아직 등록 안됨)</td>
                        <td>❌</td>
                    </tr>
                    <tr>
                        <td><strong>PreRegisterAllComponents</strong></td>
                        <td>✅</td>
                        <td>⚠️ (등록 직전)</td>
                        <td>❌</td>
                    </tr>
                    <tr>
                        <td><strong>InitializeComponent</strong></td>
                        <td>✅</td>
                        <td>✅ (등록 완료)</td>
                        <td>⚠️ (초기화 중일 수 있음)</td>
                    </tr>
                    <tr>
                        <td><strong>PostInitializeComponents</strong></td>
                        <td>✅ (준비 완료)</td>
                        <td>✅</td>
                        <td>⚠️ (초기화 중일 수 있음)</td>
                    </tr>
                    <tr>
                        <td><strong>BeginPlay</strong></td>
                        <td>✅</td>
                        <td>✅</td>
                        <td>✅ (모두 준비 완료)</td>
                    </tr>
                </table>

                <h2>Constructor vs PostInitializeComponents</h2>
                <div class="hierarchy-box">Constructor (생성자)
  ⚠️  CDO 생성 시에도 호출됨
  ❌ World 접근 불가
  ❌ 다른 액터 접근 불가
  ❌ GetWorld() == nullptr
  ✅ UPROPERTY 기본값 설정만 가능

PostInitializeComponents
  ✅ 실제 인스턴스 생성 시에만 호출
  ✅ World 접근 가능
  ✅ GetWorld() != nullptr
  ✅ 동적 로직 실행 가능</div>

                <h2>학습 포인트</h2>
                <ul>
                    <li>✅ <strong>초기화 순서 6단계</strong> - OnComponentCreated → PreRegister → Register → Initialize → PostInitialize → BeginPlay</li>
                    <li>✅ <strong>C++ vs Blueprint Root 차이</strong> - 컴포넌트 등록 시점이 다름</li>
                    <li>✅ <strong>각 단계의 접근 범위</strong> - World, 컴포넌트, 다른 액터 접근 가능 시점 이해</li>
                    <li>✅ <strong>Constructor vs PostInitializeComponents</strong> - World 접근 가능 여부 차이</li>
                    <li>✅ <strong>BeginPlay 조건</strong> - World 시작, 부모 BeginPlay 완료 필요</li>
                </ul>

                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['spawn-sec4'] = {
            title: 'C++ vs Blueprint 생성 순서',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Spawn Actor</div>
                    <h1>Native C++ vs Blueprint 컴포넌트 생성 순서</h1>
                </div>
                <h2>핵심 결론</h2>
                <div class="callout tip">
                    <div class="callout-title">Native C++ 컴포넌트가 Blueprint 컴포넌트보다 먼저 생성됩니다</div>
                    <table>
                        <tr>
                            <th>컴포넌트 타입</th>
                            <th>실제 생성 시점</th>
                            <th>생성 위치</th>
                            <th>생성 함수</th>
                        </tr>
                        <tr>
                            <td><strong>Native C++ Component</strong></td>
                            <td>⏰ NewObject (Constructor)</td>
                            <td>Actor Constructor</td>
                            <td><code>CreateDefaultSubobject</code></td>
                        </tr>
                        <tr>
                            <td><strong>Blueprint SCS Component</strong></td>
                            <td>⏰ ExecuteConstruction</td>
                            <td>FinishSpawning 단계</td>
                            <td><code>CreateComponentsForActor</code></td>
                        </tr>
                    </table>
                </div>

                <h2>왜 이것이 중요한가?</h2>
                <div class="hierarchy-box">이 순서를 이해하면:
✅ 컴포넌트 초기화 로직을 올바른 시점에 배치 가능
✅ C++과 Blueprint 컴포넌트 간 의존성 문제 예방
✅ RootComponent 설정 순서 이해
✅ RegisterAllComponents 지연 이유 파악</div>

                <h2>컴포넌트가 실제로 생성되는 시점</h2>
                <div class="callout warning">
                    <div class="callout-title">중요: 생성 시점 명확히 하기</div>
                    <p>"PostSpawnInitialize에서 C++ 컴포넌트를 생성한다"는 표현은 <strong>부정확</strong>합니다. C++ 컴포넌트는 <strong>Constructor</strong>에서 생성됩니다.</p>
                </div>

                <h3>Native C++ 컴포넌트 - Constructor에서 생성</h3>
                <pre><code class="language-cpp">// 액터의 Constructor에서 생성됨!
AMyActor::AMyActor()
{
    // ✅ CreateDefaultSubobject로 C++ 컴포넌트 생성
    MeshComponent = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT("Mesh"));
    MovementComponent = CreateDefaultSubobject&lt;UMovementComponent&gt;(TEXT("Movement"));

    // RootComponent 설정
    RootComponent = MeshComponent;
}

// NewObject 호출 시점에 Constructor 실행!
AActor* Actor = NewObject&lt;AActor&gt;(
    LevelToSpawnIn,
    Class,              // AMyActor::StaticClass()
    NewActorName,
    ActorFlags,
    Template
);

// 이 시점에서:
// 1. AMyActor() Constructor 호출됨
// 2. CreateDefaultSubobject로 생성한 컴포넌트들이 이미 존재함
// 3. Actor->GetComponents()로 조회 가능!</code></pre>

                <div class="flow-vertical">
                    <div class="flow-node">NewObject&lt;AActor&gt;()</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">Constructor 호출 (AMyActor::AMyActor())</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">CreateDefaultSubobject&lt;UComponent&gt;()</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">✅ C++ 컴포넌트 생성 완료!</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">NewObject 반환</div>
                    <span class="flow-arrow">→</span>
                    <div class="flow-node">PostSpawnInitialize (GetComponents() ✅ 이미 존재)</div>
                </div>

                <h3>Blueprint 컴포넌트 - ExecuteConstruction에서 생성</h3>
                <pre><code class="language-cpp">// ExecuteConstruction에서 생성됨!
void AActor::ExecuteConstruction(...)
{
    // Blueprint의 Simple Construction Script 실행
    // → BP에서 추가한 컴포넌트들이 여기서 생성됨

    UBlueprintGeneratedClass* BGClass = Cast&lt;UBlueprintGeneratedClass&gt;(GetClass());
    if (BGClass)
    {
        // SCS (Simple Construction Script) 컴포넌트 생성
        BGClass->CreateComponentsForActor(this);

        // 이제 BP 컴포넌트들이 GetComponents()로 조회 가능!
    }
}</code></pre>

                <h2>흔한 오해 정정</h2>
                <table>
                    <tr>
                        <th>오해</th>
                        <th>실제</th>
                    </tr>
                    <tr>
                        <td>"PostSpawnInitialize에서 C++ 컴포넌트 생성"</td>
                        <td>❌ Constructor에서 이미 생성됨</td>
                    </tr>
                    <tr>
                        <td>"DispatchOnComponentsCreated가 생성함"</td>
                        <td>❌ 생성 알림만 전송함</td>
                    </tr>
                    <tr>
                        <td>"FixupNativeActorComponents가 생성함"</td>
                        <td>❌ 이미 존재하는 것을 검색함</td>
                    </tr>
                </table>

                <h2>OnComponentCreated 호출 시점 차이</h2>
                <div class="hierarchy-box">C++ 컴포넌트의 OnComponentCreated
┌──────────────────────────────────────────┐
│ SpawnActor                                │
│   ↓                                      │
│ PostSpawnInitialize                       │
│   ↓                                      │
│ DispatchOnComponentsCreated(this)  ✅     │
│   (C++ 컴포넌트만)                        │
└──────────────────────────────────────────┘

BP 컴포넌트의 OnComponentCreated
┌──────────────────────────────────────────┐
│ SpawnActor                                │
│   ↓                                      │
│ PostSpawnInitialize (C++ 컴포넌트 생성)  │
│   ↓                                      │
│ FinishSpawning                            │
│   ↓                                      │
│ ExecuteConstruction                       │
│   ↓                                      │
│ Blueprint SCS 컴포넌트 생성  ✅           │
│   (BP 컴포넌트)                           │
│   ↓                                      │
│ OnComponentCreated 호출                   │
└──────────────────────────────────────────┘</div>

                <h2>실전 활용 가이드</h2>
                <h3>컴포넌트 간 참조 시점</h3>
                <pre><code class="language-cpp">// ❌ C++ 컴포넌트에서 BP 컴포넌트 참조 (위험!)
void UMyCppComponent::OnComponentCreated()
{
    Super::OnComponentCreated();

    // ❌ 위험! BP 컴포넌트는 아직 생성 안됨
    UMyBPComponent* BPComp = GetOwner()->FindComponentByClass&lt;UMyBPComponent&gt;();
    if (BPComp)  // nullptr!
    {
        // 실행 안됨
    }
}


// ✅ InitializeComponent에서 참조 (안전)
void UMyCppComponent::InitializeComponent()
{
    Super::InitializeComponent();

    // ✅ 안전! 모든 컴포넌트가 생성되어 있음
    UMyBPComponent* BPComp = GetOwner()->FindComponentByClass&lt;UMyBPComponent&gt;();
    if (BPComp)  // 존재함!
    {
        BPComp->Setup();
    }
}


// ✅ BP 컴포넌트에서 C++ 컴포넌트 참조 (안전)
void UMyBPComponent::OnComponentCreated()
{
    Super::OnComponentCreated();

    // ✅ 안전! C++ 컴포넌트는 이미 생성됨
    UMyCppComponent* CppComp = GetOwner()->FindComponentByClass&lt;UMyCppComponent&gt;();
    if (CppComp)  // 존재함!
    {
        CppComp->Configure();
    }
}</code></pre>

                <h3>올바른 초기화 시점 선택</h3>
                <table>
                    <tr>
                        <th>시점</th>
                        <th>C++에서 C++</th>
                        <th>C++에서 BP</th>
                        <th>BP에서 C++</th>
                    </tr>
                    <tr>
                        <td><strong>OnComponentCreated</strong></td>
                        <td>✅ 가능</td>
                        <td>❌ 불가능</td>
                        <td>✅ 가능</td>
                    </tr>
                    <tr>
                        <td><strong>InitializeComponent</strong></td>
                        <td>✅ 가능</td>
                        <td>✅ 가능</td>
                        <td>✅ 가능</td>
                    </tr>
                    <tr>
                        <td><strong>PostInitializeComponents</strong></td>
                        <td colspan="3">모든 컴포넌트 참조 ✅ 안전</td>
                    </tr>
                </table>

                <h2>핵심 요약</h2>
                <ul>
                    <li>✅ <strong>실제 생성 시점</strong>: C++ 컴포넌트는 <strong>Constructor (NewObject 시점)</strong>에서 CreateDefaultSubobject로 생성</li>
                    <li>✅ <strong>알림 시점</strong>: PostSpawnInitialize의 DispatchOnComponentsCreated는 생성이 아니라 <strong>알림</strong></li>
                    <li>✅ <strong>생성 순서</strong>: C++ 컴포넌트 (Constructor) → BP 컴포넌트 (ExecuteConstruction)</li>
                    <li>✅ <strong>등록 지연</strong>: BP Root인 경우 RegisterAllComponents가 ExecuteConstruction까지 지연</li>
                    <li>✅ <strong>안전한 참조 시점</strong>: InitializeComponent 또는 PostInitializeComponents</li>
                </ul>

                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['spawn-sec5'] = {
            title: '액터 생성 종합 정리',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Spawn Actor</div>
                    <h1>액터 생성 및 초기화 과정 종합 정리</h1>
                </div>
                <h2>Overview</h2>
                <p>언리얼 엔진에서 액터가 생성되어 게임에서 동작하기까지의 <strong>전체 과정을 완벽하게 이해</strong>합니다.</p>

                <div class="callout">
                    <div class="callout-title">왜 이것이 중요한가?</div>
                    <table>
                        <tr>
                            <th>이유</th>
                            <th>설명</th>
                        </tr>
                        <tr>
                            <td><strong>올바른 시점 선택</strong></td>
                            <td>각 단계를 알아야 적절한 위치에 로직 배치 가능</td>
                        </tr>
                        <tr>
                            <td><strong>디버깅 효율성</strong></td>
                            <td>초기화 문제 발생 시 빠르게 원인 파악</td>
                        </tr>
                        <tr>
                            <td><strong>Override 지점 파악</strong></td>
                            <td>원하는 시점에 커스텀 로직 추가 가능</td>
                        </tr>
                        <tr>
                            <td><strong>네트워크 복제 이해</strong></td>
                            <td>복제 타이밍과 순서 파악</td>
                        </tr>
                    </table>
                </div>

                <h2>전체 프로세스 한눈에 보기</h2>
                <div class="hierarchy-box">┌──────────────────────────────────────────────────────────┐
│                   GetWorld()->SpawnActor()                │
└────────────────────┬─────────────────────────────────────┘
                     │
┌────────────────────▼─────────────────────────────────────┐
│ PART 1: 액터 생성 사전 처리 (UWorld::SpawnActor)         │
├──────────────────────────────────────────────────────────┤
│ 1️⃣ 레벨 결정                                             │
│ 2️⃣ Template/CDO 선택                                     │
│ 3️⃣ 고유한 액터 이름 생성                                 │
│ 4️⃣ Transform & Collision 설정                            │
│ 5️⃣ bNoFail 플래그 처리                                   │
│ 6️⃣ 생성 전 콜리전 체크                                   │
│ 7️⃣ NewObject로 액터 생성                                 │
│ 8️⃣ AActor::PostSpawnInitialize 호출                      │
└────────────────────┬─────────────────────────────────────┘
                     │
┌────────────────────▼─────────────────────────────────────┐
│ PART 2: 액터 생성 마무리 (AActor::FinishSpawning)        │
├──────────────────────────────────────────────────────────┤
│ 1️⃣ 최종 Transform 결정                                   │
│ 2️⃣ Transform 보정 (Deferred Spawn)                       │
│ 3️⃣ ExecuteConstruction (BP SCS 컴포넌트 생성)            │
│ 4️⃣ AActor::PostActorConstruction 호출                    │
│    ├─ Collision Handling 처리 ⚠️                         │
│    └─ 초기화 진입점                                      │
└────────────────────┬─────────────────────────────────────┘
                     │
┌────────────────────▼─────────────────────────────────────┐
│ PART 3: 액터 초기화 순서 (6단계)                         │
├──────────────────────────────────────────────────────────┤
│ 1️⃣ OnComponentCreated - 컴포넌트 생성 신호탄            │
│ 2️⃣ PreRegisterAllComponents - World 등록 준비           │
│ 3️⃣ RegisterAllComponents - World에 컴포넌트 등록        │
│ 4️⃣ InitializeComponent - 각 컴포넌트 초기화             │
│ 5️⃣ PostInitializeComponents - 액터 레벨 최종 초기화     │
│ 6️⃣ BeginPlay - 게임 로직 시작                           │
└──────────────────────────────────────────────────────────┘</div>

                <h2>상황별 적절한 Override 함수</h2>
                <table>
                    <tr>
                        <th>상황</th>
                        <th>사용 함수</th>
                    </tr>
                    <tr>
                        <td>컴포넌트 생성 직후 설정</td>
                        <td><code>OnComponentCreated</code></td>
                    </tr>
                    <tr>
                        <td>World 등록 전 충돌/물리 설정</td>
                        <td><code>PreRegisterAllComponents</code></td>
                    </tr>
                    <tr>
                        <td>컴포넌트별 초기화 로직</td>
                        <td><code>InitializeComponent</code></td>
                    </tr>
                    <tr>
                        <td>액터 레벨 초기화, 컴포넌트 간 상호작용</td>
                        <td><code>PostInitializeComponents</code></td>
                    </tr>
                    <tr>
                        <td>게임 로직 시작, 다른 액터 참조</td>
                        <td><code>BeginPlay</code></td>
                    </tr>
                </table>

                <h2>각 단계별 접근 가능 범위</h2>
                <table>
                    <tr>
                        <th>단계</th>
                        <th>World</th>
                        <th>자신 컴포넌트</th>
                        <th>다른 액터</th>
                    </tr>
                    <tr>
                        <td><strong>Constructor</strong></td>
                        <td>❌</td>
                        <td>⚠️ (기본값만)</td>
                        <td>❌</td>
                    </tr>
                    <tr>
                        <td><strong>OnComponentCreated</strong></td>
                        <td>❌</td>
                        <td>✅</td>
                        <td>❌</td>
                    </tr>
                    <tr>
                        <td><strong>PreRegisterAllComponents</strong></td>
                        <td>⚠️</td>
                        <td>✅</td>
                        <td>❌</td>
                    </tr>
                    <tr>
                        <td><strong>InitializeComponent</strong></td>
                        <td>✅</td>
                        <td>✅</td>
                        <td>⚠️</td>
                    </tr>
                    <tr>
                        <td><strong>PostInitializeComponents</strong></td>
                        <td>✅</td>
                        <td>✅</td>
                        <td>⚠️</td>
                    </tr>
                    <tr>
                        <td><strong>BeginPlay</strong></td>
                        <td>✅</td>
                        <td>✅</td>
                        <td>✅</td>
                    </tr>
                </table>

                <h2>주요 함수 Override 가이드</h2>
                <table>
                    <tr>
                        <th>함수</th>
                        <th>시점</th>
                        <th>주요 용도</th>
                        <th>주의사항</th>
                    </tr>
                    <tr>
                        <td><code>Constructor</code></td>
                        <td>클래스 생성</td>
                        <td>UPROPERTY 기본값</td>
                        <td>World 접근 불가</td>
                    </tr>
                    <tr>
                        <td><code>OnComponentCreated</code></td>
                        <td>컴포넌트 생성 후</td>
                        <td>컴포넌트 초기 설정</td>
                        <td>World 미등록 상태</td>
                    </tr>
                    <tr>
                        <td><code>InitializeComponent</code></td>
                        <td>등록 후</td>
                        <td>컴포넌트 초기화</td>
                        <td>다른 액터 주의</td>
                    </tr>
                    <tr>
                        <td><code>PostInitializeComponents</code></td>
                        <td>모든 컴포넌트 준비</td>
                        <td>액터 초기화, 복제 준비</td>
                        <td>다른 액터 주의</td>
                    </tr>
                    <tr>
                        <td><code>BeginPlay</code></td>
                        <td>게임 시작</td>
                        <td>게임 로직, 타이머</td>
                        <td>모든 것 접근 가능</td>
                    </tr>
                </table>

                <h2>디버깅 체크리스트</h2>
                <div class="hierarchy-box">액터 초기화 문제 발생 시 확인할 사항:

□ SpawnActor 후 null 체크 했는가?
□ Collision Handling 설정이 적절한가?
□ Deferred Spawn 시 FinishSpawning 호출했는가?
□ Super 호출을 먼저 했는가?
□ World 접근을 Constructor에서 하지 않았는가?
□ BeginPlay 조건이 모두 충족되었는가?
□ C++ Root vs BP Root 차이를 고려했는가?
□ 다른 액터를 BeginPlay 이전에 참조하지 않았는가?
□ bActorsInitialized 플래그를 확인했는가?
□ 네트워크 복제가 PostInitializeComponents에서 준비되는가?</div>

                <h2>반드시 기억해야 할 10가지</h2>
                <ol>
                    <li>✅ <strong>SpawnActor vs SpawnActorDeferred</strong> - bDeferConstruction 플래그만 다름</li>
                    <li>✅ <strong>액터 이름 고유성</strong> - 레벨 내에서 항상 고유, 중복 시 자동 번호 추가</li>
                    <li>✅ <strong>C++ 우선, BP 나중</strong> - C++ 컴포넌트가 먼저 생성됨</li>
                    <li>✅ <strong>Transform 보정</strong> - Deferred Spawn 시 중간 변경사항 반영</li>
                    <li>✅ <strong>Collision Destroy</strong> - Collision Handling으로 생성 실패 가능, null 체크 필수</li>
                    <li>✅ <strong>6단계 초기화</strong> - OnComponentCreated → BeginPlay</li>
                    <li>✅ <strong>네트워크 복제</strong> - PostInitializeComponents에서 ReadyForReplication 호출</li>
                    <li>✅ <strong>BeginPlay 조건</strong> - 5가지 조건 모두 충족 필요</li>
                    <li>✅ <strong>Constructor 제약</strong> - World 접근 불가, UPROPERTY 설정만</li>
                    <li>✅ <strong>Super 호출</strong> - Override 시 항상 먼저 Super 호출</li>
                </ol>

                <h2>올바른 사용 패턴</h2>
                <pre><code class="language-cpp">// ✅ 올바른 SpawnActor 사용
AActor* NewActor = GetWorld()->SpawnActor&lt;AMyActor&gt;();

if (NewActor)  // 항상 null 체크!
{
    NewActor->DoSomething();
}


// ✅ Deferred Spawn 올바른 사용
AActor* Actor = GetWorld()->SpawnActorDeferred&lt;AMyProjectile&gt;(...);

if (Actor)
{
    // ConstructionScript 실행 전 속성 설정
    Actor->Damage = CalculateDamage();
    Actor->TargetLocation = Target->GetActorLocation();

    // 반드시 FinishSpawning 호출!
    Actor->FinishSpawning(Transform);

    // 다시 null 체크 (Collision으로 Destroy 가능)
    if (Actor)
    {
        Actor->Launch();
    }
}


// ✅ PostInitializeComponents에서 동적 생성
void AMyActor::PostInitializeComponents()
{
    Super::PostInitializeComponents();  // Super 먼저!

    // 모든 컴포넌트 준비 후 추가 컴포넌트 생성
    if (HasAuthority())
    {
        UMyComponent* NewComp = NewObject&lt;UMyComponent&gt;(this);
        NewComp->RegisterComponent();
    }
}


// ✅ BeginPlay에서 다른 액터 참조
void AMyActor::BeginPlay()
{
    Super::BeginPlay();  // Super 먼저!

    // 모든 액터 준비 완료 시점
    AGameMode* GM = GetWorld()->GetAuthGameMode();
    if (GM)
    {
        GM->RegisterPlayer(this);
    }
}</code></pre>

                <div class="callout tip">
                    <div class="callout-title">Spawn Actor 학습 완료!</div>
                    <p>언리얼의 액터 생성 및 초기화 과정을 완벽하게 이해했습니다. <strong>핵심 원칙</strong>: 올바른 시점에 올바른 함수를 Override 하라!</p>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        // ========================================
        // Blueprint: 블루프린트 시스템과 SpawnActor (7.88~7.94)
        // ========================================

        sectionData['bp-sec1'] = {
            title: '블루프린트 개념',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Blueprint</div>
                    <h1>블루프린트 개념</h1>
                </div>
                <h2>Overview</h2>
                <p>블루프린트 시스템의 핵심 개념과 <strong>실시간 컴파일</strong>이 가능한 구조적 원리를 분석합니다.</p>

                <div class="callout">
                    <div class="callout-title">학습 목표</div>
                    <ul>
                        <li>블루프린트와 C++의 차이점 이해</li>
                        <li>UBlueprint와 GeneratedClass의 관계 파악</li>
                        <li>실시간 컴파일 메커니즘 이해</li>
                    </ul>
                </div>

                <h2>핵심 질문: 왜 블루프린트는 실시간 컴파일이 가능한가?</h2>
                <div class="callout tip">
                    <div class="callout-title">정답</div>
                    <p>블루프린트는 <strong>설계도(UBlueprint)</strong>와 <strong>실제 클래스(GeneratedClass)</strong>를 분리하여 관리합니다.</p>
                    <p>에디터에서 컴파일 버튼을 누르면 블루프린트 스크립트 데이터를 바탕으로 GeneratedClass를 새롭게 생성하거나 업데이트하기 때문에 실시간 컴파일이 가능합니다.</p>
                </div>

                <h2>블루프린트 시스템 구조</h2>
                <div class="flow-container">
                    <div class="flow-diagram" style="flex-direction: column; gap: 15px;">
                        <div class="flow-node" style="background: #e1f5ff;">블루프린트 에디터<br/>(노드 수정)</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #e1f5ff;">UBlueprint<br/>(설계도)</div>
                        <span class="flow-arrow">↓ 컴파일</span>
                        <div class="flow-node" style="background: #ffe1e1;">GeneratedClass<br/>(생성/갱신)</div>
                        <span class="flow-arrow">↓ 즉시 반영</span>
                        <div class="flow-node" style="background: #e1ffe1;">게임에서 사용</div>
                    </div>
                </div>

                <h2>UBlueprint 클래스</h2>
                <h3>1. 부모 클래스</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// 블루프린트가 상속받는 부모 클래스 정보
UPROPERTY(meta=(NoResetToDefault))
TSubclassOf&lt;UObject&gt; ParentClass;</code></pre>
                    </div>
                </div>
                <p><strong>역할</strong>: 블루프린트가 상속받는 C++ 또는 부모 블루프린트 클래스를 저장</p>

                <h3>2. 그래프 노드 저장</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// 함수, 이벤트, 매크로 그래프 저장
UPROPERTY()
TArray&lt;TObjectPtr&lt;UEdGraph&gt;&gt; FunctionGraphs;  // 함수 그래프

UPROPERTY(transient, duplicatetransient)
TArray&lt;TObjectPtr&lt;UEdGraph&gt;&gt; EventGraphs;     // 이벤트 그래프

UPROPERTY()
TArray&lt;TObjectPtr&lt;UEdGraph&gt;&gt; MacroGraphs;     // 매크로 그래프</code></pre>
                    </div>
                </div>
                <div class="callout">
                    <div class="callout-title">역할</div>
                    <ul>
                        <li>에디터에서 <strong>실시간으로 생성되는 노드</strong> 정보 저장</li>
                        <li>함수, 이벤트, 매크로 그래프를 <strong>각각 분리 관리</strong></li>
                        <li>컴파일 시 이 데이터를 기반으로 <strong>GeneratedClass 생성</strong></li>
                    </ul>
                </div>

                <h3>3. GeneratedClass (가장 중요!)</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// 실제 게임에서 사용되는 클래스
UPROPERTY(nontransactional)
TSubclassOf&lt;class UObject&gt; GeneratedClass;  // UBlueprintGeneratedClass 타입</code></pre>
                    </div>
                </div>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>구분</th><th>UBlueprint</th><th>GeneratedClass</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>역할</td><td>설계도 (Blueprint)</td><td>실제 클래스 (Class)</td></tr>
                            <tr><td>용도</td><td>에디터에서 편집</td><td>게임에서 사용</td></tr>
                            <tr><td>생성 시점</td><td>에셋 생성 시</td><td>컴파일 시</td></tr>
                            <tr><td>변경</td><td>에디터에서 자유롭게</td><td>컴파일마다 갱신</td></tr>
                        </tbody>
                    </table>
                </div>

                <h2>실시간 컴파일 메커니즘</h2>
                <div class="flow-container">
                    <div class="flow-diagram" style="flex-direction: column; gap: 15px;">
                        <div class="flow-node" style="background: #ffecb3;">에디터 컴파일 버튼 클릭</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">블루프린트 스크립트 데이터 분석</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">GeneratedClass 존재?</div>
                        <div style="display: flex; gap: 30px; justify-content: center;">
                            <div style="text-align: center;">
                                <span class="flow-arrow">Yes ↓</span>
                                <div class="flow-node" style="background: #fff3cd;">GeneratedClass 갱신</div>
                            </div>
                            <div style="text-align: center;">
                                <span class="flow-arrow">No ↓</span>
                                <div class="flow-node" style="background: #d4edda;">GeneratedClass 새로 생성</div>
                            </div>
                        </div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #c8e6c9;">즉시 적용 가능</div>
                    </div>
                </div>

                <h2>UBlueprintGeneratedClass</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// UClass를 상속하지만 블루프린트 메타데이터가 추가됨
class UBlueprintGeneratedClass : public UClass, public IBlueprintPropertyGuidProvider
{
    // 블루프린트 전용 메타데이터 포함
};</code></pre>
                    </div>
                </div>

                <h2>C++ vs 블루프린트 컴파일 비교</h2>
                <div class="flow-container">
                    <div class="flow-diagram" style="flex-direction: column; gap: 20px;">
                        <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; text-align: center;">
                            <strong>C++ 경로</strong><br/>
                            C++ Code → Unreal Header Tool → UClass
                        </div>
                        <div style="background: #f3e5f5; padding: 15px; border-radius: 8px; text-align: center;">
                            <strong>Blueprint 경로</strong><br/>
                            Blueprint → Blueprint Compile → UBlueprintGeneratedClass
                        </div>
                    </div>
                </div>

                <div class="callout">
                    <div class="callout-title">특징</div>
                    <ul>
                        <li>UClass를 상속받지만 <strong>블루프린트 메타데이터</strong>가 추가된 클래스</li>
                        <li>C++ 코드는 <strong>Unreal Header Tool</strong>을 통해 UClass 생성</li>
                        <li>블루프린트는 <strong>Blueprint Compile</strong>을 통해 UBlueprintGeneratedClass 생성</li>
                    </ul>
                </div>

                <h2>블루프린트 로드 방식</h2>
                <p>블루프린트를 주소로 로드할 때 <strong>\`_C\` 접미사</strong> 사용:</p>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>로드 방식</th><th>대상</th><th>용도</th></tr>
                        </thead>
                        <tbody>
                            <tr><td><strong>\`_C\` 사용</strong></td><td>GeneratedClass</td><td>게임에서 사용 (일반적)</td></tr>
                            <tr><td><strong>\`_C\` 미사용</strong></td><td>블루프린트 에셋 자체</td><td>에디터 전용</td></tr>
                        </tbody>
                    </table>
                </div>

                <h2>핵심 요약</h2>
                <div class="callout important">
                    <div class="callout-title">핵심 개념 3줄 요약</div>
                    <ul>
                        <li><strong>UBlueprint</strong>: 에디터에서 편집하는 <strong>설계도</strong></li>
                        <li><strong>GeneratedClass</strong>: 게임에서 실제로 사용되는 <strong>클래스</strong></li>
                        <li><strong>실시간 컴파일</strong>: 컴파일할 때마다 GeneratedClass를 <strong>갱신/생성</strong></li>
                    </ul>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['bp-sec2'] = {
            title: 'SimpleConstructionScript',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Blueprint</div>
                    <h1>SimpleConstructionScript (SCS)</h1>
                </div>
                <h2>Overview</h2>
                <p>블루프린트의 <strong>컴포넌트 계층 구조</strong>를 관리하는 SimpleConstructionScript (SCS) 시스템을 분석합니다.</p>

                <div class="callout">
                    <div class="callout-title">핵심 포인트</div>
                    <ul>
                        <li>SCS는 블루프린트 에디터 좌측 상단의 컴포넌트 계층 구조 관리</li>
                        <li>모든 블루프린트는 독립적인 SCS를 소유 (메모리 최적화)</li>
                        <li>Node 형태로 컴포넌트를 저장하여 계층 관리</li>
                        <li>UInheritableComponentHandler로 부모 컴포넌트 오버라이딩 지원</li>
                    </ul>
                </div>

                <h2>UBlueprintGeneratedClass 구조</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>class UBlueprintGeneratedClass : public UClass, public IBlueprintPropertyGuidProvider
{
    // 블루프린트에서 계층 구조를 담당
    TObjectPtr&lt;class USimpleConstructionScript&gt; SimpleConstructionScript;

    // 블루프린트 상속 구조 내에서 컴포넌트 템플릿의 오버라이드(재정의) 매핑
    // 기본 컴포넌트 템플릿(원본)을 유지하면서, 파생 블루프린트에서 일부만 수정 가능
    TObjectPtr&lt;class UInheritableComponentHandler&gt; InheritableComponentHandler;
}</code></pre>
                    </div>
                </div>

                <p><strong>두 가지 핵심 시스템</strong>:</p>
                <ul>
                    <li><strong>SimpleConstructionScript</strong>: 자신의 컴포넌트 계층 관리</li>
                    <li><strong>InheritableComponentHandler</strong>: 부모 컴포넌트 오버라이딩 관리</li>
                </ul>

                <h2>SCS 구조</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>class USimpleConstructionScript : public UObject
{
    // 최상위 노드들만 저장
    UPROPERTY()
    TArray&lt;TObjectPtr&lt;class USCS_Node&gt;&gt; RootNodes;

    // 모든 노드 저장
    UPROPERTY()
    TArray&lt;TObjectPtr&lt;class USCS_Node&gt;&gt; AllNodes;
}</code></pre>
                    </div>
                </div>

                <h2>RootNodes vs AllNodes</h2>
                <h3>RootNodes</h3>
                <ul>
                    <li>블루프린트에서 만든 컴포넌트 중 <strong>최상위 컴포넌트</strong>만 저장</li>
                    <li>컴포넌트가 없으면: 0개</li>
                    <li>최상위 2개 + 각각의 하위 2개 = <strong>여전히 2개</strong> (하위는 카운트 안 됨)</li>
                </ul>

                <h3>AllNodes</h3>
                <ul>
                    <li>블루프린트에서 만든 <strong>모든 컴포넌트</strong> 개수만큼 가짐</li>
                </ul>

                <div class="code-block">
                    <div class="code-header"><span class="code-lang">예시</span></div>
                    <div class="code-content">
<pre><code>Scene (Root)
├── StaticMesh1
│   └── StaticMesh2
└── PointLight

RootNodes: 2개 (Scene, PointLight)
AllNodes: 4개 (Scene, StaticMesh1, StaticMesh2, PointLight)</code></pre>
                    </div>
                </div>

                <h2>독립적 SCS 관리의 이유</h2>
                <div class="callout warning">
                    <div class="callout-title">질문: 왜 모든 블루프린트가 독립적으로 Node를 관리하는가?</div>
                    <p><strong>답변</strong>: 메모리 문제 발생 방지</p>
                </div>

                <div class="code-block">
                    <div class="code-header"><span class="code-lang">예시 상황</span></div>
                    <div class="code-content">
<pre><code>A (블루프린트) - 3개 컴포넌트 생성
    ↓ 상속
B (A의 자식) - 5개 컴포넌트 추가 생성
    ↓ 상속
C (B의 자식) - 0개 컴포넌트 생성

만약 부모 정보를 모두 포함한다면:
- A: 3개 인스턴스
- B: 3(A) + 5(자신) = 8개 인스턴스
- C: 3(A) + 5(B) + 0(자신) = 8개 인스턴스

총 메모리: 3 + 8 + 8 = 19개 인스턴스

상속 깊이가 깊어질수록 메모리 낭비가 기하급수적으로 증가!</code></pre>
                    </div>
                </div>

                <div class="callout tip">
                    <div class="callout-title">언리얼의 해결책</div>
                    <ul>
                        <li>각 블루프린트는 <strong>자신의 컴포넌트만</strong> SCS에 저장</li>
                        <li>부모 컴포넌트 수정은 <strong>UInheritableComponentHandler</strong>로 처리</li>
                    </ul>
                </div>

                <h2>USCS_Node 클래스</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>class USCS_Node
{
    // 생성할 컴포넌트의 클래스 타입 (UStaticMeshComponent, USkeletalMeshComponent 등)
    UPROPERTY()
    TObjectPtr&lt;UClass&gt; ComponentClass;

    // 블루프린트에서 설정한 속성값이 저장된 템플릿 인스턴스
    // 생성 시 이 템플릿을 복사하여 인스턴스화
    UPROPERTY()
    TObjectPtr&lt;class UActorComponent&gt; ComponentTemplate;

    // 자식 노드 배열
    UPROPERTY()
    TArray&lt;TObjectPtr&lt;class USCS_Node&gt;&gt; ChildNodes;
}</code></pre>
                    </div>
                </div>

                <h2>아키타입 (Archetype)</h2>
                <p><strong>ComponentTemplate의 역할</strong>:</p>
                <ul>
                    <li>블루프린트에서 컴포넌트 값을 계속 변경할 수 있음</li>
                    <li><strong>인스턴스 복사에 사용되는 템플릿</strong> = <strong>아키타입 (Archetype)</strong></li>
                    <li>CDO(Class Default Object)도 아키타입에 해당</li>
                </ul>

                <p><strong>ComponentClass의 역할</strong>:</p>
                <ul>
                    <li>블루프린트에서 값을 변경했다가 <strong>초기값으로 되돌릴 때</strong> 필요</li>
                    <li>기본값이 ComponentClass의 CDO에 저장되어 있음</li>
                </ul>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>항목</th><th>ComponentClass</th><th>ComponentTemplate</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>역할</td><td>초기 기본값</td><td>현재 설정값</td></tr>
                            <tr><td>용도</td><td>Reset to Default</td><td>인스턴스 복사</td></tr>
                            <tr><td>타입</td><td>UClass*</td><td>UActorComponent*</td></tr>
                        </tbody>
                    </table>
                </div>

                <div class="callout">
                    <div class="callout-title">왜 CDO를 직접 사용하지 않나?</div>
                    <ul>
                        <li>블루프린트에서 값을 바꿀 때마다 CDO를 새로 생성하는 것은 비효율적</li>
                        <li>CDO는 클래스마다 고유하게 가져야 하는 개념과 불일치</li>
                        <li>따라서 별도의 ComponentTemplate 사용</li>
                    </ul>
                </div>

                <h2>핵심 정리</h2>
                <div class="callout important">
                    <div class="callout-title">SCS 핵심 개념</div>
                    <ul>
                        <li><strong>SCS</strong>: 블루프린트 컴포넌트 계층 구조 관리</li>
                        <li><strong>독립적 관리</strong>: 각 BP는 자신의 컴포넌트만 저장 (메모리 최적화)</li>
                        <li><strong>Node 형태</strong>: 트리 구조로 부모-자식 관계 표현</li>
                        <li><strong>아키타입</strong>: ComponentTemplate이 인스턴스 복사의 원본</li>
                    </ul>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['bp-sec3'] = {
            title: '컴포넌트 오버라이딩',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Blueprint</div>
                    <h1>컴포넌트 오버라이딩</h1>
                </div>
                <h2>Overview</h2>
                <p>블루프린트 상속 구조에서 <strong>부모 컴포넌트를 오버라이딩</strong>하는 InheritableComponentHandler 시스템을 분석합니다.</p>

                <div class="callout">
                    <div class="callout-title">핵심 포인트</div>
                    <ul>
                        <li>자식 블루프린트는 부모 컴포넌트의 값을 수정 가능</li>
                        <li>UInheritableComponentHandler가 오버라이드 정보를 관리</li>
                        <li>변경된 컴포넌트만 저장하여 메모리 절약</li>
                        <li>부모 원본은 유지하면서 자식만의 수정사항 관리</li>
                    </ul>
                </div>

                <h2>UInheritableComponentHandler</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>class UInheritableComponentHandler
{
    // 오버라이드된 컴포넌트 정보를 저장하는 배열
    TArray&lt;FComponentOverrideRecord&gt; Records;
}</code></pre>
                    </div>
                </div>

                <p><strong>특징</strong>:</p>
                <ul>
                    <li>내부 구조는 매우 단순 - 배열 하나만 존재</li>
                    <li><strong>변경된 컴포넌트만 저장</strong> (메모리 최적화)</li>
                    <li>부모의 모든 컴포넌트를 저장하지 않음</li>
                </ul>

                <h2>FComponentOverrideRecord</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>struct FComponentOverrideRecord
{
    // 오버라이딩된 컴포넌트 (자식이 새로 만든 버전)
    TObjectPtr&lt;UClass&gt; ComponentClass;
    TObjectPtr&lt;UActorComponent&gt; ComponentTemplate;

    // 오버라이딩할 부모 컴포넌트 정보 (어떤 부모 컴포넌트를 대체하는지)
    FComponentKey ComponentKey;
};</code></pre>
                    </div>
                </div>

                <p><strong>구성 요소</strong>:</p>
                <ul>
                    <li><strong>ComponentKey</strong>: 부모의 어떤 컴포넌트를 오버라이드하는지 식별</li>
                    <li><strong>ComponentClass & ComponentTemplate</strong>: 오버라이드된 새로운 컴포넌트 정보</li>
                </ul>

                <h2>FComponentKey</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>struct FComponentKey
{
    // 부모 컴포넌트의 클래스
    TObjectPtr&lt;UClass&gt; OwnerClass;

    // 부모 컴포넌트의 변수 이름
    FName SCSVariableName;

    // 고유 식별자
    FGuid AssociatedGuid;
};</code></pre>
                    </div>
                </div>

                <p><strong>역할</strong>:</p>
                <ul>
                    <li>부모 블루프린트의 어떤 컴포넌트를 오버라이드하는지 식별</li>
                    <li>OwnerClass: 부모 블루프린트 클래스</li>
                    <li>SCSVariableName: 부모 컴포넌트의 변수명</li>
                </ul>

                <h2>오버라이딩 동작 예시</h2>
                <h3>시나리오</h3>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">예시</span></div>
                    <div class="code-content">
<pre><code>BP0 (부모 블루프린트)
    Component3 - Location: (0, 0, 0)
        ↓ 상속
BP1 (자식 블루프린트)
    Component3 값 변경 → Location: (50, 50, 50)</code></pre>
                    </div>
                </div>

                <h3>동작 과정</h3>
                <div class="flow-container">
                    <div class="flow-diagram" style="flex-direction: column; gap: 15px;">
                        <div class="flow-node" style="background: #e3f2fd;">1단계: BP0에서 Component3 기본값 설정<br/>Location: (0, 0, 0) → BP0의 SCS에 저장</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #fff3cd;">2단계: BP1에서 Component3 값 변경<br/>Location: (50, 50, 50) → Records 구조체 생성</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #d4edda;">3단계: BP1 인스턴스화<br/>오버라이드된 컴포넌트 발견 → Component4 생성</div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>FComponentOverrideRecord record;
// 어떤 부모 컴포넌트를 오버라이드하는지
record.ComponentKey = Component3의 키;

// 새로운 값이 적용된 컴포넌트
record.ComponentTemplate = Component4; // Location: (50, 50, 50)</code></pre>
                    </div>
                </div>

                <h2>메모리 효율성 비교</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>방식</th><th>BP0</th><th>BP1</th><th>BP2</th><th>총</th></tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>❌ 모든 부모 정보 저장</td>
                                <td>10개</td>
                                <td>10+5=15개</td>
                                <td>10+5+3=18개</td>
                                <td>43개</td>
                            </tr>
                            <tr>
                                <td>✅ 변경된 것만 저장</td>
                                <td>10개 (SCS)</td>
                                <td>5개 + 2개 Records</td>
                                <td>3개 + 1개 Records</td>
                                <td>21개</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h2>InheritableComponentHandler의 역할</h2>
                <div class="callout important">
                    <div class="callout-title">핵심 정리</div>
                    <ul>
                        <li><strong>부모 컴포넌트 오버라이딩 지원</strong>: 자식 블루프린트에서 부모 컴포넌트 값 변경 가능</li>
                        <li><strong>메모리 최적화</strong>: 부모 컴포넌트 정보를 모두 기록하지 않고 <strong>변경된 컴포넌트만</strong> Records에 저장</li>
                        <li><strong>원본 유지</strong>: 부모의 원본 컴포넌트는 그대로 유지, 자식만의 수정사항 별도 관리</li>
                    </ul>
                </div>

                <h2>핵심 원리 흐름</h2>
                <div class="flow-container">
                    <div class="flow-diagram" style="flex-direction: column; gap: 12px;">
                        <div class="flow-node">각 블루프린트는 자신의 컴포넌트만 SCS에 저장</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">부모 컴포넌트를 수정하면?</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #fff3cd;">InheritableComponentHandler의 Records에 오버라이드 정보 저장</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">인스턴스 생성 시 오버라이드 체크</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #d4edda;">오버라이드된 컴포넌트가 있으면 그것을 사용</div>
                    </div>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['bp-sec4'] = {
            title: 'ExecuteConstruction',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Blueprint</div>
                    <h1>ExecuteConstruction</h1>
                </div>
                <h2>Overview</h2>
                <p>블루프린트 SCS 구조에 맞춰 컴포넌트가 어떻게 <strong>생성되고 등록</strong>되는지 분석합니다.</p>

                <div class="callout">
                    <div class="callout-title">핵심 포인트</div>
                    <ul>
                        <li>ExecuteConstruction은 Native C++ 컴포넌트와 Blueprint 컴포넌트를 모두 처리</li>
                        <li><strong>8단계</strong>의 체계적인 과정으로 진행</li>
                        <li>RootComponent 설정과 등록 순서가 중요</li>
                        <li>Construction Script는 모든 컴포넌트 생성 후 호출</li>
                    </ul>
                </div>

                <h2>FinishSpawning에서의 호출</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>void AActor::FinishSpawning(const FTransform& UserTransform,
                            bool bIsDefaultTransform,
                            const FComponentInstanceDataCache* InstanceDataCache,
                            ESpawnActorScaleMethod TransformScaleMethod)
{
    // Native C++ 지연되었던 컴포넌트 등록 + Blueprint SCS 컴포넌트 생성 및 등록
    ExecuteConstruction(FinalRootComponentTransform, nullptr, InstanceDataCache,
                       bIsDefaultTransform, TransformScaleMethod);
}</code></pre>
                    </div>
                </div>

                <h2>8단계 전체 과정</h2>
                <div class="flow-container">
                    <div class="flow-diagram" style="flex-direction: column; gap: 10px;">
                        <div class="flow-node" style="background: #e3f2fd;">1단계: 블루프린트 계층 구조 수집</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #e3f2fd;">2단계: SCS 실행 전 컴포넌트 수집</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #e3f2fd;">3단계: Native SceneComponent 정리</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #fff3cd;">4단계: 부모→자식 순 BP 컴포넌트 생성</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #fff3cd;">5단계: BP RootComponent 등록 확인</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #fff3cd;">6단계: 미등록 컴포넌트 확인</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #d4edda;">7단계: Blueprint Construction Script</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #d4edda;">8단계: C++ OnConstruction</div>
                    </div>
                </div>

                <h2>1단계: 블루프린트 계층 구조 수집</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// 1. 블루프린트 계층구조 부모를 전부 가져와서 저장
// AActor ◄─────── BP0 ◄────── BP1
// [BP0, BP1] are collected
TArray&lt;const UBlueprintGeneratedClass*&gt; ParentBPClassStack;
const bool bErrorFree = UBlueprintGeneratedClass::GetGeneratedClassesHierarchy(
    GetClass(), ParentBPClassStack);</code></pre>
                    </div>
                </div>
                <p><strong>동작</strong>: 자신을 포함한 모든 부모 블루프린트 클래스 수집 (Native C++ 클래스는 제외)</p>

                <h2>2단계: SCS 실행 전 컴포넌트 수집</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// 2. SCS 실행 전에 액터가 소유한 모든 컴포넌트를 가져옴
TInlineComponentArray&lt;UActorComponent*&gt; PreSCSComponents;
GetComponents(PreSCSComponents);</code></pre>
                    </div>
                </div>
                <p><strong>특징</strong>: 블루프린트 컴포넌트는 아직 생성 전, <strong>Native C++에서 생성된 컴포넌트만</strong> 수집됨</p>

                <h2>3단계: Native C++ SceneComponent 정리</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// 3. C++에서 정의된 SceneComponent 저장
TInlineComponentArray&lt;USceneComponent*&gt; NativeSceneComponents;
for (UActorComponent* ActorComponent : PreSCSComponents)
{
    if (USceneComponent* SceneComponent = Cast&lt;USceneComponent&gt;(ActorComponent))
    {
        // 컴포넌트가 SceneComponent + Native C++이면서 Actor를 통해 생성된 경우만 추적
        if (SceneComponent->CreationMethod == EComponentCreationMethod::Native &&
            SceneComponent->GetOuter()->IsA&lt;AActor&gt;())
        {
            // 루트 컴포넌트가 설정되지 않은 경우
            // 첫 번째 Native C++ SceneComponent를 루트로 사용
            if (RootComponent == nullptr && SceneComponent->GetAttachParent() == nullptr)
            {
                SetRootComponent(SceneComponent);
            }
            NativeSceneComponents.Add(SceneComponent);
        }
    }
}</code></pre>
                    </div>
                </div>
                <div class="callout">
                    <div class="callout-title">왜 SceneComponent만 저장하나?</div>
                    <p>블루프린트 컴포넌트가 Native SceneComponent에 <strong>부착될 수 있기 때문</strong></p>
                </div>

                <h2>4단계: 블루프린트 컴포넌트 생성 및 등록</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// 배열을 거꾸로 순회하는 이유는 맨 뒤가 최상위 부모로 저장되어 있기 때문
// ParentBPClassStack: [C, B, A]
// 순회 순서: A -> B -> C

for (int32 i = ParentBPClassStack.Num() - 1; i >= 0; i--)
{
    const UBlueprintGeneratedClass* CurrentBPGClass = ParentBPClassStack[i];
    USimpleConstructionScript* SCS = CurrentBPGClass->SimpleConstructionScript;
    if (SCS)
    {
        SCS->ExecuteScriptOnActor(this, NativeSceneComponents, Transform, ...);
    }
}</code></pre>
                    </div>
                </div>
                <div class="callout tip">
                    <div class="callout-title">역순 순회 이유</div>
                    <p>부모부터 자식 순서로 컴포넌트 생성 → 부모 컴포넌트에 자식 컴포넌트 부착 가능</p>
                </div>

                <h2>5단계: 블루프린트 RootComponent 등록</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// 5. 블루프린트 루트 컴포넌트가 생성되었고 혹시나 Register 안될 수 있어서 다시 체크
if (HasDeferredComponentRegistration() && GetWorld()->bIsWorldInitialized)
{
    RegisterAllComponents();
}</code></pre>
                    </div>
                </div>

                <h2>6단계: 미등록 컴포넌트 확인 및 등록</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// 6. SCS에서 중간에 생성된 등록되지 않은 새 컴포넌트를 체크해서 등록
TInlineComponentArray&lt;UActorComponent*&gt; PostSCSComponents;
GetComponents(PostSCSComponents);

for (UActorComponent* ActorComponent : PostSCSComponents)
{
    if (!ActorComponent->IsRegistered() && ActorComponent->bAutoRegister && ...)
    {
        USimpleConstructionScript::RegisterInstancedComponent(ActorComponent);
    }
}</code></pre>
                    </div>
                </div>

                <h2>7단계: Blueprint Construction Script 호출</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// 7. UserConstructionScript 호출
ProcessUserConstructionScript();</code></pre>
                    </div>
                </div>
                <div class="callout important">
                    <div class="callout-title">Construction Script 특징</div>
                    <ul>
                        <li>모든 컴포넌트 생성 완료 후 <strong>가장 먼저 호출되는 함수</strong></li>
                        <li>C++, 블루프린트 컴포넌트 모두 생성 및 등록 완료 상태</li>
                        <li>여기서 컴포넌트를 생성하면 CDO, SCS에 반영 안 됨 (동적 컴포넌트 생성용)</li>
                        <li>블루프린트 컴파일 시마다 호출 (시각적 효과 디자인 테스트 가능)</li>
                    </ul>
                </div>

                <h2>8단계: C++ OnConstruction 호출</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// 8. OnConstruction 호출
OnConstruction(Transform);</code></pre>
                    </div>
                </div>
                <p>C++용 Construction 함수로 Virtual 함수로 오버라이드 가능</p>

                <h2>컴포넌트 등록 순서</h2>
                <div class="callout important">
                    <div class="callout-title">핵심 등록 순서</div>
                    <ol>
                        <li><strong>RootComponent</strong> 등록</li>
                        <li><strong>Native C++ Component</strong> 등록</li>
                        <li><strong>Blueprint Component</strong> 등록</li>
                    </ol>
                    <p>💡 <strong>Lyra의 ExtensionComponent는 이 등록 순서를 활용합니다!</strong></p>
                </div>

                <h2>Transform 최적화</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// bIsDefaultTransform가 true면 변화가 없으므로 SetWorldTransform을 진행하지 않음
// 이동은 굉장히 무거운 연산임을 기억!
if (RootComponent && !bIsDefaultTransform)
{
    RootComponent->SetWorldTransform(Transform, /*bSweep=*/false,
                                    /*OutSweepHitResult=*/nullptr,
                                    ETeleportType::TeleportPhysics);
}</code></pre>
                    </div>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['bp-sec5'] = {
            title: 'SCS 컴포넌트 생성 준비',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Blueprint</div>
                    <h1>SCS 컴포넌트 생성 준비</h1>
                </div>
                <h2>Overview</h2>
                <p>블루프린트에서 생성한 컴포넌트를 실제로 생성하기 전, 어떤 <strong>준비 과정</strong>을 거치고 어떤 식으로 생성을 요청하는지 분석합니다.</p>

                <div class="callout">
                    <div class="callout-title">핵심 포인트</div>
                    <ul>
                        <li>SCS의 RootNodes만 순회 (자식은 재귀적으로 처리)</li>
                        <li>DefaultSceneRootNode는 특수 처리</li>
                        <li>RootNode도 부모 컴포넌트가 존재 (Native C++ 또는 부모 BP)</li>
                        <li>부모 찾기: Native는 이름으로, BP는 리플렉션으로</li>
                    </ul>
                </div>

                <h2>호출 지점</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// AActor::ExecuteConstruction
USimpleConstructionScript* SCS = CurrentBPGClass->SimpleConstructionScript;
if (SCS)
{
    SCS->ExecuteScriptOnActor(this, NativeSceneComponents, Transform,
                             TransformRotationCache, bIsDefaultTransform,
                             TransformScaleMethod);
}</code></pre>
                    </div>
                </div>

                <h2>RootNodes 순회</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// 블루프린트에서 생성한 컴포넌트 중 최상위만 RootNodes
for (USCS_Node* RootNode : RootNodes)
{
    // ...
}</code></pre>
                    </div>
                </div>
                <p><strong>특징</strong>: SCS의 RootNodes만 직접 순회, 하위 컴포넌트는 재귀 호출로 처리</p>

                <h2>DefaultSceneRootNode 처리</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// RootNode가 DefaultSceneRootNode인 경우
// RootComponent가 없는 경우에만 생성하도록 설정
if (RootNode && ((RootNode != DefaultSceneRootNode) || (RootComponent == nullptr)))
{
    // ...
}</code></pre>
                    </div>
                </div>

                <div class="callout">
                    <div class="callout-title">DefaultSceneRootNode란?</div>
                    <ul>
                        <li>블루프린트에서 RootComponent가 없는 경우 자동 배정되는 특수 노드</li>
                        <li>언리얼 에디터에서 빈 액터 블루프린트 생성 시 'DefaultSceneRoot' 확인 가능</li>
                    </ul>
                </div>

                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>조건</th><th>처리</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>RootNode ≠ DefaultSceneRootNode</td><td>무조건 생성</td></tr>
                            <tr><td>RootNode = DefaultSceneRootNode</td><td>RootComponent 없을 때만 생성</td></tr>
                        </tbody>
                    </table>
                </div>

                <h2>부모 컴포넌트 찾기</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>USceneComponent* ParentComponent = nullptr;

// RootNode에 부모 이름이 설정되어 있는 경우 부모를 찾는 로직
if(RootNode->ParentComponentOrVariableName != NAME_None)
{
    UClass* ActorClass = Actor->GetClass();

    // 부모가 Native C++이라면 NativeComponent에서 찾아서 저장
    if(RootNode->bIsParentComponentNative)
    {
        for(USceneComponent* NativeSceneComponent : NativeSceneComponents)
        {
            if(NativeSceneComponent->GetFName() == RootNode->ParentComponentOrVariableName)
            {
                ParentComponent = NativeSceneComponent;
                break;
            }
        }
    }
    // 부모가 블루프린트인 경우 리플렉션을 이용해서 저장
    else
    {
        FObjectPropertyBase* Property = FindFProperty&lt;FObjectPropertyBase&gt;(
            ActorClass, RootNode->ParentComponentOrVariableName);

        if(Property != nullptr)
        {
            ParentComponent = Cast&lt;USceneComponent&gt;(
                Property->GetObjectPropertyValue_InContainer(Actor));
        }
    }
}</code></pre>
                    </div>
                </div>

                <div class="callout warning">
                    <div class="callout-title">왜 RootNode에 부모가 있나?</div>
                    <ul>
                        <li>RootNode는 <strong>나의 SCS 기준 최상위</strong></li>
                        <li>하지만 부모 블루프린트나 Native C++에 컴포넌트가 있을 수 있음</li>
                        <li>RootNode라도 부모 컴포넌트에 부착될 수 있음</li>
                    </ul>
                </div>

                <h2>부모 찾기 전략</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>부모 타입</th><th>검색 방법</th><th>이유</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>Native C++</td><td>이름으로 직접 검색</td><td>컴파일 타임에 이름 고정</td></tr>
                            <tr><td>Blueprint</td><td>리플렉션 사용</td><td>런타임에 동적 생성</td></tr>
                        </tbody>
                    </table>
                </div>

                <h2>RootNodes의 의미</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">예시</span></div>
                    <div class="code-content">
<pre><code>BP0 (부모)
    Component1 (Native C++)
        ↓
BP1 (자식, 현재 SCS)
    Component2  ← RootNode (BP1의 SCS 기준 최상위)
    ├── Component3
    └── Component4

설명:
- Component2는 BP1의 SCS에서 RootNode
- 하지만 Component1(부모)에 부착될 수 있음
- RootNode ≠ 절대적 최상위, SCS 기준 최상위</code></pre>
                    </div>
                </div>

                <h2>컴포넌트 생성 요청</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// 액터와 부모정보를 모두 넘겨서 루트노드의 컴포넌트 + 자식 컴포넌트까지 모두 생성
RootNode->ExecuteNodeOnActor(Actor,
                             ParentComponent != nullptr ? ParentComponent : RootComponent,
                             &RootTransform,
                             RootRelativeRotationCache,
                             bIsDefaultTransform,
                             TransformScaleMethod);</code></pre>
                    </div>
                </div>

                <h2>예외 상황 처리</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// RootNode도 없고 RootComponent도 없는 특수한 상황에는
// 임시 SceneComponent를 생성해서 Root로 설정
else if(Actor->GetRootComponent() == nullptr)
{
    USceneComponent* SceneComp = NewObject&lt;USceneComponent&gt;(Actor);
    SceneComp->CreationMethod = EComponentCreationMethod::SimpleConstructionScript;
    SceneComp->SetWorldTransform(RootTransform);
    Actor->SetRootComponent(SceneComp);
    SceneComp->RegisterComponent();
}</code></pre>
                    </div>
                </div>

                <div class="callout important">
                    <div class="callout-title">중요</div>
                    <p>언리얼 엔진은 <strong>RootComponent가 무조건 존재</strong>하도록 만듭니다!</p>
                </div>

                <h2>생성 흐름 요약</h2>
                <div class="flow-container">
                    <div class="flow-diagram" style="flex-direction: column; gap: 12px;">
                        <div class="flow-node">ExecuteScriptOnActor 호출</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">RootNodes 순회</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">DefaultSceneRootNode 체크</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #fff3cd;">부모 이름 있음? → Native or BP?</div>
                        <div style="display: flex; gap: 30px; justify-content: center;">
                            <div style="text-align: center;">
                                <span class="flow-arrow">Native ↓</span>
                                <div class="flow-node">이름으로 검색</div>
                            </div>
                            <div style="text-align: center;">
                                <span class="flow-arrow">BP ↓</span>
                                <div class="flow-node">리플렉션으로 검색</div>
                            </div>
                        </div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #d4edda;">ExecuteNodeOnActor 호출</div>
                    </div>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['bp-sec6'] = {
            title: 'SCS 컴포넌트 생성 및 등록',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Blueprint</div>
                    <h1>SCS 컴포넌트 생성 및 등록</h1>
                </div>
                <h2>Overview</h2>
                <p>SCS 노드에서 컴포넌트를 <strong>실제로 생성</strong>하는 과정을 상세히 분석합니다.</p>

                <div class="callout">
                    <div class="callout-title">핵심 포인트</div>
                    <ul>
                        <li>템플릿 가져올 때 <strong>오버라이딩 체크</strong> (핵심 로직!)</li>
                        <li>StaticDuplicateObjectEx로 <strong>깊은 복사</strong></li>
                        <li>RootComponent 설정 시 RegisterAllComponents 호출</li>
                        <li>등록 순서: Root → Native C++ → BP Component</li>
                        <li>리플렉션으로 액터 변수에 할당</li>
                        <li>자식 노드는 재귀적으로 생성</li>
                    </ul>
                </div>

                <h2>템플릿 가져오기 (가장 중요!)</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// Actor에서 Class를 가져와 BlueprintGeneratedClass로 형변환
UBlueprintGeneratedClass* ActualBPGC = CastChecked&lt;UBlueprintGeneratedClass&gt;(Actor->GetClass());

// 생성하려는 노드의 컴포넌트를 오버라이딩 했을 수 있어서 실제 템플릿 컴포넌트를 가져옴
// 제일 중요!!!
if (UActorComponent* ActualComponentTemplate = GetActualComponentTemplate(ActualBPGC))
{
    // 템플릿을 이용해서 컴포넌트 생성
    NewActorComp = Actor->CreateComponentFromTemplate(ActualComponentTemplate, InternalVariableName);
}</code></pre>
                    </div>
                </div>

                <h2>GetActualComponentTemplate - 오버라이딩 체크</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// SCS_Node의 Outer는 SCS!
const USimpleConstructionScript* SCS = GetSCS();

// 서로 다른 SCS를 가져야 override 조건 검사를 할 수 있는 상황
if (SCS != ActualBPGC->SimpleConstructionScript)
{
    // 해당 컴포넌트에 오버라이딩된 템플릿이 있는지 찾기 위한 Key
    const FComponentKey ComponentKey(this);

    do
    {
        // 현재 SCS의 InheritableComponentHandler 가져옴
        UInheritableComponentHandler* InheritableComponentHandler =
            ActualBPGC->GetInheritableComponentHandler();

        if (InheritableComponentHandler)
        {
            // Template 가져옴 → 오버라이딩된 게 없으면 nullptr 반환
            OverridenComponentTemplate =
                InheritableComponentHandler->GetOverridenComponentTemplate(ComponentKey);
        }

        // 상속 구조에서 나와 동일한 SCS를 찾아서 계속 위로 올라감
        ActualBPGC = Cast&lt;UBlueprintGeneratedClass&gt;(ActualBPGC->GetSuperClass());

    } while (!OverridenComponentTemplate && ActualBPGC && SCS != ActualBPGC->SimpleConstructionScript);
}

// Override 된 게 없으면 나의 Template 바로 반환
return OverridenComponentTemplate ? OverridenComponentTemplate : ToRawPtr(ComponentTemplate);</code></pre>
                    </div>
                </div>

                <div class="callout warning">
                    <div class="callout-title">왜 부모로 올라가나?</div>
                    <p>상속 구조: BP_GrandParent → BP_Parent → BP_Child</p>
                    <p>BP_Parent는 오버라이드 안 했지만 BP_Child는 했을 수 있음 → 모든 자식 BP를 순회하며 오버라이드 찾기</p>
                </div>

                <h2>CreateComponentFromTemplate</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>UActorComponent* NewActorComp = nullptr;

if (Template != nullptr)
{
    // 유니크한 이름을 배정 (Character_1, Character_2)
    if (InName == NAME_None)
    {
        InName = FindFirstFreeName(this, Template->GetFName());
    }

    // 템플릿을 복제해서 생성
    FObjectDuplicationParameters DupeActorParameters(Template, this);
    DupeActorParameters.DestName = InName;
    NewActorComp = (UActorComponent*)StaticDuplicateObjectEx(DupeActorParameters);

    // 블루프린트에서 생성된 컴포넌트 후속처리 함수
    PostCreateBlueprintComponent(NewActorComp);
}

return NewActorComp;</code></pre>
                    </div>
                </div>

                <div class="callout important">
                    <div class="callout-title">StaticDuplicateObjectEx의 힘</div>
                    <ul>
                        <li>정말 <strong>깊은 복사</strong> (Deep Copy)</li>
                        <li>액터를 복제하면 관련 컴포넌트까지 전부 복제</li>
                        <li>템플릿의 모든 속성값 복사</li>
                    </ul>
                </div>

                <h2>RootComponent 설정 (중요!)</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// ParentComponent가 null인 경우 블루프린트에서는 무조건 Root임
if (!IsValid(ParentComponent))
{
    NewSceneComp->SetWorldTransform(WorldTransform);
    Actor->SetRootComponent(NewSceneComp);

    // 매우 중요
    // Blueprint의 SCS의 컴포넌트에서 Root를 설정한 경우
    // 이제 Root 설정되었으니 등록 시작
    if (Actor->HasDeferredComponentRegistration() && bRegisterComponent)
    {
        Actor->RegisterAllComponents();
    }
}</code></pre>
                    </div>
                </div>

                <div class="callout tip">
                    <div class="callout-title">핵심 개념: 컴포넌트 등록 순서</div>
                    <ol>
                        <li>RootComponent 등록</li>
                        <li>Native C++ Component 등록</li>
                        <li>BP Component 등록</li>
                    </ol>
                    <p>💡 <strong>Lyra의 ExtensionComponent는 이 순서를 활용합니다!</strong></p>
                </div>

                <h2>일반 컴포넌트 부착 및 등록</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// RootComponent가 있는 경우에는 Parent에 부착 초기설정만 진행
else
{
    NewSceneComp->SetupAttachment(ParentComponent, AttachToName);
}

// SCS에서 생성된 컴포넌트 Register 진행
if (bRegisterComponent)
{
    USimpleConstructionScript::RegisterInstancedComponent(NewSceneComp);
}</code></pre>
                    </div>
                </div>

                <h2>액터 변수에 저장 (리플렉션)</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// Actor의 Name에 해당하는 컴포넌트 변수에 NewActorComp를 할당
FName VarName = InternalVariableName;
if (VarName != NAME_None)
{
    UClass* ActorClass = Actor->GetClass();
    if (FObjectPropertyBase* Prop = FindFProperty&lt;FObjectPropertyBase&gt;(ActorClass, VarName))
    {
        if (Prop->PropertyClass == nullptr || NewActorComp->IsA(Prop->PropertyClass))
        {
            Prop->SetObjectPropertyValue_InContainer(Actor, NewActorComp);
        }
    }
}</code></pre>
                    </div>
                </div>

                <div class="callout">
                    <div class="callout-title">왜 리플렉션?</div>
                    <ul>
                        <li>템플릿을 활용했기 때문에 리플렉션 사용</li>
                        <li>블루프린트에서 정의한 컴포넌트 변수에 할당</li>
                        <li>코드에서 \`UStaticMeshComponent* MeshComp\`로 접근 가능</li>
                    </ul>
                </div>

                <h2>자식 노드 재귀 생성</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// 내 자식이 존재한다면 동일하게 호출
USceneComponent* ParentSceneComponentOfChildren =
    (NewSceneComp != nullptr) ? NewSceneComp : ParentComponent;

for (int32 NodeIdx = 0; NodeIdx < ChildNodes.Num(); NodeIdx++)
{
    USCS_Node* Node = ChildNodes[NodeIdx];
    check(Node != nullptr);
    Node->ExecuteNodeOnActor(Actor, ParentSceneComponentOfChildren,
                            nullptr, nullptr, false);
}</code></pre>
                    </div>
                </div>

                <h2>핵심 흐름</h2>
                <div class="flow-container">
                    <div class="flow-diagram" style="flex-direction: column; gap: 10px;">
                        <div class="flow-node" style="background: #fff3cd;">GetActualComponentTemplate<br/>(오버라이딩 체크)</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">CreateComponentFromTemplate</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #ffc107;">StaticDuplicateObjectEx<br/>(깊은 복사)</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">OnComponentCreated 호출</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">SceneComponent? → ParentComponent 존재?</div>
                        <div style="display: flex; gap: 30px; justify-content: center;">
                            <div style="text-align: center;">
                                <span class="flow-arrow">No ↓</span>
                                <div class="flow-node" style="background: #d4edda;">RootComponent 설정<br/>→ RegisterAllComponents</div>
                            </div>
                            <div style="text-align: center;">
                                <span class="flow-arrow">Yes ↓</span>
                                <div class="flow-node">SetupAttachment</div>
                            </div>
                        </div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">리플렉션으로 변수 할당</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #c8e6c9;">자식 노드 재귀 생성</div>
                    </div>
                </div>

                <div class="callout tip">
                    <div class="callout-title">언리얼 분석 팁</div>
                    <p>언리얼을 분석할수록 과정이 반복됩니다. 한 번 제대로 분석하면, 앞으로 분석할수록 난이도가 낮아집니다!</p>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['bp-sec7'] = {
            title: 'SpawnActor 정리',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Blueprint</div>
                    <h1>SpawnActor 정리</h1>
                </div>
                <h2>Overview</h2>
                <p>SpawnActor의 <strong>전체 과정</strong>을 단계별로 정리하고, 각 단계의 의미와 중요성을 파악합니다.</p>

                <div class="callout">
                    <div class="callout-title">핵심 포인트</div>
                    <ul>
                        <li>SpawnActor는 <strong>6단계</strong>의 체계적 과정</li>
                        <li>Native C++와 Blueprint 컴포넌트는 생성 시점이 다름</li>
                        <li>PostActorConstruction에서 액터 생존 보장</li>
                        <li>PlayerState는 PostInitialize에서 생성되는 이유</li>
                    </ul>
                </div>

                <h2>SpawnActor 6단계 전체 흐름</h2>
                <div class="flow-container">
                    <div class="flow-diagram" style="flex-direction: column; gap: 10px;">
                        <div class="flow-node" style="background: #e3f2fd;">1️⃣ NewObject로 액터 생성<br/>(생성자 호출, Native C++ 컴포넌트 생성)</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #e3f2fd;">2️⃣ DispatchOnComponentsCreated<br/>(Native C++ 컴포넌트만)</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #fff3cd;">3️⃣ BP RootComponent? → 등록 지연</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #fff3cd;">4️⃣ FinishSpawning<br/>(ExecuteConstruction, BP 컴포넌트 생성)</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #d4edda;">5️⃣ PostActorConstruction<br/>(Pre/Post InitializeComponents)</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #c8e6c9;">6️⃣ DispatchBeginPlay</div>
                    </div>
                </div>

                <h2>1단계: NewObject로 액터 생성</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// 가장 먼저 NewObject를 통해 액터 생성
AActor* Actor = NewObject&lt;AActor&gt;(GetTransientPackage(), Class);</code></pre>
                    </div>
                </div>
                <p><strong>역할</strong>: UObject 생성, 생성자 호출, Native C++ 컴포넌트의 CreateDefaultSubobject 실행</p>

                <h2>2단계: DispatchOnComponentsCreated</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// Native C++ 관련 컴포넌트만 처리
Actor->DispatchOnComponentsCreated();</code></pre>
                    </div>
                </div>
                <p><strong>대상</strong>: Native C++ 컴포넌트만 (Blueprint 컴포넌트는 아직 생성 전)</p>

                <h2>3단계: 블루프린트 컴포넌트 지연</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// 블루프린트 컴포넌트가 root라면 지연
if (BlueprintComponentIsRoot)
{
    // RegisterAllComponents 지연
}</code></pre>
                    </div>
                </div>
                <div class="callout warning">
                    <div class="callout-title">SpawnActorDeferred 특징</div>
                    <p>블루프린트 관련 컴포넌트 생성은 진행되지 않음. FinishSpawning 호출 전까지 대기!</p>
                </div>

                <h2>4단계: FinishSpawning - ExecuteConstruction</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// FinishSpawning에서 ExecuteConstruction 호출
Actor->FinishSpawning(Transform, bIsDefaultTransform);
    ↓
ExecuteConstruction
    ↓
// 블루프린트 관련 컴포넌트 생성 및 등록
// 만약 BP가 루트여서 지연되었던 부분도 진행</code></pre>
                    </div>
                </div>
                <p><strong>처리 내용</strong>: Blueprint SCS 컴포넌트 생성 및 등록, 지연되었던 등록 작업 수행, Construction Script 호출</p>

                <h2>5단계: PostActorConstruction</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// PostActorConstruction에서 초기화 관련 로직을 순차적으로 진행
PostActorConstruction();

// 상세 순서:
// 1. PreInitializeComponents
// 2. InitializeComponent
// 3. PostInitializeComponents</code></pre>
                    </div>
                </div>

                <div class="callout important">
                    <div class="callout-title">중요: 액터 Destroy 가능성</div>
                    <p>Pre, InitializeComponent 단계에서 혹시라도 액터가 Destroy될 여지가 있음!</p>
                </div>

                <h2>PostInitializeComponents의 중요성</h2>
                <div class="callout warning">
                    <div class="callout-title">질문: PlayerState는 왜 PostInitializeComponents에서 생성될까?</div>
                    <p><strong>답변</strong>: PostActorConstruction의 안전성 보장</p>
                </div>

                <div class="flow-container">
                    <div class="flow-diagram" style="flex-direction: column; gap: 12px;">
                        <div class="flow-node">PostActorConstruction 시작</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">PreInitializeComponents</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #ffcdd2;">❌ 액터 Destroy 가능</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">InitializeComponent</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #ffcdd2;">❌ 액터 Destroy 가능</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #c8e6c9;">PostInitializeComponents<br/>✅ 액터 생존 확실히 보장</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #d4edda;">PlayerState 생성 (안전!)</div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>void APlayerController::PostInitializeComponents()
{
    Super::PostInitializeComponents();

    // 이 시점에는 액터가 확실히 생존
    // PlayerState 생성 안전
    if (!PlayerState)
    {
        PlayerState = GetWorld()->SpawnActor&lt;APlayerState&gt;(...);
    }
}</code></pre>
                    </div>
                </div>

                <h2>6단계: DispatchBeginPlay</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code>// 마지막에 DispatchBeginPlay
Actor->DispatchBeginPlay();</code></pre>
                    </div>
                </div>
                <p><strong>역할</strong>: BeginPlay 호출, 게임 로직 시작</p>

                <h2>컴포넌트 생성 시점 비교</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>컴포넌트 타입</th><th>생성 시점</th><th>호출 함수</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>Native C++</td><td>NewObject 시</td><td>생성자</td></tr>
                            <tr><td>Blueprint</td><td>FinishSpawning 시</td><td>ExecuteConstruction</td></tr>
                        </tbody>
                    </table>
                </div>

                <h2>핵심 정리</h2>
                <div class="callout important">
                    <div class="callout-title">SpawnActor 6단계 요약</div>
                    <ol>
                        <li><strong>NewObject로 액터 생성</strong>: 생성자 호출, Native C++ 컴포넌트 생성</li>
                        <li><strong>DispatchOnComponentsCreated</strong>: Native 컴포넌트 초기화</li>
                        <li><strong>블루프린트 컴포넌트 지연</strong>: BP Root인 경우 등록 지연</li>
                        <li><strong>FinishSpawning → ExecuteConstruction</strong>: BP 컴포넌트 생성 및 등록</li>
                        <li><strong>PostActorConstruction</strong>: Pre → Initialize → <strong>Post (액터 생존 보장)</strong></li>
                        <li><strong>DispatchBeginPlay</strong>: BeginPlay 호출</li>
                    </ol>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['bp-sec8'] = {
            title: '블루프린트와 SpawnActor 종합',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Blueprint</div>
                    <h1>블루프린트와 SpawnActor 완전 정복</h1>
                </div>
                <h2>Overview</h2>
                <p>블루프린트 시스템의 내부 구조와 SpawnActor의 전체 과정을 <strong>종합 정리</strong>합니다.</p>

                <h2>학습 로드맵</h2>
                <div class="flow-container">
                    <div class="flow-diagram" style="flex-wrap: wrap; justify-content: center; gap: 15px;">
                        <div class="flow-node" style="background: #e3f2fd;">1. 블루프린트 기본</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node" style="background: #e3f2fd;">2. SCS 구조</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node" style="background: #fff3cd;">3. 오버라이딩</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node" style="background: #fff3cd;">4. ExecuteConstruction</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node" style="background: #d4edda;">5. 생성 준비</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node" style="background: #d4edda;">6. 생성 및 등록</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node" style="background: #c8e6c9;">7. SpawnActor 통합</div>
                    </div>
                </div>

                <h2>핵심 개념 1: 블루프린트 이중 구조</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>구분</th><th>UBlueprint</th><th>GeneratedClass</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>역할</td><td>설계도</td><td>실제 클래스</td></tr>
                            <tr><td>용도</td><td>에디터 편집</td><td>게임 사용</td></tr>
                            <tr><td>변경</td><td>자유롭게</td><td>컴파일마다 갱신</td></tr>
                        </tbody>
                    </table>
                </div>

                <h2>핵심 개념 2: SCS 독립 관리</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">원리</span></div>
                    <div class="code-content">
<pre><code>각 BP는 자신의 컴포넌트만 SCS에 저장
→ 메모리 최적화
→ InheritableComponentHandler로 부모 수정</code></pre>
                    </div>
                </div>

                <h2>핵심 개념 3: 컴포넌트 등록 순서</h2>
                <div class="flow-container">
                    <div class="flow-diagram" style="flex-direction: column; gap: 10px;">
                        <div class="flow-node" style="background: #ff9800; color: white;">1. RootComponent</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #2196f3; color: white;">2. Native C++ Components</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #4caf50; color: white;">3. Blueprint Components</div>
                    </div>
                </div>
                <div class="callout tip">
                    <div class="callout-title">실무 활용</div>
                    <p>Lyra의 ExtensionComponent는 이 등록 순서를 활용합니다!</p>
                </div>

                <h2>핵심 개념 4: ExecuteConstruction 8단계</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">흐름</span></div>
                    <div class="code-content">
<pre><code>계층 수집 → 컴포넌트 수집 → Native 정리 → BP 생성
→ Root 등록 → 미등록 확인 → Construction Script → OnConstruction</code></pre>
                    </div>
                </div>

                <h2>핵심 개념 5: 오버라이딩 체크</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">흐름</span></div>
                    <div class="code-content">
<pre><code>GetActualComponentTemplate
→ InheritableComponentHandler 순회
→ 오버라이드 있으면 사용, 없으면 원본 사용</code></pre>
                    </div>
                </div>

                <h2>핵심 개념 6: SpawnActor 6단계</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">흐름</span></div>
                    <div class="code-content">
<pre><code>NewObject → Native 처리 → 지연(선택)
→ FinishSpawning(BP 생성) → PostActorConstruction
→ BeginPlay</code></pre>
                    </div>
                </div>

                <h2>실무 활용 팁</h2>
                <h3>✅ DO</h3>
                <div class="callout tip">
                    <div class="callout-title">권장 사항</div>
                    <ul>
                        <li><strong>Construction Script 활용</strong>: 모든 컴포넌트 생성 완료 후 동작, 동적 컴포넌트 생성에 적합</li>
                        <li><strong>PostInitializeComponents 활용</strong>: 액터 생존이 확실히 보장되는 시점, 중요한 객체 생성에 사용</li>
                        <li><strong>컴포넌트 등록 순서 이해</strong>: Lyra의 ExtensionComponent 패턴 활용, Root → Native → BP 순서 활용</li>
                    </ul>
                </div>

                <h3>❌ DON'T</h3>
                <div class="callout warning">
                    <div class="callout-title">주의 사항</div>
                    <ul>
                        <li><strong>Construction Script에서 CDO 의존</strong>: Construction Script 컴포넌트는 CDO/SCS에 반영 안 됨</li>
                        <li><strong>PreInitializeComponents에서 중요 객체 생성</strong>: 액터가 Destroy될 수 있음</li>
                        <li><strong>SCS 구조 무시</strong>: 메모리 최적화 구조 이해 필요</li>
                    </ul>
                </div>

                <h2>학습 체크리스트</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>항목</th><th>핵심 질문</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>블루프린트 기본</td><td>왜 실시간 컴파일이 가능한가?</td></tr>
                            <tr><td>SCS 구조</td><td>왜 독립적으로 관리하나?</td></tr>
                            <tr><td>오버라이딩</td><td>어떻게 부모 컴포넌트를 수정하나?</td></tr>
                            <tr><td>ExecuteConstruction</td><td>8단계는 무엇인가?</td></tr>
                            <tr><td>생성 준비</td><td>RootNode의 부모는 누구인가?</td></tr>
                            <tr><td>생성 및 등록</td><td>오버라이딩 체크는 어떻게 하나?</td></tr>
                            <tr><td>SpawnActor 통합</td><td>전체 흐름은?</td></tr>
                        </tbody>
                    </table>
                </div>

                <div class="callout important">
                    <div class="callout-title">Blueprint 챕터 학습 완료!</div>
                    <p>블루프린트 시스템과 SpawnActor의 모든 것을 마스터했습니다.</p>
                    <ul>
                        <li>UBlueprint와 GeneratedClass의 이중 구조</li>
                        <li>SCS의 독립적 컴포넌트 관리</li>
                        <li>InheritableComponentHandler의 오버라이딩 시스템</li>
                        <li>ExecuteConstruction의 8단계 과정</li>
                        <li>SpawnActor의 6단계 전체 흐름</li>
                    </ul>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        // ========================================
        // Render: 카메라와 렌더링 시스템 (8.95~8.97)
        // ========================================

        sectionData['render-sec1'] = {
            title: '카메라 업데이트',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Render</div>
                    <h1>카메라 업데이트</h1>
                </div>
                <h2>Overview</h2>
                <p>카메라는 <strong>World Tick의 거의 마지막 단계</strong>에서 업데이트됩니다. 모든 게임 로직이 완료된 뒤에 촬영해야 위치나 애니메이션이 정확하게 보이기 때문입니다.</p>

                <h2>핵심 포인트</h2>
                <ul>
                    <li>카메라는 World Tick의 거의 마지막 단계에서 업데이트</li>
                    <li>모든 게임 로직이 완료된 뒤에 촬영</li>
                    <li>ViewTarget을 통해 POV 계산</li>
                    <li>여러 카메라가 있어도 ViewTarget 시스템으로 자동 처리</li>
                </ul>

                <h2>카메라 업데이트 호출 체인</h2>
                <div class="flow-container">
                    <div class="flow-diagram" style="flex-direction: column; gap: 8px;">
                        <div class="flow-node">UWorld::Tick</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">APlayerController::UpdateCameraManager</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">APlayerCameraManager::UpdateCamera</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">APlayerCameraManager::DoUpdateCamera</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">APlayerCameraManager::UpdateViewTarget</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">AActor::CalcCamera</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: var(--success); color: #000;">첫 번째 활성 CameraComponent에서 POV 가져오기</div>
                    </div>
                </div>

                <h2>UWorld::Tick에서 카메라 업데이트</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code class="language-cpp">// World Tick의 마지막 순간에 Camera View Update
for (FConstPlayerControllerIterator Iterator = GetPlayerControllerIterator(); Iterator; ++Iterator)
{
    if (APlayerController* PlayerController = Iterator->Get())
    {
        PlayerController->UpdateCameraManager(DeltaSeconds);
    }
}

// 특수 Tick을 Group 별로 실행 - (다섯 번째)
if (bDoingActorTicks)
{
    RunTickGroup(TG_PostUpdateWork);
    RunTickGroup(TG_LastDemotable);
}</code></pre>
                    </div>
                </div>
                <div class="callout">
                    <div class="callout-title">순서</div>
                    <ol>
                        <li>일반 Tick 그룹들 실행</li>
                        <li><strong>카메라 업데이트</strong> ← 여기!</li>
                        <li>특수 Tick 그룹 실행 (PostUpdateWork, LastDemotable)</li>
                    </ol>
                </div>

                <h2>DoUpdateCamera: 본격적인 카메라 업데이트</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code class="language-cpp">void APlayerCameraManager::DoUpdateCamera(float DeltaTime)
{
    // ViewTarget을 통해 POV 업데이트
    UpdateViewTarget(ViewTarget, DeltaTime);

    // 카메라 블렌딩 처리
    FMinimalViewInfo NewPOV = ViewTarget.POV;
    NewPOV.BlendViewInfo(PendingViewTarget.POV, BlendPct);

    // 최종 POV를 카메라에 저장 (캐시)
    FillCameraCache(NewPOV);
}</code></pre>
                    </div>
                </div>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>단계</th><th>함수</th><th>역할</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>1</td><td>UpdateViewTarget</td><td>ViewTarget을 통해 POV 업데이트</td></tr>
                            <tr><td>2</td><td>BlendViewInfo</td><td>카메라 블렌딩 처리</td></tr>
                            <tr><td>3</td><td>FillCameraCache</td><td>최종 POV를 카메라에 저장</td></tr>
                        </tbody>
                    </table>
                </div>

                <h2>AActor::CalcCamera - 핵심 함수</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code class="language-cpp">void AActor::CalcCamera(float DeltaTime, FMinimalViewInfo& OutResult)
{
    // Actor가 소유한 CameraComponent를 모두 순회
    // 첫 번째로 활성화되어 있는 컴포넌트의 POV 데이터 반환
    for (UCameraComponent* CameraComponent : GetComponents&lt;UCameraComponent&gt;())
    {
        if (CameraComponent->IsActive())
        {
            CameraComponent->GetCameraView(DeltaTime, OutResult);
            return;
        }
    }

    // 카메라 컴포넌트가 없으면 액터 자신의 위치/회전 사용
    OutResult.Location = GetActorLocation();
    OutResult.Rotation = GetActorRotation();
}</code></pre>
                    </div>
                </div>
                <div class="callout tip">
                    <div class="callout-title">여러 카메라 문제 해결</div>
                    <p>ViewTarget의 카메라를 통해 POV를 가져오므로, 카메라가 여러 대 있어도 문제 없음!</p>
                </div>

                <h2>POV와 ViewTarget</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>용어</th><th>설명</th></tr>
                        </thead>
                        <tbody>
                            <tr><td><strong>POV</strong></td><td>Point of View - 현재 바라보는 시점 (위치, 회전, FOV)</td></tr>
                            <tr><td><strong>ViewTarget</strong></td><td>일반적으로 빙의(Possess)한 액터 - 카메라 정보 제공 대상</td></tr>
                        </tbody>
                    </table>
                </div>
                <div class="flow-container">
                    <div class="flow-diagram">
                        <div class="flow-node">ViewTarget (Actor)</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">CameraComponent</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">POV</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node" style="background: var(--success); color: #000;">화면에 렌더링</div>
                    </div>
                </div>

                <h2>핵심 정리</h2>
                <div class="callout important">
                    <div class="callout-title">카메라 업데이트 핵심</div>
                    <ul>
                        <li><strong>업데이트 타이밍</strong>: World Tick의 거의 마지막, 모든 게임 로직 완료 후</li>
                        <li><strong>여러 카메라 처리</strong>: ViewTarget 시스템 활용, 첫 번째 활성 카메라 사용</li>
                        <li><strong>POV 계산 흐름</strong>: ViewTarget → CameraComponent → POV</li>
                        <li><strong>캐싱</strong>: FillCameraCache로 POV 저장, 다른 시스템에서 빠르게 접근</li>
                    </ul>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['render-sec2'] = {
            title: '화면 렌더링',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Render</div>
                    <h1>화면 렌더링</h1>
                </div>
                <h2>Overview</h2>
                <p>렌더링은 <strong>Engine Tick의 후반부</strong>에서 실행됩니다. 카메라 업데이트 이후 렌더링이 진행되며, Canvas 단위로 처리됩니다.</p>

                <h2>핵심 포인트</h2>
                <ul>
                    <li>렌더링은 Engine Tick 후반부에서 실행</li>
                    <li>카메라 업데이트 이후 렌더링 진행</li>
                    <li>Canvas 단위로 렌더링 처리</li>
                    <li>FSceneViewFamilyContext가 View 생명주기 관리</li>
                    <li>렌더링 스레드로 정보 전달</li>
                </ul>

                <h2>렌더링 타이밍</h2>
                <div class="flow-container">
                    <div class="flow-diagram" style="flex-direction: column; gap: 8px;">
                        <div class="flow-node">Engine Tick 시작</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">World Tick 실행 (게임 로직)</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">카메라 업데이트 (World Tick 후반)</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: var(--success); color: #000;">렌더링 진행 (Engine Tick 후반)</div>
                    </div>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code class="language-cpp">// UEngine::Tick
// 엔진 틱 후반부에서 Viewport의 Draw 함수를 호출하며 렌더링 진행
GameViewport->Viewport->Draw();</code></pre>
                    </div>
                </div>
                <div class="callout tip">
                    <div class="callout-title">중요</div>
                    <p>엔진 틱 안에서 월드 틱이 실행되므로, 카메라 업데이트 이후 렌더링이 진행됨</p>
                </div>

                <h2>FViewport::Draw - Canvas 생성</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code class="language-cpp">// 렌더링은 캔버스라는 단위로 진행
// Viewport는 여러 개의 캔버스를 가질 수 있음
// (콘솔 게임에서 2인용 게임을 할 때 사용 가능)

// 캔버스 생성
FCanvas Canvas(this, nullptr, ViewportWorld,
              ViewportWorld ? ViewportWorld->GetFeatureLevel() : GMaxRHIFeatureLevel,
              FCanvas::CDM_DeferDrawing,
              ViewportClient->ShouldDPIScaleSceneCanvas() ? ViewportClient->GetDPIScale() : 1.0f);

// 화면에 그릴 때 사용할 사각형 영역을 설정
Canvas.SetRenderTargetRect(FIntRect(0, 0, SizeX, SizeY));

{
    // ViewportClient에 캔버스를 넣어 Draw 함수 호출
    ViewportClient->Draw(this, &Canvas);
}</code></pre>
                    </div>
                </div>
                <div class="callout">
                    <div class="callout-title">Canvas 개념</div>
                    <ul>
                        <li>렌더링은 <strong>Canvas</strong> 단위로 진행</li>
                        <li>Viewport는 <strong>여러 캔버스</strong> 소유 가능</li>
                        <li>분할 화면 게임에서 활용 (2인용 등)</li>
                    </ul>
                </div>

                <h2>FSceneViewFamilyContext</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>클래스</th><th>역할</th></tr>
                        </thead>
                        <tbody>
                            <tr><td><strong>FSceneView</strong></td><td>카메라가 촬영한 3D 정보를 2D 모니터에 출력하기 위해 가공한 완성된 데이터</td></tr>
                            <tr><td><strong>FSceneViewFamilyContext</strong></td><td>FSceneView를 배열 형태로 소유, 생명주기 관리 (RAII 패턴)</td></tr>
                        </tbody>
                    </table>
                </div>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code class="language-cpp">// 매 프레임마다 씬을 렌더링하기 위해 생성되는 View에 대한 RAII인 ViewFamily 생성
FSceneViewFamilyContext ViewFamily(
    FSceneViewFamily::ConstructionValues(InViewport, MyWorld->Scene, EngineShowFlags)
        .SetRealtimeUpdate(true)
        .SetRequireMobileMultiView(bRequireMultiView)
);</code></pre>
                    </div>
                </div>

                <h2>LocalPlayer별 View 생성</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code class="language-cpp">// 로컬 플레이어를 순회하며 CalcSceneView를 호출하여
// 플레이어 카메라 정보를 활용해 FSceneView를 생성

for (FLocalPlayerIterator Iterator(GEngine, MyWorld); Iterator; ++Iterator)
{
    ULocalPlayer* LocalPlayer = *Iterator;
    if (LocalPlayer)
    {
        // 플레이어의 정보를 통하여 최종적인 View 생성 (카메라 정보)
        FSceneView* View = LocalPlayer->CalcSceneView(
            &ViewFamily,
            ViewLocation,
            ViewRotation,
            InViewport,
            nullptr,
            bStereoRendering ? ViewIndex : INDEX_NONE
        );
    }
}</code></pre>
                    </div>
                </div>
                <div class="callout">
                    <div class="callout-title">멀티플레이어 지원</div>
                    <ul>
                        <li>로컬 플레이어 수만큼 View 생성</li>
                        <li>스테레오 렌더링(VR) 지원</li>
                        <li>ViewFamily에 자동 저장</li>
                    </ul>
                </div>

                <h2>렌더링 스레드로 전달</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code class="language-cpp">// ViewFamily에 있는 SceneView 정보(카메라 위치, 렌더링 설정 등)를
// 렌더링 스레드로 전달하여 실제 렌더링 과정 시작
GetRendererModule().BeginRenderingViewFamily(SceneCanvas, &ViewFamily);</code></pre>
                    </div>
                </div>

                <h2>전체 렌더링 흐름</h2>
                <div class="flow-container">
                    <div class="flow-diagram" style="flex-direction: column; gap: 8px;">
                        <div class="flow-node">UEngine::Tick</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">Viewport::Draw</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">Canvas 생성</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">ViewportClient::Draw</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">FSceneViewFamilyContext 생성</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">LocalPlayer 순회 → CalcSceneView</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">ViewFamily에 저장</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: var(--success); color: #000;">렌더링 스레드로 전달 → 실제 렌더링</div>
                    </div>
                </div>

                <h2>핵심 정리</h2>
                <div class="callout important">
                    <div class="callout-title">화면 렌더링 핵심</div>
                    <ul>
                        <li><strong>Canvas</strong>: 렌더링 기본 단위, 그릴 영역 지정, 여러 Canvas로 분할 화면 가능</li>
                        <li><strong>FSceneView</strong>: 3D → 2D 투영 데이터, 카메라 시점 및 투영 정보 포함</li>
                        <li><strong>FSceneViewFamilyContext</strong>: FSceneView 배열 관리, RAII 패턴으로 생명주기 관리</li>
                        <li><strong>기억할 것</strong>: 엔진 틱에서 렌더링이 호출된다!</li>
                    </ul>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['render-sec3'] = {
            title: '렌더링 정보 계산',
            html: `
                <div class="content-header">
                    <div class="breadcrumb">Render</div>
                    <h1>렌더링 정보 계산</h1>
                </div>
                <h2>Overview</h2>
                <p>SceneView를 생성하는 과정과 어떤 정보를 참조하는지 상세히 분석합니다. <strong>카메라 업데이트 때 저장한 POV 정보</strong>를 여기서 가져옵니다.</p>

                <h2>핵심 포인트</h2>
                <ul>
                    <li>CalcSceneView에서 FSceneView 생성</li>
                    <li>CalcSceneViewInitOptions로 투영 데이터 계산</li>
                    <li>GetViewPoint에서 카메라 업데이트 정보 가져오기</li>
                    <li>3D → 2D 투영에 필요한 수학 계산</li>
                    <li>Camera Update 때 저장한 POV 정보 활용</li>
                </ul>

                <h2>주요 함수 체인</h2>
                <div class="flow-container">
                    <div class="flow-diagram" style="flex-direction: column; gap: 8px;">
                        <div class="flow-node">ULocalPlayer::CalcSceneView</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">ULocalPlayer::CalcSceneViewInitOptions</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">ULocalPlayer::GetProjectionData</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">ULocalPlayer::GetViewPoint</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: var(--success); color: #000;">PlayerCameraManager::GetCameraCacheView</div>
                    </div>
                </div>

                <h2>CalcSceneView</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code class="language-cpp">FSceneView* ULocalPlayer::CalcSceneView(
    class FSceneViewFamily* ViewFamily,
    FVector& OutViewLocation,
    FRotator& OutViewRotation,
    FViewport* Viewport,
    class FViewElementDrawer* ViewDrawer,
    int32 StereoViewIndex)
{
    // View에 대한 종합적인 정보를 계산해서 저장
    FSceneViewInitOptions ViewInitOptions;
    if (!CalcSceneViewInitOptions(ViewInitOptions, Viewport, ViewDrawer, StereoViewIndex))
    {
        return nullptr;
    }

    // ViewInitOptions 정보를 이용하여 최종적인 View 생성
    FSceneView* const View = new FSceneView(ViewInitOptions);
    OutViewLocation = View->ViewLocation;
    OutViewRotation = View->ViewRotation;

    // Family에 저장
    ViewFamily->Views.Add(View);

    return View;
}</code></pre>
                    </div>
                </div>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>단계</th><th>작업</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>1</td><td>CalcSceneViewInitOptions: View 초기화 옵션 계산</td></tr>
                            <tr><td>2</td><td>FSceneView 생성: 계산된 옵션으로 View 생성</td></tr>
                            <tr><td>3</td><td>ViewFamily에 추가: RAII 관리 대상에 포함</td></tr>
                        </tbody>
                    </table>
                </div>

                <h2>CalcSceneViewInitOptions - 3단계 검증</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code class="language-cpp">bool ULocalPlayer::CalcSceneViewInitOptions(
    struct FSceneViewInitOptions& ViewInitOptions,
    FViewport* Viewport,
    class FViewElementDrawer* ViewDrawer,
    int32 StereoViewIndex)
{
    // 1️⃣ 비정상적인 상황이면 실패
    if ((PlayerController == NULL) ||
        (Size.X <= 0.f) ||
        (Size.Y <= 0.f) ||
        (Viewport == NULL))
    {
        return false;
    }

    // 2️⃣ 투영 데이터 계산
    if (GetProjectionData(Viewport, ViewInitOptions, StereoViewIndex) == false)
    {
        return false;
    }

    // 3️⃣ 잘못된 View 데이터가 있으면 실패
    if (!ViewInitOptions.IsValidViewRectangle())
    {
        return false;
    }

    ViewInitOptions.ViewActor = PlayerController->GetViewTarget();
    return true;
}</code></pre>
                    </div>
                </div>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>단계</th><th>검증 내용</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>1</td><td>기본 조건 체크: Controller, Size, Viewport 존재 확인</td></tr>
                            <tr><td>2</td><td>투영 데이터 계산: GetProjectionData 호출</td></tr>
                            <tr><td>3</td><td>유효성 검사: ViewRectangle 확인</td></tr>
                        </tbody>
                    </table>
                </div>

                <h2>GetViewPoint - 카메라 정보 가져오기</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">C++</span></div>
                    <div class="code-content">
<pre><code class="language-cpp">void ULocalPlayer::GetViewPoint(FMinimalViewInfo& OutViewInfo)
{
    if(PlayerController != NULL)
    {
        if (PlayerController->PlayerCameraManager != NULL)
        {
            // 카메라에 저장된 View, FOV 값 저장
            OutViewInfo = PlayerController->PlayerCameraManager->GetCameraCacheView();
            OutViewInfo.FOV = PlayerController->PlayerCameraManager->GetFOVAngle();

            // 카메라의 Location, Rotation 정보 저장
            PlayerController->GetPlayerViewPoint(
                OutViewInfo.Location,
                OutViewInfo.Rotation
            );
        }
    }

    OutViewInfo.DesiredFOV = OutViewInfo.FOV;
}</code></pre>
                    </div>
                </div>
                <div class="callout tip">
                    <div class="callout-title">핵심!</div>
                    <p><strong>카메라 업데이트 때 POV 정보를 카메라에 저장한 것을 가져옴!</strong></p>
                </div>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>함수</th><th>가져오는 정보</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>GetCameraCacheView()</td><td>카메라 업데이트 시 저장된 POV</td></tr>
                            <tr><td>GetFOVAngle()</td><td>Field of View 각도</td></tr>
                            <tr><td>GetPlayerViewPoint()</td><td>카메라 위치와 회전</td></tr>
                        </tbody>
                    </table>
                </div>

                <h2>카메라 업데이트와 렌더링 연결</h2>
                <div class="flow-container">
                    <div class="flow-diagram" style="flex-direction: column; gap: 8px;">
                        <div class="flow-node" style="background: #e3f2fd;">카메라 업데이트 단계</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">DoUpdateCamera → UpdateViewTarget → CalcCamera</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">POV 계산</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: var(--warning); color: #000;">FillCameraCache (POV 저장!)</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: #d4edda;">렌더링 단계</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">CalcSceneView → GetProjectionData → GetViewPoint</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node" style="background: var(--success); color: #000;">GetCameraCacheView (POV 가져오기!)</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">투영 데이터 계산 → FSceneView 생성</div>
                    </div>
                </div>

                <h2>데이터 흐름 정리</h2>
                <div class="code-block">
                    <div class="code-header"><span class="code-lang">흐름</span></div>
                    <div class="code-content">
<pre><code>카메라 업데이트
    ↓
POV 계산
    ↓
FillCameraCache (저장)
    ↓
... (시간 경과)
    ↓
렌더링 시작
    ↓
GetCameraCacheView (로드)
    ↓
투영 계산
    ↓
화면 렌더링</code></pre>
                    </div>
                </div>

                <h2>주요 클래스</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr><th>클래스</th><th>역할</th></tr>
                        </thead>
                        <tbody>
                            <tr><td><strong>FMinimalViewInfo</strong></td><td>카메라 시점 정보 (Location, Rotation, FOV 포함)</td></tr>
                            <tr><td><strong>FSceneViewInitOptions</strong></td><td>SceneView 초기화 옵션 (투영 데이터, ViewActor 정보)</td></tr>
                            <tr><td><strong>FSceneView</strong></td><td>최종 렌더링 정보 (3D → 2D 투영 완료)</td></tr>
                        </tbody>
                    </table>
                </div>

                <h2>핵심 정리</h2>
                <div class="callout important">
                    <div class="callout-title">렌더링 정보 계산 핵심</div>
                    <ul>
                        <li><strong>SceneView 생성 3단계</strong>: ViewInitOptions 계산 → FSceneView 생성 → ViewFamily에 추가</li>
                        <li><strong>투영 데이터 계산</strong>: 3D 공간을 2D 화면으로 변환하는 복잡한 그래픽스 수학</li>
                        <li><strong>카메라 정보 재사용</strong>: 카메라 업데이트 시 FillCameraCache로 저장 → 렌더링 시 GetCameraCacheView로 로드</li>
                        <li><strong>검증 과정</strong>: Controller/Viewport 존재, 투영 데이터 유효성, ViewRectangle 확인</li>
                    </ul>
                </div>

                <h2>Render 챕터 학습 완료</h2>
                <div class="callout tip">
                    <div class="callout-title">학습 체크리스트</div>
                    <ul>
                        <li>✅ 카메라 업데이트 타이밍: World Tick 거의 마지막</li>
                        <li>✅ 렌더링 타이밍: Engine Tick 후반부</li>
                        <li>✅ POV 저장/로드: FillCameraCache → GetCameraCacheView</li>
                        <li>✅ SceneView 생성: CalcSceneView → CalcSceneViewInitOptions → GetProjectionData → GetViewPoint</li>
                        <li>✅ 주요 클래스: FMinimalViewInfo, FSceneViewInitOptions, FSceneView, FSceneViewFamilyContext</li>
                    </ul>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        // ========================================
        // Garbage Collector Chapter
        // ========================================

        sectionData['gc-sec1'] = {
            title: 'GC 개념 및 과정',
            html: `
                <h2>가비지 컬렉션이란?</h2>
                <div class="callout info">
                    <div class="callout-title">Garbage Collection (GC)</div>
                    더 이상 사용하지 않는 메모리를 <strong>자동으로 관리하고 해제</strong>하는 프로세스입니다.
                    개발자의 휴먼 에러를 줄여주는 핵심 시스템입니다.
                </div>

                <h3>GC가 필요한 이유</h3>
                <div class="flow-container">
                    <div class="flow-diagram">
                        <div class="flow-node">필요없는 메모리</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">반드시 해제 필요</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">메모리 누수 방지</div>
                    </div>
                </div>

                <div class="table-container">
                    <table>
                        <tr><th>작업</th><th>난이도</th><th>문제점</th></tr>
                        <tr><td><strong>new 타이밍</strong></td><td>쉬움</td><td>객체가 필요한 시점은 명확</td></tr>
                        <tr><td><strong>delete 타이밍</strong></td><td>어려움</td><td>언제 제거해야 하는지 파악 어려움</td></tr>
                    </table>
                </div>

                <h3>GC의 장점</h3>
                <div class="table-container">
                    <table>
                        <tr><th>측면</th><th>효과</th></tr>
                        <tr><td>개발 집중도</td><td>메모리 해제 걱정 없이 로직 구현</td></tr>
                        <tr><td>생산성</td><td>개발 속도 향상</td></tr>
                        <tr><td>안정성</td><td>더블 프리, 댕글링 포인터 방지</td></tr>
                    </table>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">GC가 방지하는 문제들</span>
                    </div>
                    <div class="code-content">
                        <pre><code>// 문제 1: 더블 프리 (Double Free)
delete object;
delete object; // 크래시!

// 문제 2: 사용 중인 메모리 해제
delete player;
enemy->Attack(player); // 댕글링 포인터!

// GC 사용 시: 이런 문제 자동 방지</code></pre>
                    </div>
                </div>

                <h3>GC의 단점</h3>
                <div class="callout warning">
                    <div class="callout-title">Stop-the-World</div>
                    GC가 작동하는 동안 프로그램의 <strong>모든 작업이 일반적으로 멈춥니다</strong>.
                </div>

                <div class="flow-container">
                    <div class="flow-diagram">
                        <div class="flow-node">GC 실행 시작</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node warning">프로그램 일시 정지</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">Mark & Sweep</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">프로그램 재개</div>
                    </div>
                </div>

                <h3>GC 처리 방식: Mark and Sweep</h3>
                <div class="flow-container">
                    <div class="flow-diagram">
                        <div class="flow-node">모든 객체</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">Root로부터 도달 가능?</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node highlight">Yes: Mark 표시</div>
                    </div>
                    <div class="flow-diagram">
                        <div class="flow-node">Mark 있음</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node success">살아남음</div>
                    </div>
                    <div class="flow-diagram">
                        <div class="flow-node">Mark 없음</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node warning">Sweep 제거</div>
                    </div>
                </div>

                <h3>스마트 포인터 vs GC</h3>
                <div class="table-container">
                    <table>
                        <tr><th>항목</th><th>스마트 포인터</th><th>가비지 컬렉션</th></tr>
                        <tr><td><strong>메모리 반환 시점</strong></td><td>참조 카운트 0이 되면 즉시</td><td>GC 실행 시 (예측 어려움)</td></tr>
                        <tr><td><strong>시점 예측</strong></td><td>예측 가능</td><td>예측 어려움</td></tr>
                        <tr><td><strong>순환 참조</strong></td><td>수동 처리 필요 (weak_ptr)</td><td>자동 감지 및 처리</td></tr>
                        <tr><td><strong>개발 난이도</strong></td><td>중간</td><td>낮음</td></tr>
                    </table>
                </div>

                <div class="callout important">
                    <div class="callout-title">언리얼에서 스마트 포인터가 필요한 이유</div>
                    <ul>
                        <li>GC는 <strong>UObject</strong>에만 적용됨</li>
                        <li>일반 C++ 객체는 GC 대상이 아님</li>
                        <li>스마트 포인터가 없으면 메모리 누수 발생 가능</li>
                    </ul>
                </div>

                <h3>GC 3단계 과정</h3>
                <div class="flow-container">
                    <div class="flow-diagram">
                        <div class="flow-node">1단계: Pre GC</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node highlight">2단계: Mark</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node warning">3단계: Sweep</div>
                    </div>
                </div>

                <div class="table-container">
                    <table>
                        <tr><th>단계</th><th>작업</th><th>설명</th></tr>
                        <tr><td><strong>Pre GC</strong></td><td>비동기 로딩 처리</td><td>안정적인 상태 만들기</td></tr>
                        <tr><td><strong>Mark</strong></td><td>Root부터 마킹</td><td>도달 가능한 객체에 표시</td></tr>
                        <tr><td><strong>Sweep</strong></td><td>마킹 없는 객체 제거</td><td>BeginDestroy → FinishDestroy → 메모리 반납</td></tr>
                    </table>
                </div>

                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['gc-sec2'] = {
            title: 'GC 준비',
            html: `
                <h2>GC 시작 시점</h2>
                <div class="callout info">
                    <div class="callout-title">핵심 질문</div>
                    <ul>
                        <li>GC는 <strong>어디서 시작</strong>하는가?</li>
                        <li>사전 준비 단계에서 <strong>어떤 작업</strong>을 진행하는가?</li>
                    </ul>
                </div>

                <h3>World Tick의 마지막 단계</h3>
                <div class="flow-container">
                    <div class="flow-diagram">
                        <div class="flow-node">UWorld::Tick</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">게임 로직 실행</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">액터 Tick</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">물리 시뮬레이션</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node highlight">GC 시작</div>
                    </div>
                </div>

                <div class="callout important">
                    <div class="callout-title">GC는 매 프레임마다 실행되지 않습니다!</div>
                </div>

                <div class="table-container">
                    <table>
                        <tr><th>설정</th><th>값</th><th>설명</th></tr>
                        <tr><td><strong>기본 주기</strong></td><td>61초</td><td>기본 설정으로 약 61초마다 실행</td></tr>
                        <tr><td><strong>설정 위치</strong></td><td>Project Settings</td><td>Time Between Purging Pending Kill Objects</td></tr>
                        <tr><td><strong>변경 가능</strong></td><td>Yes</td><td>프로젝트 설정에서 조절 가능</td></tr>
                    </table>
                </div>

                <div class="callout warning">
                    <div class="callout-title">주기 설정 주의사항</div>
                    <ul>
                        <li><strong>너무 짧으면</strong>: GC가 자주 실행 → 프레임 드롭 빈번</li>
                        <li><strong>너무 길면</strong>: 제거 대기 객체 누적 → 한 번에 많은 객체 제거 → 심한 프레임 드롭</li>
                    </ul>
                </div>

                <h3>GC 호출 체인</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">UWorld::Tick</span>
                    </div>
                    <div class="code-content">
                        <pre><code>void UWorld::Tick(...)
{
    // ... 게임 로직 실행 ...
    // ... 액터 Tick ...
    // ... 컴포넌트 Tick ...

    // GC 시작 (약 61초마다 한 번)
    GEngine->ConditionalCollectGarbage();

    // ... World Tick 마무리 ...
}</code></pre>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">UEngine::ConditionalCollectGarbage - 중복 호출 방지</span>
                    </div>
                    <div class="code-content">
                        <pre><code>void UEngine::ConditionalCollectGarbage()
{
    // 같은 프레임에 중복 호출 방지
    if (GFrameCounter != LastGCFrame)
    {
        // 본격적인 GC 호출
        if (TryCollectGarbage(GARBAGE_COLLECTION_KEEPFLAGS, true))
        {
            // GC로 제거된 액터들을 World 목록에서 삭제
            ForEachObjectOfClass(UWorld::StaticClass(), [](UObject* World)
            {
                CastChecked<UWorld>(World)->CleanupActors();
            });

            // GC 관련 플래그 초기화
            bFullPurgeTriggered = false;
            bShouldDelayGarbageCollect = false;
            TimeSinceLastPendingKillPurge = 0.0f;
        }
    }
}</code></pre>
                    </div>
                </div>

                <h3>핵심 함수: PerformReachabilityAnalysisAndConditionallyPurgeGarbage</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">GC의 3단계</span>
                    </div>
                    <div class="code-content">
                        <pre><code>void FReachabilityAnalysisState::PerformReachabilityAnalysisAndConditionallyPurgeGarbage(...)
{
    // 통계 초기화
    GGCStats = UE::GC::Private::FStats();
    GGCStats.bInProgress = true;

    // 1단계: Pre GC - 비동기 로딩 처리
    UE::GC::PreCollectGarbageImpl<true>(ObjectKeepFlags);

    // 2단계: Mark - Root부터 도달 가능한 객체 마킹
    PerformReachabilityAnalysis();

    // 3단계: Sweep - 마킹되지 않은 객체 제거
    UE::GC::PostCollectGarbageImpl<true>(ObjectKeepFlags);
}</code></pre>
                    </div>
                </div>

                <h3>Pre GC: 비동기 로딩 처리</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">PreCollectGarbageImpl</span>
                    </div>
                    <div class="code-content">
                        <pre><code>void PreCollectGarbageImpl(EObjectFlags KeepFlags)
{
    // 비동기 로딩 중이면 완료될 때까지 대기
    if (IsAsyncLoading())
    {
        FlushAsyncLoading();
        GGCStats.bFlushedAsyncLoading = true;
    }
}</code></pre>
                    </div>
                </div>

                <div class="callout warning">
                    <div class="callout-title">왜 비동기 로딩을 먼저 처리할까?</div>
                    GC 도중 비동기 로딩이 계속되면:
                    <ul>
                        <li>새로운 객체가 계속 생성됨</li>
                        <li>기존 참조 관계 변경</li>
                        <li>GC 추적 실패</li>
                        <li>생성되자마자 제거될 수 있음!</li>
                    </ul>
                </div>

                <div class="flow-container">
                    <div class="flow-diagram">
                        <div class="flow-node">GC 시작 전</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node highlight">FlushAsyncLoading</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">참조 관계 확정</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node success">안전하게 GC 시작</div>
                    </div>
                </div>

                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['gc-sec3'] = {
            title: '초기 도달 가능성 처리',
            html: `
                <h2>StartReachabilityAnalysis</h2>
                <div class="callout info">
                    <div class="callout-title">핵심 질문</div>
                    <ul>
                        <li><strong>도달 가능성 분석</strong>은 어떻게 시작되는가?</li>
                        <li><strong>마킹을 제거</strong>하는 방법은 무엇인가?</li>
                        <li><strong>Root는 어떻게</strong> 가져와서 마킹하는가?</li>
                    </ul>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">StartReachabilityAnalysis 구조</span>
                    </div>
                    <div class="code-content">
                        <pre><code>void FRealtimeGC::StartReachabilityAnalysis(EObjectFlags KeepFlags, const EGCOptions Options)
{
    // 1단계: FGCObject 대상 별도 수집
    BeginInitialReferenceCollection(Options);

    // 2단계: 초기 루트 후보 초기화
    InitialObjects.Reset();

    // 3단계: 모든 Object를 Unreachable로 표시 후 Root만 Reachable로 표시
    MarkObjectsAsUnreachable(KeepFlags);
}</code></pre>
                    </div>
                </div>

                <h3>FGCObject란?</h3>
                <div class="callout important">
                    <div class="callout-title">UPROPERTY의 중요성</div>
                    <ul>
                        <li>GC가 참조 관계를 파악하려면 UPROPERTY 필수</li>
                        <li>UPROPERTY 없으면 GC는 해당 객체를 아무도 참조하지 않는다고 판단</li>
                        <li>UObject를 소유하려면 UPROPERTY 매크로 필수!</li>
                    </ul>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">FGCObject 사용 예시</span>
                    </div>
                    <div class="code-content">
                        <pre><code>// 일반 구조체는 UPROPERTY를 사용할 수 없음
// FGCObject를 상속받아 해결!

struct FTestGC : public FGCObject
{
public:
    // GC에게 소유한 객체를 알림
    virtual void AddReferencedObjects(FReferenceCollector& Collector) override
    {
        // 이 객체를 GC 카운팅에 포함해주세요!
        Collector.AddReferencedObject(Object);
    }

private:
    TObjectPtr<UObject> Object = nullptr;
};</code></pre>
                    </div>
                </div>

                <h3>Root Object란?</h3>
                <div class="callout info">
                    <div class="callout-title">Root Object</div>
                    GC의 <strong>도달 가능성 분석이 시작되는 지점</strong>.
                    항상 메모리에 올라와 있어야 하는 <strong>핵심 객체</strong>.
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">UEngine::Init - Root 등록</span>
                    </div>
                    <div class="code-content">
                        <pre><code>void UEngine::Init(IEngineLoop* InEngineLoop)
{
    // UEngine을 Root Object로 등록
    AddToRoot();
}</code></pre>
                    </div>
                </div>

                <h3>SwapReachableAndMaybeUnreachable - 천재적인 최적화</h3>
                <div class="callout tip">
                    <div class="callout-title">천재적인 아이디어!</div>
                    모든 객체를 순회하지 않고 <strong>flag의 의미를 바꿔버립니다</strong>!
                </div>

                <div class="table-container">
                    <table>
                        <tr><th>방법</th><th>시간 복잡도</th><th>설명</th></tr>
                        <tr><td><strong>일반적 방법</strong></td><td>O(N)</td><td>모든 객체 순회 필요</td></tr>
                        <tr><td><strong>Swap 방법</strong></td><td>O(1)</td><td>Flag 의미만 변경</td></tr>
                    </table>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">SwapReachableAndMaybeUnreachable</span>
                    </div>
                    <div class="code-content">
                        <pre><code>// 일반적 방법 (비효율)
for (UObject* obj : AllObjects)
{
    obj->SetFlag(Unreachable);  // 매우 느림!
}

// 언리얼의 방법 (효율적)
static void FGCFlags::SwapReachableAndMaybeUnreachable()
{
    // flag의 의미를 바꿔버림!
    Swap(ReachableObjectFlag, MaybeUnreachableObjectFlag);
}

// Before Swap:
// 0x01 = Reachable, 0x02 = MaybeUnreachable
// PlayerA: 0x01 (Reachable)

// After Swap:
// 0x01 = MaybeUnreachable, 0x02 = Reachable
// PlayerA: 0x01 (MaybeUnreachable) ← 자동 변경!</code></pre>
                    </div>
                </div>

                <h3>Root Object 마킹 및 수집</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">MarkRootObjectsAsReachable</span>
                    </div>
                    <div class="code-content">
                        <pre><code>void FRealtimeGC::MarkRootObjectsAsReachable(...)
{
    // AddToRoot로 Root Object들이 저장된 배열 복사
    TArray<int32> RootsArray(GRoots.Array());

    // 모든 Root Object를 병렬로 처리
    ParallelFor(MarkRootsState.NumWorkerThreads(), 1,
        [&RootsArray](int32 ThreadIndex)
        {
            // Root Object 가져오기
            FUObjectItem* RootItem = &GUObjectArray.GetObjectItemArrayUnsafe()[RootsArray[...]];
            UObject* Object = static_cast<UObject*>(RootItem->Object);

            // Reachable로 표시
            FGCFlags::FastMarkAsReachableInterlocked_ForGC(RootItem);

            // 마킹된 객체를 결과 배열에 추가
            ThreadState.Payload.Add(Object);
        }
    );
}</code></pre>
                    </div>
                </div>

                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['gc-sec4'] = {
            title: '도달 가능성 분석',
            html: `
                <h2>Schema 시스템</h2>
                <div class="callout info">
                    <div class="callout-title">핵심 질문</div>
                    <ul>
                        <li><strong>Mark</strong>는 어떻게 진행되는가?</li>
                        <li><strong>참조</strong>를 어떻게 추적하는가?</li>
                        <li><strong>Schema</strong>란 무엇인가?</li>
                    </ul>
                </div>

                <h3>ProcessObjectArray - 핵심 로직</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">ProcessObjectArray</span>
                    </div>
                    <div class="code-content">
                        <pre><code>void TFastReferenceCollector::ProcessObjectArray(FWorkerContext& Context)
{
    // 1단계: FGCObject에서 수집한 객체 먼저 Reachable 표시
    Context.ReferencingObject = FGCObject::GGCObjectReferencer;
    for (UObject** InitialRef : Context.InitialNativeReferences)
    {
        Dispatcher.HandleKillableReference(*InitialRef, ...);
    }

    // 2단계: InitialObjects (Root Objects) 순회하며 ProcessObjects 호출
    TConstArrayView<UObject*> CurrentObjects = Context.InitialObjects;
    while (true)
    {
        // Root부터 시작해서 멤버 목록을 따라가며 Reachable 표시
        ProcessObjects(Dispatcher, CurrentObjects);

        // 객체가 참조하고 있는 다른 UObject가 존재하는지 판단
        FWorkBlock* Block = RemainingObjects.PopFullBlock();

        // 없으면 종료
        if (!Block) break;

        // 있으면 다음 순회 대상으로 설정
        CurrentObjects = MakeArrayView(Block->Objects, BlockSize);
    }
}</code></pre>
                    </div>
                </div>

                <h3>Schema란 무엇인가?</h3>
                <div class="callout important">
                    <div class="callout-title">Schema의 핵심 역할</div>
                    GC가 필요한 멤버 변수(UObject 포인터)의 리플렉션 데이터를
                    <strong>배열 형식</strong>으로 미리 모아둔 최적화 구조체
                </div>

                <h4>과거의 문제점</h4>
                <div class="table-container">
                    <table>
                        <tr><th>문제</th><th>영향</th></tr>
                        <tr><td>연결 리스트 형식의 Reflection 데이터</td><td>캐시 성능 급격히 저하</td></tr>
                        <tr><td>모든 UPROPERTY 변수 순회</td><td>GC 대상이 아닌 변수까지 접근</td></tr>
                    </table>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">예시: GC 대상 vs 비대상</span>
                    </div>
                    <div class="code-content">
                        <pre><code>UPROPERTY()
float HP;  // GC 대상 아님

UPROPERTY()
TObjectPtr<UTestComponent> TestComp = nullptr;  // GC 대상!

UPROPERTY()
float MP;  // GC 대상 아님

float Exp;  // UPROPERTY 아님</code></pre>
                    </div>
                </div>

                <h4>Schema의 해결책</h4>
                <div class="callout tip">
                    <div class="callout-title">Schema 시스템의 장점</div>
                    <ul>
                        <li>배열 형식으로 GC 필요 변수만 저장</li>
                        <li>캐시 성능 향상</li>
                        <li>불필요한 접근 제거</li>
                        <li>GC 속도 대폭 향상</li>
                    </ul>
                </div>

                <h3>VisitMembers - 멤버 변수 순회</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">VisitMembers</span>
                    </div>
                    <div class="code-content">
                        <pre><code>void VisitMembers(TDispatcher& Dispatcher, FSchemaView Schema, const UObject* Instance)
{
    // Schema에서 멤버 변수 정보가 압축된 Word 단위로 순회
    for (const FMemberWord* WordIt = Schema.GetWords(); true; ++WordIt)
    {
        // Word 내부에 Member는 4개 → Quad 형태로 저장
        const FMemberWordUnpacked Quad(WordIt->Members);

        // 멤버 변수 순회
        for (FMemberUnpacked Member : Quad.Members)
        {
            // 멤버 데이터의 실제 메모리 주소 계산
            uint8* MemberPtr = (uint8*)(InstanceCursor + Member.WordOffset);

            // 멤버 변수 타입에 맞게 처리
            switch (Member.Type)
            {
            case EMemberType::Reference:
                Dispatcher.HandleKillableReference(*(UObject**)MemberPtr, ...);
                break;

            case EMemberType::ReferenceArray:
                Dispatcher.HandleKillableArray(*(TArray<UObject*>*)MemberPtr, ...);
                break;

            case EMemberType::Stop:
                return;
            }
        }
    }
}</code></pre>
                    </div>
                </div>

                <h3>HandleValidReference - 마킹 처리</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">HandleValidReference</span>
                    </div>
                    <div class="code-content">
                        <pre><code>static bool TReachabilityProcessor::HandleValidReference(
    FWorkerContext& Context,
    FImmutableReference Reference,
    FReferenceMetadata Metadata)
{
    // Reachable로 변경
    if (FGCFlags::MarkAsReachableInterlocked_ForGC(Metadata.ObjectItem))
    {
        // ObjectsToSerialize에 추가
        // 이 객체가 참조하는 다른 객체도 나중에 탐색
        Context.ObjectsToSerialize.Add<Options>(Reference.Object);

        return true;
    }

    return false;
}</code></pre>
                    </div>
                </div>

                <h3>참조 체인 탐색 - SNS 친구 찾기 비유</h3>
                <div class="flow-container">
                    <div class="flow-diagram">
                        <div class="flow-node highlight">Root Object (나)</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">Player, NPC, Monster</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">Weapon, Helmet, Item</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">...</div>
                    </div>
                </div>

                <div class="callout info">
                    <div class="callout-title">재귀적 탐색</div>
                    모든 연결된 친구(객체)를 찾을 때까지 반복!
                    ObjectsToSerialize에서 다음 객체를 가져와 계속 탐색.
                </div>

                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['gc-sec5'] = {
            title: '메모리 반환',
            html: `
                <h2>Sweep 단계 - 가비지 객체 정리</h2>
                <div class="callout info">
                    <div class="callout-title">핵심 질문</div>
                    <ul>
                        <li><strong>마킹되지 않은 객체</strong>를 어떻게 수집하는가?</li>
                        <li><strong>Sweep 단계</strong>에서 어떤 작업을 수행하는가?</li>
                        <li><strong>메모리 반환</strong>은 어떻게 이루어지는가?</li>
                    </ul>
                </div>

                <h3>WeakPtr 자동 처리</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">ClearWeakReferences</span>
                    </div>
                    <div class="code-content">
                        <pre><code>static void ClearWeakReferences(TConstArrayView<TUniquePtr<FWorkerContext>> Contexts)
{
    for (FWeakReferenceInfo& ReferenceInfo : Context->WeakReferences)
    {
        UObject* ReferencedObject = ReferenceInfo.ReferencedObject;

        // GC 예정 체크
        if (ReferencedObject && FGCFlags::IsMaybeUnreachable_ForGC(ReferencedObject))
        {
            // Reference를 직접 nullptr로 변환
            *ReferenceInfo.Reference = nullptr;
        }
    }
}</code></pre>
                    </div>
                </div>

                <div class="callout tip">
                    <div class="callout-title">WeakPtr 자동 처리의 이점</div>
                    <ul>
                        <li>GC가 자동으로 WeakPtr을 nullptr로 변환</li>
                        <li>개발자는 nullptr 체크만 하면 됨</li>
                        <li>IsValid() 체크 불필요</li>
                    </ul>
                </div>

                <h3>GatherUnreachableObjects - 마킹되지 않은 객체 수집</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">GatherUnreachableObjects</span>
                    </div>
                    <div class="code-content">
                        <pre><code>void GatherUnreachableObjects(...)
{
    // 병렬로 UObject들 모두 순회하면서 Reachable 표시되지 않은 대상 수집
    ParallelFor(GGatherUnreachableObjectsState.NumWorkerThreads(), 1,
        [](int32 ThreadIndex)
        {
            while (Iterator.Index <= Iterator.LastIndex)
            {
                // GUObjectArray에서 ObjectItem 가져오기
                FUObjectItem* ObjectItem = &GUObjectArray.GetObjectItemArrayUnsafe()[Iterator.Index++];

                // MaybeUnreachable인지 체크
                if (FGCFlags::IsMaybeUnreachable_ForGC(ObjectItem))
                {
                    // Unreachable로 표시
                    FGCFlags::SetUnreachable(ObjectItem);

                    // 수집 배열에 추가
                    Iterator.Payload.Add({ ObjectItem });
                }
            }
        }
    );

    // 수집한 Object를 GUnreachableObjects에 저장
    GGatherUnreachableObjectsState.Finish(GUnreachableObjects);
}</code></pre>
                    </div>
                </div>

                <h3>GUObjectArray - 모든 UObject 저장소</h3>
                <div class="callout info">
                    <div class="callout-title">GUObjectArray</div>
                    <ul>
                        <li>모든 UObject 저장</li>
                        <li>생성 시 자동 등록</li>
                        <li>GC가 이 배열을 순회</li>
                        <li>UObjectItem으로 Wrapping하여 저장</li>
                    </ul>
                </div>

                <h3>객체 파괴: BeginDestroy → FinishDestroy</h3>
                <div class="flow-container">
                    <div class="flow-diagram">
                        <div class="flow-node">BeginDestroy</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">IsReadyForFinishDestroy 대기</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">FinishDestroy</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">소멸자 호출</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node success">메모리 반환</div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">ConditionalFinishDestroy</span>
                    </div>
                    <div class="code-content">
                        <pre><code>bool UObject::ConditionalFinishDestroy()
{
    if (!HasAnyFlags(RF_FinishDestroyed))
    {
        // RF_FinishDestroyed 플래그 설정
        SetFlags(RF_FinishDestroyed);

        // 최종 메모리 정리
        // 중요! 자식 클래스에서 오버라이드할 때
        // Super::FinishDestroy()는 맨 마지막에 호출!
        FinishDestroy();

        // 일련 번호 초기화로 WeakObjectPtr 무효화
        GUObjectArray.ResetSerialNumber(this);
    }
}</code></pre>
                    </div>
                </div>

                <div class="callout warning">
                    <div class="callout-title">FinishDestroy 호출 순서 - 매우 중요!</div>
                    자식이 먼저, 부모가 나중에 호출되어야 합니다!
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">올바른 FinishDestroy 오버라이드</span>
                    </div>
                    <div class="code-content">
                        <pre><code>class UMyComponent : public UActorComponent
{
    virtual void FinishDestroy() override
    {
        // 1단계: 자식의 리소스 먼저 정리
        CleanupMyResources();

        // 2단계: 부모는 맨 마지막!
        Super::FinishDestroy();  // 마지막에 호출!
    }
};</code></pre>
                    </div>
                </div>

                <h3>DestroyObjects - 최종 메모리 반환</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">DestroyObjects</span>
                    </div>
                    <div class="code-content">
                        <pre><code>void DestroyObjects(...)
{
    for (auto& UnreachableObject : GUnreachableObjects)
    {
        UObject* Object = UnreachableObject.Object;

        // 소멸자 호출 및 메모리 공간 반납
        Object->~UObject();
        GUObjectAllocator.FreeUObject(Object);

        UnreachableObject.Object = nullptr;
    }
}</code></pre>
                    </div>
                </div>

                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        sectionData['gc-sec6'] = {
            title: 'AddToRoot와 Destroy Actor',
            html: `
                <h2>AddToRoot - Root Object 등록</h2>
                <div class="callout info">
                    <div class="callout-title">핵심 질문</div>
                    <ul>
                        <li><strong>Root Object</strong>는 어떻게 등록되는가?</li>
                        <li><strong>AddToRoot()</strong>는 어떤 작업을 수행하는가?</li>
                        <li><strong>GRoots 배열</strong>은 무엇인가?</li>
                    </ul>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">UEngine::Init - Root 등록</span>
                    </div>
                    <div class="code-content">
                        <pre><code>void UEngine::Init(IEngineLoop* InEngineLoop)
{
    // Engine의 Loop를 GEngineLoop로 등록
    EngineLoop = InEngineLoop;

    // Engine SubSystem 생성
    EngineSubsystemCollection.Initialize(this);

    // UEngine을 Root Object로 등록
    AddToRoot();

    // ...
}</code></pre>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">SetRootFlags - 핵심 로직</span>
                    </div>
                    <div class="code-content">
                        <pre><code>bool FUObjectItem::SetRootFlags(EInternalObjectFlags FlagsToSet)
{
    const int32 OldFlags = GetFlagsInternal();

    // 이미 Root로 설정되어 있는지 체크
    if ((OldFlags & RootFlags) == 0)
    {
        // GRoots에 별도로 저장!
        GRoots.Add(GUObjectArray.ObjectToIndex(Object));

        // Root Flag 설정
        bIChangedIt = AtomicallySetFlag_ForGC(FlagsToSet);
    }

    // Root로 설정된 게 맞으면 Reachable로 무조건 설정
    if (bIChangedIt)
    {
        Object->MarkAsReachable();
    }

    return bIChangedIt;
}</code></pre>
                    </div>
                </div>

                <div class="callout warning">
                    <div class="callout-title">Root Object 남용 금지</div>
                    <ul>
                        <li>Root로 설정하면 GC에서 절대 제거 안 됨</li>
                        <li>메모리에서 영구 상주</li>
                        <li>메모리 누수 가능</li>
                        <li>제거: RemoveFromRoot()로 해제 가능</li>
                    </ul>
                </div>

                <h2>Destroy Actor - Actor 제거</h2>
                <div class="callout important">
                    <div class="callout-title">특이한 점</div>
                    Destroy() 함수는 <strong>AActor 클래스부터 존재</strong>합니다.
                    UObject에는 없습니다!
                </div>

                <h3>왜 Destroy 함수가 필요한가?</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">SpawnActor - Level에 저장</span>
                    </div>
                    <div class="code-content">
                        <pre><code>AActor* const Actor = NewObject<AActor>(...);

// 생성하자마자 레벨에 저장!
LevelToSpawnIn->TryAddActorToList(Actor, false);</code></pre>
                    </div>
                </div>

                <div class="callout warning">
                    <div class="callout-title">문제 상황</div>
                    <ul>
                        <li>Actor는 생성 즉시 Level에 추가됨</li>
                        <li>Level이 Actor를 참조하고 있음</li>
                        <li>UPROPERTY로 관리되므로 GC가 인식</li>
                        <li><strong>참조가 해제되지 않음!</strong></li>
                    </ul>
                </div>

                <h3>UWorld::DestroyActor 주요 작업</h3>
                <div class="flow-container">
                    <div class="flow-diagram">
                        <div class="flow-node">유효성 검사</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">부착된 액터 분리</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">Owner 제거</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node highlight">Level에서 제거</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node warning">MarkAsGarbage</div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">KillFlag 처리</span>
                    </div>
                    <div class="code-content">
                        <pre><code>static void TReachabilityProcessor::HandleBatchedReference(...)
{
    // KillFlag가 설정된 경우
    if (Metadata.Has(KillFlag))
    {
        // Reference를 nullptr로 변환
        KillReference(*Reference.Mutable);
    }
    else
    {
        HandleValidReference(Context, Reference, Metadata);
    }
}

void KillReference(UObject*& Object)
{
    // 단순히 nullptr로 변경
    Object = nullptr;
}</code></pre>
                    </div>
                </div>

                <div class="callout tip">
                    <div class="callout-title">천재적인 설계</div>
                    <ul>
                        <li>멤버 변수가 가지고 있던 참조를 nullptr로 변경</li>
                        <li><strong>Level이 해당 Actor를 더 이상 소유하지 않게 됨</strong></li>
                        <li>모든 참조가 끊어짐</li>
                        <li>GC가 자동으로 제거</li>
                    </ul>
                </div>

                <div class="callout warning">
                    <div class="callout-title">Destroy는 즉시 제거가 아님!</div>
                    Destroy() 함수를 호출해도 <strong>바로 Actor가 제거되지 않습니다</strong>!
                    <ul>
                        <li>KillFlag 설정 → PendingKill 상태</li>
                        <li>다음 GC 실행 시 실제 메모리 제거</li>
                    </ul>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">올바른 유효성 체크</span>
                    </div>
                    <div class="code-content">
                        <pre><code>// IsValid 사용 (올바름)
if (IsValid(MyActor))
{
    // 사용 가능
}

// nullptr 체크만으로는 부족! (위험)
if (MyActor != nullptr)
{
    // PendingKill 상태일 수 있음!
}</code></pre>
                    </div>
                </div>

                <h2>GC 챕터 학습 완료</h2>
                <div class="callout tip">
                    <div class="callout-title">학습 체크리스트</div>
                    <ul>
                        <li>GC 개념: Mark and Sweep, 3단계 과정</li>
                        <li>GC 시작 시점: World Tick 마지막, 약 61초마다</li>
                        <li>Swap 최적화: O(1)에 모든 객체 마킹 초기화</li>
                        <li>Schema 시스템: GC 필요 변수만 배열로 저장</li>
                        <li>Sweep 단계: BeginDestroy → FinishDestroy → 메모리 반환</li>
                        <li>AddToRoot: Root Object 등록, GC에서 영구 보호</li>
                        <li>Destroy Actor: KillFlag 설정, GC가 처리</li>
                        <li>IsValid 필수: PendingKill 상태 확인</li>
                    </ul>
                </div>
                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        // ========================================
        // Pointer Chapter - TObjectPtr
        // ========================================
        sectionData['ptr-sec1'] = {
            title: 'TObjectPtr - 강한 참조 포인터',
            html: `
                <h2>TObjectPtr 개요</h2>
                <div class="callout">
                    <div class="callout-title">TObjectPtr란?</div>
                    언리얼 5부터 <strong>UObject 참조의 표준</strong>으로 권장되는 강한 참조(Strong Reference) 포인터입니다.
                </div>

                <h3>핵심 특징</h3>
                <div class="concept-card">
                    <div class="card-title">TObjectPtr의 4가지 핵심</div>
                    <ul>
                        <li><strong>FObjectPtr 래핑</strong>: FObjectPtr을 래핑한 템플릿 클래스</li>
                        <li><strong>디버깅 정보</strong>: 에디터에서 디버깅 정보 풍부</li>
                        <li><strong>점진적 GC 지원</strong>: UE 5.4+ 쓰기 장벽(Write Barrier)</li>
                        <li><strong>쿠킹 최적화</strong>: 쿠킹 시 Raw Pointer로 자동 변환</li>
                    </ul>
                </div>

                <h3>기본 사용법</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">UE4 vs UE5 방식</span>
                    </div>
                    <div class="code-content">
                        <pre><code>// UE4 방식 (Raw Pointer)
UPROPERTY()
AActor* MyActor;

// UE5 권장 방식 (TObjectPtr)
UPROPERTY()
TObjectPtr&lt;AActor&gt; MyActor;</code></pre>
                    </div>
                </div>

                <h2>TObjectPtr 구조</h2>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">TObjectPtr 정의</span>
                    </div>
                    <div class="code-content">
                        <pre><code>template &lt;typename T&gt;
struct TObjectPtr
{
    // UObject 헬퍼 함수들
    bool IsResolved() const { return ObjectPtr.IsResolved(); }
    FString GetPath() const { return ObjectPtr.GetPath(); }
    FString GetPathName() const { return ObjectPtr.GetPathName(); }
    FName GetFName() const { return ObjectPtr.GetFName(); }
    FString GetName() const { return ObjectPtr.GetName(); }
    bool IsA(const UClass* SomeBase) const;

    template &lt;typename U&gt;
    bool IsA() const { return ObjectPtr.IsA&lt;U&gt;(); }

    // 핵심: FObjectPtr 래핑
    FObjectPtr ObjectPtr;
};</code></pre>
                    </div>
                </div>

                <div class="flow-container">
                    <div class="flow-diagram">
                        <div class="flow-node">TObjectPtr&lt;T&gt;</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node highlight">FObjectPtr</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">UObject* Handle</div>
                    </div>
                </div>

                <h2>FObjectPtr의 핵심 - GC Barrier</h2>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">FObjectPtr 내부</span>
                    </div>
                    <div class="code-content">
                        <pre><code>struct FObjectPtr
{
#if UE_OBJECT_PTR_GC_BARRIER
    // 점진적 GC를 위한 최적화
    FObjectPtr(FObjectPtr&& InOther) : Handle(MoveTemp(InOther.Handle))
    {
        // 이동 생성자에서도 Reachable 마킹
        ConditionallyMarkAsReachable(*this);
    }

    FObjectPtr(const FObjectPtr& InOther) : Handle(InOther.Handle)
    {
        // 복사 생성자에서 Reachable 마킹
        ConditionallyMarkAsReachable(*this);
    }

    FObjectPtr& operator=(const FObjectPtr& InOther)
    {
        // 대입 전 대상 객체 마킹
        ConditionallyMarkAsReachable(InOther);
        Handle = InOther.Handle;
        return *this;
    }
#endif

    // 실제 UObject 포인터
    UObject* Handle;
};</code></pre>
                    </div>
                </div>

                <div class="callout important">
                    <div class="callout-title">ConditionallyMarkAsReachable</div>
                    <ul>
                        <li>객체가 대입될 때 즉시 Reachable로 마킹</li>
                        <li>점진적 GC 중에도 참조 관계를 놓치지 않도록 보장</li>
                        <li><strong>"쓰기 장벽(Write Barrier)"</strong> 기법 구현</li>
                    </ul>
                </div>

                <h2>점진적 GC (Incremental GC)</h2>
                <h3>기존 GC의 문제점</h3>
                <div class="flow-container">
                    <div class="flow-diagram vertical">
                        <div class="flow-node">전통적인 Mark and Sweep</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">한 프레임에 모든 GC 처리</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">탐색할 객체가 많으면?</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node warning">프리즈 현상 발생!</div>
                    </div>
                </div>

                <h3>점진적 GC의 해결책</h3>
                <div class="flow-container">
                    <div class="flow-diagram vertical">
                        <div class="flow-node highlight">점진적 GC (Incremental GC)</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">여러 프레임에 걸쳐 분산 처리</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node">한 프레임당 부하 감소</div>
                        <span class="flow-arrow">↓</span>
                        <div class="flow-node success">부드러운 실행!</div>
                    </div>
                </div>

                <h3>쓰기 장벽 (Write Barrier)이 필요한 이유</h3>
                <div class="concept-card">
                    <div class="card-title">참조 추적 문제</div>
                    <pre style="background: var(--bg-code); padding: 15px; border-radius: 6px; font-size: 0.85rem;">
Frame 1: GC Mark 시작
    → Object A 마킹

Frame 2: GC Mark 진행 중
    → 코드에서 Object B를 새로 참조!
    → Raw Pointer로는 추적 불가능

Frame 3: GC Sweep
    → Object B가 제거될 수 있음!</pre>
                </div>

                <h3>TObjectPtr의 해결책</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">쓰기 장벽 작동</span>
                    </div>
                    <div class="code-content">
                        <pre><code>// TObjectPtr 사용 시
MyObjectPtr = SomeObject;  // 대입 연산

// 내부적으로 자동 호출
ConditionallyMarkAsReachable(SomeObject);

// GC가 즉시 인식!
// "아, 이 객체는 방금 사용되기 시작했으니 삭제하면 안 되겠구나!"</code></pre>
                    </div>
                </div>

                <div class="concept-card">
                    <div class="card-title">쓰기 장벽 시각화</div>
                    <pre style="background: var(--bg-code); padding: 15px; border-radius: 6px; font-size: 0.85rem;">
Frame 1 (Mark 시작):
    GC: Object A 마킹 중...

Frame 2 (Mark 진행):
    코드: MyPtr = Object B  ← TObjectPtr 대입
          ↓
    자동: ConditionallyMarkAsReachable(B)
          ↓
    GC: Object B도 Reachable로 마킹!

Frame 3 (Mark 계속):
    GC: Object B는 이미 마킹됨
        ✅ 안전하게 보호됨

Frame 4 (Sweep):
    GC: Object B는 살아있음
        ✅ 제거되지 않음</pre>
                </div>

                <h2>쿠킹 최적화 - UnrealObjectPtrTool</h2>
                <div class="flow-container">
                    <div class="flow-diagram">
                        <div class="flow-node">개발 단계</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node highlight">TObjectPtr&lt;T&gt;</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">UnrealObjectPtrTool</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node success">T* Raw Pointer</div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">쿠킹 변환</span>
                    </div>
                    <div class="code-content">
                        <pre><code>// 개발 중 (에디터)
UPROPERTY()
TObjectPtr&lt;AActor&gt; PlayerActor;
TObjectPtr&lt;UStaticMeshComponent&gt; MeshComp;
TArray&lt;TObjectPtr&lt;AActor&gt;&gt; Actors;

// ↓ UnrealObjectPtrTool ↓

// 쿠킹 후 (게임)
UPROPERTY()
AActor* PlayerActor;
UStaticMeshComponent* MeshComp;
TArray&lt;AActor*&gt; Actors;</code></pre>
                    </div>
                </div>

                <div class="callout tip">
                    <div class="callout-title">최고의 전략</div>
                    <ul>
                        <li><strong>개발 중</strong>: TObjectPtr로 디버깅 편의성 확보</li>
                        <li><strong>쿠킹 후</strong>: Raw Pointer로 성능 최적화</li>
                        <li>양쪽의 장점을 모두 가져감!</li>
                    </ul>
                </div>

                <h2>TObjectPtr 사용 이점</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>단계</th>
                                <th>포인터 타입</th>
                                <th>특징</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>개발</strong></td>
                                <td>TObjectPtr</td>
                                <td>디버깅 정보, 추적 가능, 안전성</td>
                            </tr>
                            <tr>
                                <td><strong>쿠킹</strong></td>
                                <td>Raw Pointer</td>
                                <td>성능 최적화, 메모리 효율</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>마이그레이션 가이드</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">UE4 → UE5 변환</span>
                    </div>
                    <div class="code-content">
                        <pre><code>// Before (UE4):
UPROPERTY()
AActor* PlayerActor;

UPROPERTY()
UStaticMeshComponent* MeshComp;

UPROPERTY()
TArray&lt;AActor*&gt; Actors;

// After (UE5):
UPROPERTY()
TObjectPtr&lt;AActor&gt; PlayerActor;

UPROPERTY()
TObjectPtr&lt;UStaticMeshComponent&gt; MeshComp;

UPROPERTY()
TArray&lt;TObjectPtr&lt;AActor&gt;&gt; Actors;</code></pre>
                    </div>
                </div>

                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" onclick="navigateSection(1)">다음 →</button>
                </div>
            `
        };

        // ========================================
        // Pointer Chapter - TWeakObjectPtr
        // ========================================
        sectionData['ptr-sec2'] = {
            title: 'TWeakObjectPtr - 약한 참조 포인터',
            html: `
                <h2>TWeakObjectPtr 개요</h2>
                <div class="callout">
                    <div class="callout-title">TWeakObjectPtr란?</div>
                    GC에 <strong>영향을 주지 않는</strong> 약한 참조(Weak Reference) 포인터입니다.
                    참조는 하지만 소유는 하지 않아서 <strong>Marking 대상이 아닙니다</strong>.
                </div>

                <h3>핵심 특징</h3>
                <div class="concept-card">
                    <div class="card-title">TWeakObjectPtr의 3가지 핵심</div>
                    <ul>
                        <li><strong>GC에 영향 없음</strong>: 약한 참조 (마킹 대상 아님)</li>
                        <li><strong>포인터 없음</strong>: 실제 포인터를 저장하지 않음</li>
                        <li><strong>Index + SerialNumber</strong>: GUObjectArray를 통해 추적</li>
                    </ul>
                </div>

                <h3>Strong vs Weak Reference</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>항목</th>
                                <th>TObjectPtr (Strong)</th>
                                <th>TWeakObjectPtr (Weak)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>저장 방식</strong></td>
                                <td>UObject* 포인터</td>
                                <td>Index + SerialNumber</td>
                            </tr>
                            <tr>
                                <td><strong>GC 마킹</strong></td>
                                <td>✅ 마킹 대상</td>
                                <td>❌ 마킹 대상 아님</td>
                            </tr>
                            <tr>
                                <td><strong>소유 관계</strong></td>
                                <td>강한 참조 (소유)</td>
                                <td>약한 참조 (비소유)</td>
                            </tr>
                            <tr>
                                <td><strong>객체 수명</strong></td>
                                <td>영향을 줌</td>
                                <td>영향을 주지 않음</td>
                            </tr>
                            <tr>
                                <td><strong>자동 nullptr</strong></td>
                                <td>❌</td>
                                <td>✅ (GC 시)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h2>FWeakObjectPtr 구조</h2>
                <div class="callout important">
                    <div class="callout-title">핵심 특징: 포인터가 없다!</div>
                    FWeakObjectPtr는 <strong>실제 raw pointer를 저장하지 않습니다</strong>.
                    ObjectIndex와 ObjectSerialNumber 두 개의 정수만 가집니다.
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">FWeakObjectPtr 정의</span>
                    </div>
                    <div class="code-content">
                        <pre><code>/**
 * 참조하는 UObject가 GC 대상이 되지 않음
 * → 객체의 생존 시간에 영향을 주지 않으면서 안전하게 참조
 *
 * 내부적으로 실제 UObject 포인터를 직접 저장하지 않음!!!
 * 대신, ObjectIndex와 ObjectSerialNumber를 저장
 */
struct FWeakObjectPtr
{
    // GUObjectArray의 Index
    int32 ObjectIndex;

    // UObject의 고유 번호
    int32 ObjectSerialNumber;
};</code></pre>
                    </div>
                </div>

                <div class="flow-container">
                    <div class="flow-diagram">
                        <div class="flow-node">TWeakObjectPtr&lt;T&gt;</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node highlight">FWeakObjectPtr</div>
                        <span class="flow-arrow">→</span>
                        <div class="flow-node">int32 ObjectIndex</div>
                        <span class="flow-arrow">+</span>
                        <div class="flow-node">int32 SerialNumber</div>
                    </div>
                </div>

                <h2>객체 추적 메커니즘</h2>
                <h3>Internal_Get 과정</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">객체 조회 과정</span>
                    </div>
                    <div class="code-content">
                        <pre><code>FUObjectItem* Internal_GetObjectItem() const
{
    // SerialNumber가 0이면 유효하지 않음
    if (ObjectSerialNumber == 0)
        return nullptr;

    // Index가 음수면 유효하지 않음
    if (ObjectIndex < 0)
        return nullptr;

    // GUObjectArray에서 Index로 ObjectItem 조회
    FUObjectItem* const ObjectItem = GUObjectArray.IndexToObject(ObjectIndex);
    if (!ObjectItem)
        return nullptr;

    // SerialNumber로 동일한 객체인지 확인
    // WeakObject가 가리키던 Index 자리에 다른 Object로 대체되었을 수 있음
    if (!SerialNumbersMatch(ObjectItem))
        return nullptr;

    return ObjectItem;
}

UObject* Internal_Get(bool bEvenIfGarbage) const
{
    FUObjectItem* const ObjectItem = Internal_GetObjectItem();

    return ((ObjectItem != nullptr) && GUObjectArray.IsValid(ObjectItem, bEvenIfGarbage))
        ? (UObject*)ObjectItem->Object
        : nullptr;
}</code></pre>
                    </div>
                </div>

                <h3>GUObjectArray 구조</h3>
                <div class="concept-card">
                    <div class="card-title">GUObjectArray</div>
                    <pre style="background: var(--bg-code); padding: 15px; border-radius: 6px; font-size: 0.85rem;">
┌──────────────────────────────────────┐
│         GUObjectArray                │
├──────────────────────────────────────┤
│  Index  │  FUObjectItem              │
├──────────────────────────────────────┤
│    0    │  UObject* + SerialNumber   │
│    1    │  UObject* + SerialNumber   │
│    2    │  UObject* + SerialNumber   │
│    3    │  nullptr (삭제됨)          │
│    4    │  UObject* + SerialNumber   │
│   ...   │  ...                       │
└──────────────────────────────────────┘</pre>
                </div>

                <h3>SerialNumber의 역할</h3>
                <div class="callout warning">
                    <div class="callout-title">Index 재사용 문제 해결</div>
                    <ol>
                        <li>ObjectA가 Index 100에 생성 (SerialNumber: 500)</li>
                        <li>TWeakObjectPtr가 (Index: 100, Serial: 500) 저장</li>
                        <li>ObjectA가 GC로 제거됨</li>
                        <li>ObjectB가 Index 100에 새로 생성 (SerialNumber: 600)</li>
                        <li>TWeakObjectPtr가 Index 100 조회</li>
                        <li>SerialNumber 500 != 600 → <strong>nullptr 반환 (안전!)</strong></li>
                    </ol>
                </div>

                <div class="concept-card">
                    <div class="card-title">SerialNumber 검증 시각화</div>
                    <pre style="background: var(--bg-code); padding: 15px; border-radius: 6px; font-size: 0.85rem;">
Before (ObjectA 생성):
    GUObjectArray[100]
        ├─ Object: ObjectA
        └─ SerialNumber: 500

    TWeakObjectPtr
        ├─ ObjectIndex: 100
        └─ ObjectSerialNumber: 500
        → Get() = ObjectA ✅

After GC (ObjectA 제거, ObjectB 생성):
    GUObjectArray[100]
        ├─ Object: ObjectB
        └─ SerialNumber: 600

    TWeakObjectPtr
        ├─ ObjectIndex: 100
        └─ ObjectSerialNumber: 500
        → SerialNumbersMatch: 500 != 600
        → Get() = nullptr ✅ (안전!)</pre>
                </div>

                <h2>순환 참조 방지</h2>
                <h3>문제: 순환 참조</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">순환 참조 문제</span>
                    </div>
                    <div class="code-content">
                        <pre><code>// ❌ 순환 참조 문제
class APlayerActor
{
    UPROPERTY()
    TObjectPtr&lt;AWeapon&gt; Weapon;  // Strong
};

class AWeapon
{
    UPROPERTY()
    TObjectPtr&lt;APlayerActor&gt; Owner;  // Strong
    // 💥 순환 참조! GC가 제거하지 못함
};</code></pre>
                    </div>
                </div>

                <h3>해결: Weak Reference</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">순환 참조 해결</span>
                    </div>
                    <div class="code-content">
                        <pre><code>// ✅ 순환 참조 해결
class APlayerActor
{
    UPROPERTY()
    TObjectPtr&lt;AWeapon&gt; Weapon;  // Strong (소유)
};

class AWeapon
{
    UPROPERTY()
    TWeakObjectPtr&lt;APlayerActor&gt; Owner;  // Weak (비소유)
    // ✅ 약한 참조로 순환 참조 해결
};</code></pre>
                    </div>
                </div>

                <div class="flow-container">
                    <div class="flow-diagram">
                        <div class="flow-node highlight">PlayerActor</div>
                        <span class="flow-arrow">→ Strong →</span>
                        <div class="flow-node">Weapon</div>
                        <span class="flow-arrow">- - Weak - -</span>
                        <div class="flow-node highlight">PlayerActor</div>
                    </div>
                </div>

                <h2>TWeakObjectPtr 사용 패턴</h2>
                <h3>패턴 1: 역참조 (Back Reference)</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">부모-자식 관계</span>
                    </div>
                    <div class="code-content">
                        <pre><code>// Owner → Component (Strong)
class AActor
{
    UPROPERTY()
    TObjectPtr&lt;UMyComponent&gt; Component;  // 소유
};

// Component → Owner (Weak, 역참조)
class UMyComponent
{
    UPROPERTY()
    TWeakObjectPtr&lt;AActor&gt; OwnerActor;  // 역참조
};</code></pre>
                    </div>
                </div>

                <h3>패턴 2: 캐싱 시스템</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">캐시 구현</span>
                    </div>
                    <div class="code-content">
                        <pre><code>class UTextureCache
{
    // Weak Reference로 캐싱
    TMap&lt;FName, TWeakObjectPtr&lt;UTexture&gt;&gt; Cache;

    UTexture* GetOrLoad(FName Name)
    {
        // 캐시 확인
        if (auto WeakTex = Cache.Find(Name))
        {
            if (WeakTex->IsValid())
            {
                return WeakTex->Get();  // 캐시 히트
            }
            else
            {
                Cache.Remove(Name);  // 제거됨, 캐시 무효화
            }
        }

        // 로드
        UTexture* NewTexture = LoadTexture(Name);
        Cache.Add(Name, NewTexture);
        return NewTexture;
    }
};</code></pre>
                    </div>
                </div>

                <h3>패턴 3: 옵저버 패턴</h3>
                <div class="code-block">
                    <div class="code-header">
                        <span class="code-lang">C++</span>
                        <span class="code-title">옵저버 목록</span>
                    </div>
                    <div class="code-content">
                        <pre><code>class AEventManager
{
    // 옵저버들을 Weak Reference로 관리
    TArray&lt;TWeakObjectPtr&lt;AActor&gt;&gt; Observers;

    void NotifyAll()
    {
        for (auto& WeakObserver : Observers)
        {
            if (WeakObserver.IsValid())
            {
                WeakObserver->OnEvent();
            }
        }
    }
};</code></pre>
                    </div>
                </div>

                <h2>주의사항</h2>
                <div class="callout warning">
                    <div class="callout-title">항상 유효성 검사 필수!</div>
                    <pre style="background: rgba(0,0,0,0.2); padding: 10px; border-radius: 4px; margin-top: 10px;"><code>// ❌ 나쁜 예
TWeakObjectPtr&lt;AActor&gt; WeakActor;
AActor* Actor = WeakActor.Get();
Actor->DoSomething();  // 💥 nullptr 역참조 가능!

// ✅ 좋은 예
if (WeakActor.IsValid())
{
    AActor* Actor = WeakActor.Get();
    Actor->DoSomething();
}

// ✅ 더 좋은 예 (한 줄로)
if (AActor* Actor = WeakActor.Get())
{
    Actor->DoSomething();
}</code></pre>
                </div>

                <div class="callout important">
                    <div class="callout-title">성능 고려사항</div>
                    <ul>
                        <li><strong>TObjectPtr (Strong)</strong>: 직접 포인터 접근 → 빠름</li>
                        <li><strong>TWeakObjectPtr (Weak)</strong>: GUObjectArray 조회 필요 → 약간 느림</li>
                        <li>Hot path에서는 한 번 Get()하여 로컬 변수에 저장 후 사용</li>
                    </ul>
                </div>

                <h2>포인터 선택 가이드</h2>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>시나리오</th>
                                <th>권장 포인터</th>
                                <th>이유</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>일반적인 멤버 변수</td>
                                <td>TObjectPtr</td>
                                <td>UE5 표준, 디버깅 편의</td>
                            </tr>
                            <tr>
                                <td>Parent → Child</td>
                                <td>TObjectPtr</td>
                                <td>소유 관계 (Strong)</td>
                            </tr>
                            <tr>
                                <td>Child → Parent</td>
                                <td>TWeakObjectPtr</td>
                                <td>역참조 (순환 방지)</td>
                            </tr>
                            <tr>
                                <td>캐시</td>
                                <td>TWeakObjectPtr</td>
                                <td>GC에 영향 없음</td>
                            </tr>
                            <tr>
                                <td>옵저버 목록</td>
                                <td>TWeakObjectPtr</td>
                                <td>자동 nullptr 처리</td>
                            </tr>
                            <tr>
                                <td>함수 파라미터</td>
                                <td>Raw Pointer</td>
                                <td>성능 (복사 비용)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h2>Pointer 챕터 학습 완료</h2>
                <div class="callout tip">
                    <div class="callout-title">학습 체크리스트</div>
                    <ul>
                        <li>TObjectPtr: FObjectPtr 래핑, 강한 참조, 점진적 GC 지원</li>
                        <li>쓰기 장벽: ConditionallyMarkAsReachable로 즉시 마킹</li>
                        <li>쿠킹 최적화: 개발 시 TObjectPtr → 쿠킹 후 Raw Pointer</li>
                        <li>TWeakObjectPtr: 약한 참조, Index + SerialNumber로 추적</li>
                        <li>GC 영향 없음: 포인터가 없어서 마킹 대상 아님</li>
                        <li>순환 참조 방지: 역참조에 Weak Reference 사용</li>
                        <li>유효성 검사 필수: 사용 전 항상 IsValid() 확인</li>
                    </ul>
                </div>

                <div class="nav-buttons">
                    <button class="nav-btn" onclick="navigateSection(-1)">← 이전</button>
                    <button class="nav-btn" disabled>다음 →</button>
                </div>
            `
        };

        // ========================================
        // Navigation Functions
        // ========================================

        let currentChapter = null;
        let currentSectionIndex = -1;
        const allSectionKeys = [
            'fw-sec1', 'fw-sec2', 'fw-sec3', 'fw-sec4', 'fw-sec5', 'fw-sec6', 'fw-sec7',
            'fw-sec8', 'fw-sec9', 'fw-sec10', 'fw-sec11', 'fw-sec12', 'fw-sec13', 'fw-sec14',
            'fw-sec15', 'fw-sec16', 'fw-sec17', 'fw-sec18', 'fw-sec19', 'fw-sec20', 'fw-sec21',
            'fw-sec22', 'fw-sec23', 'fw-sec24', 'fw-sec25', 'fw-sec26', 'fw-sec27', 'fw-sec28',
            'fw-sec29', 'fw-sec30',
            'tick-sec1', 'tick-sec2', 'tick-sec3', 'tick-sec4', 'tick-sec5', 'tick-sec6', 'tick-sec7',
            'tick-sec8', 'tick-sec9', 'tick-sec10', 'tick-sec11', 'tick-sec12', 'tick-sec13', 'tick-sec14',
            'tick-sec15', 'tick-sec16', 'tick-sec17', 'tick-sec18', 'tick-sec19', 'tick-sec20',
            'comp-sec1', 'comp-sec2', 'comp-sec3', 'comp-sec4', 'comp-sec5', 'comp-sec6', 'comp-sec7',
            'comp-sec8', 'comp-sec9', 'comp-sec10', 'comp-sec11', 'comp-sec12', 'comp-sec13', 'comp-sec14', 'comp-sec15',
            'obj-sec1', 'obj-sec2', 'obj-sec3', 'obj-sec4', 'obj-sec5',
            'spawn-sec1', 'spawn-sec2', 'spawn-sec3', 'spawn-sec4', 'spawn-sec5',
            'bp-sec1', 'bp-sec2', 'bp-sec3', 'bp-sec4', 'bp-sec5', 'bp-sec6', 'bp-sec7', 'bp-sec8',
            'render-sec1', 'render-sec2', 'render-sec3',
            'gc-sec1', 'gc-sec2', 'gc-sec3', 'gc-sec4', 'gc-sec5', 'gc-sec6',
            'ptr-sec1', 'ptr-sec2'
        ];

        function toggleChapter(element) {
            element.classList.toggle('collapsed');
            const list = element.nextElementSibling;
            list.classList.toggle('collapsed');
        }

        function showSection(chapter, sectionId) {
            currentChapter = chapter;
            currentSectionIndex = allSectionKeys.indexOf(sectionId);

            document.querySelectorAll('.section-item').forEach(item => {
                item.classList.remove('active');
            });

            const activeItem = document.querySelector(`[data-section="${sectionId}"]`);
            if (activeItem) {
                activeItem.classList.add('active');
            }

            const contentArea = document.getElementById('content');
            if (sectionData[sectionId]) {
                contentArea.innerHTML = sectionData[sectionId].html;
            }

            contentArea.scrollTop = 0;

            // Apply syntax highlighting
            if (typeof hljs !== 'undefined') {
                document.querySelectorAll('pre code').forEach((block) => {
                    hljs.highlightElement(block);
                });
            }
        }

        function navigateSection(direction) {
            const newIndex = currentSectionIndex + direction;
            if (newIndex >= 0 && newIndex < allSectionKeys.length) {
                const newSectionId = allSectionKeys[newIndex];
                let chapter = 'framework';
                if (newSectionId.startsWith('tick-')) {
                    chapter = 'tick';
                } else if (newSectionId.startsWith('comp-')) {
                    chapter = 'component';
                } else if (newSectionId.startsWith('obj-')) {
                    chapter = 'object';
                } else if (newSectionId.startsWith('spawn-')) {
                    chapter = 'spawn';
                } else if (newSectionId.startsWith('bp-')) {
                    chapter = 'blueprint';
                } else if (newSectionId.startsWith('render-')) {
                    chapter = 'render';
                } else if (newSectionId.startsWith('gc-')) {
                    chapter = 'gc';
                } else if (newSectionId.startsWith('ptr-')) {
                    chapter = 'ptr';
                }
                showSection(chapter, newSectionId);
            }
        }

        // Initialize first section
        showSection('framework', 'fw-sec1');
    </script>
</body>
</html>
